// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certifier.proto

#include "certifier.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr time_point::time_point(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : year_(0)
  , month_(0)
  , day_(0)
  , hour_(0)
  , seconds_(0)
  , minute_(0){}
struct time_pointDefaultTypeInternal {
  constexpr time_pointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~time_pointDefaultTypeInternal() {}
  union {
    time_point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT time_pointDefaultTypeInternal _time_point_default_instance_;
constexpr rsa_message::rsa_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : public_modulus_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , public_exponent_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_exponent_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_p_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_q_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_dp_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_dq_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct rsa_messageDefaultTypeInternal {
  constexpr rsa_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~rsa_messageDefaultTypeInternal() {}
  union {
    rsa_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT rsa_messageDefaultTypeInternal _rsa_message_default_instance_;
constexpr ecc_message::ecc_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ecc_messageDefaultTypeInternal {
  constexpr ecc_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ecc_messageDefaultTypeInternal() {}
  union {
    ecc_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ecc_messageDefaultTypeInternal _ecc_message_default_instance_;
constexpr key_message::key_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_format_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , secret_key_bits_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , certificate_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , other_key_formats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , not_before_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , not_after_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rsa_key_(nullptr)
  , ecc_key_(nullptr){}
struct key_messageDefaultTypeInternal {
  constexpr key_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~key_messageDefaultTypeInternal() {}
  union {
    key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT key_messageDefaultTypeInternal _key_message_default_instance_;
constexpr protected_blob_message::protected_blob_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct protected_blob_messageDefaultTypeInternal {
  constexpr protected_blob_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~protected_blob_messageDefaultTypeInternal() {}
  union {
    protected_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT protected_blob_messageDefaultTypeInternal _protected_blob_message_default_instance_;
constexpr entity_message::entity_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entity_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , measurement_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_(nullptr){}
struct entity_messageDefaultTypeInternal {
  constexpr entity_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~entity_messageDefaultTypeInternal() {}
  union {
    entity_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT entity_messageDefaultTypeInternal _entity_message_default_instance_;
constexpr vse_clause::vse_clause(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : verb_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , subject_(nullptr)
  , object_(nullptr)
  , clause_(nullptr){}
struct vse_clauseDefaultTypeInternal {
  constexpr vse_clauseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~vse_clauseDefaultTypeInternal() {}
  union {
    vse_clause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT vse_clauseDefaultTypeInternal _vse_clause_default_instance_;
constexpr vse_clauses::vse_clauses(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : clauses_(){}
struct vse_clausesDefaultTypeInternal {
  constexpr vse_clausesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~vse_clausesDefaultTypeInternal() {}
  union {
    vse_clauses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT vse_clausesDefaultTypeInternal _vse_clauses_default_instance_;
constexpr attestation::attestation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enclave_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , measurement_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , clause_(nullptr){}
struct attestationDefaultTypeInternal {
  constexpr attestationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~attestationDefaultTypeInternal() {}
  union {
    attestation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT attestationDefaultTypeInternal _attestation_default_instance_;
constexpr claim_message::claim_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : claim_format_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , claim_descriptor_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , not_before_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , not_after_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serialized_claim_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct claim_messageDefaultTypeInternal {
  constexpr claim_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~claim_messageDefaultTypeInternal() {}
  union {
    claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT claim_messageDefaultTypeInternal _claim_message_default_instance_;
constexpr signed_claim_message::signed_claim_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : serialized_claim_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signing_algorithm_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signing_key_(nullptr){}
struct signed_claim_messageDefaultTypeInternal {
  constexpr signed_claim_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~signed_claim_messageDefaultTypeInternal() {}
  union {
    signed_claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT signed_claim_messageDefaultTypeInternal _signed_claim_message_default_instance_;
constexpr oe_assertion::oe_assertion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , oe_report_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct oe_assertionDefaultTypeInternal {
  constexpr oe_assertionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~oe_assertionDefaultTypeInternal() {}
  union {
    oe_assertion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT oe_assertionDefaultTypeInternal _oe_assertion_default_instance_;
constexpr evidence::evidence(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : evidence_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serialized_evidence_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct evidenceDefaultTypeInternal {
  constexpr evidenceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~evidenceDefaultTypeInternal() {}
  union {
    evidence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT evidenceDefaultTypeInternal _evidence_default_instance_;
constexpr evidence_package::evidence_package(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fact_assertion_()
  , prover_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct evidence_packageDefaultTypeInternal {
  constexpr evidence_packageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~evidence_packageDefaultTypeInternal() {}
  union {
    evidence_package _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT evidence_packageDefaultTypeInternal _evidence_package_default_instance_;
constexpr certifier_rules::certifier_rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rule_(){}
struct certifier_rulesDefaultTypeInternal {
  constexpr certifier_rulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~certifier_rulesDefaultTypeInternal() {}
  union {
    certifier_rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT certifier_rulesDefaultTypeInternal _certifier_rules_default_instance_;
constexpr proved_statements::proved_statements(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : proved_(){}
struct proved_statementsDefaultTypeInternal {
  constexpr proved_statementsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~proved_statementsDefaultTypeInternal() {}
  union {
    proved_statements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT proved_statementsDefaultTypeInternal _proved_statements_default_instance_;
constexpr proof_step::proof_step(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : s1_(nullptr)
  , s2_(nullptr)
  , conclusion_(nullptr)
  , rule_applied_(0){}
struct proof_stepDefaultTypeInternal {
  constexpr proof_stepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~proof_stepDefaultTypeInternal() {}
  union {
    proof_step _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT proof_stepDefaultTypeInternal _proof_step_default_instance_;
constexpr proof::proof(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : already_proved_()
  , steps_()
  , to_prove_(nullptr){}
struct proofDefaultTypeInternal {
  constexpr proofDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~proofDefaultTypeInternal() {}
  union {
    proof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT proofDefaultTypeInternal _proof_default_instance_;
constexpr trust_request_message::trust_request_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : requesting_enclave_tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , providing_enclave_tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , submitted_evidence_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , purpose_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , support_(nullptr){}
struct trust_request_messageDefaultTypeInternal {
  constexpr trust_request_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~trust_request_messageDefaultTypeInternal() {}
  union {
    trust_request_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT trust_request_messageDefaultTypeInternal _trust_request_message_default_instance_;
constexpr trust_response_message::trust_response_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , requesting_enclave_tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , providing_enclave_tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , artifact_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct trust_response_messageDefaultTypeInternal {
  constexpr trust_response_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~trust_response_messageDefaultTypeInternal() {}
  union {
    trust_response_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT trust_response_messageDefaultTypeInternal _trust_response_message_default_instance_;
constexpr storage_info_message::storage_info_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : storage_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , storage_descriptor_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , storage_key_(nullptr){}
struct storage_info_messageDefaultTypeInternal {
  constexpr storage_info_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~storage_info_messageDefaultTypeInternal() {}
  union {
    storage_info_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT storage_info_messageDefaultTypeInternal _storage_info_message_default_instance_;
constexpr channel_key_message::channel_key_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auth_key_(nullptr){}
struct channel_key_messageDefaultTypeInternal {
  constexpr channel_key_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~channel_key_messageDefaultTypeInternal() {}
  union {
    channel_key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT channel_key_messageDefaultTypeInternal _channel_key_message_default_instance_;
constexpr trusted_service_message::trusted_service_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trusted_service_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trusted_service_key_(nullptr){}
struct trusted_service_messageDefaultTypeInternal {
  constexpr trusted_service_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~trusted_service_messageDefaultTypeInternal() {}
  union {
    trusted_service_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT trusted_service_messageDefaultTypeInternal _trusted_service_message_default_instance_;
constexpr tagged_claim::tagged_claim(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , claim_(nullptr){}
struct tagged_claimDefaultTypeInternal {
  constexpr tagged_claimDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~tagged_claimDefaultTypeInternal() {}
  union {
    tagged_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT tagged_claimDefaultTypeInternal _tagged_claim_default_instance_;
constexpr tagged_claims_sequence::tagged_claims_sequence(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : claims_(){}
struct tagged_claims_sequenceDefaultTypeInternal {
  constexpr tagged_claims_sequenceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~tagged_claims_sequenceDefaultTypeInternal() {}
  union {
    tagged_claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT tagged_claims_sequenceDefaultTypeInternal _tagged_claims_sequence_default_instance_;
constexpr policy_store_message::policy_store_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trusted_services_()
  , channel_authentication_keys_()
  , claims_()
  , storage_info_()
  , signed_claims_()
  , blobs_()
  , policy_key_(nullptr){}
struct policy_store_messageDefaultTypeInternal {
  constexpr policy_store_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~policy_store_messageDefaultTypeInternal() {}
  union {
    policy_store_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT policy_store_messageDefaultTypeInternal _policy_store_message_default_instance_;
constexpr claims_sequence::claims_sequence(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : claims_(){}
struct claims_sequenceDefaultTypeInternal {
  constexpr claims_sequenceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~claims_sequenceDefaultTypeInternal() {}
  union {
    claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT claims_sequenceDefaultTypeInternal _claims_sequence_default_instance_;
constexpr signed_claim_sequence::signed_claim_sequence(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : claims_(){}
struct signed_claim_sequenceDefaultTypeInternal {
  constexpr signed_claim_sequenceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~signed_claim_sequenceDefaultTypeInternal() {}
  union {
    signed_claim_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT signed_claim_sequenceDefaultTypeInternal _signed_claim_sequence_default_instance_;
constexpr tagged_signed_claim::tagged_signed_claim(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sc_(nullptr){}
struct tagged_signed_claimDefaultTypeInternal {
  constexpr tagged_signed_claimDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~tagged_signed_claimDefaultTypeInternal() {}
  union {
    tagged_signed_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT tagged_signed_claimDefaultTypeInternal _tagged_signed_claim_default_instance_;
constexpr buffer_sequence::buffer_sequence(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : block_(){}
struct buffer_sequenceDefaultTypeInternal {
  constexpr buffer_sequenceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~buffer_sequenceDefaultTypeInternal() {}
  union {
    buffer_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT buffer_sequenceDefaultTypeInternal _buffer_sequence_default_instance_;
constexpr run_request::run_request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : args_()
  , location_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cert_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct run_requestDefaultTypeInternal {
  constexpr run_requestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~run_requestDefaultTypeInternal() {}
  union {
    run_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT run_requestDefaultTypeInternal _run_request_default_instance_;
constexpr run_response::run_response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct run_responseDefaultTypeInternal {
  constexpr run_responseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~run_responseDefaultTypeInternal() {}
  union {
    run_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT run_responseDefaultTypeInternal _run_response_default_instance_;
constexpr app_request::app_request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : args_()
  , function_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct app_requestDefaultTypeInternal {
  constexpr app_requestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~app_requestDefaultTypeInternal() {}
  union {
    app_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT app_requestDefaultTypeInternal _app_request_default_instance_;
constexpr app_response::app_response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : args_()
  , function_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct app_responseDefaultTypeInternal {
  constexpr app_responseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~app_responseDefaultTypeInternal() {}
  union {
    app_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT app_responseDefaultTypeInternal _app_response_default_instance_;
constexpr tagged_blob_message::tagged_blob_message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , b_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct tagged_blob_messageDefaultTypeInternal {
  constexpr tagged_blob_messageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~tagged_blob_messageDefaultTypeInternal() {}
  union {
    tagged_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT tagged_blob_messageDefaultTypeInternal _tagged_blob_message_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_certifier_2eproto[35];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_certifier_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_certifier_2eproto = nullptr;

const uint32_t TableStruct_certifier_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::time_point, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::time_point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::time_point, year_),
  PROTOBUF_FIELD_OFFSET(::time_point, month_),
  PROTOBUF_FIELD_OFFSET(::time_point, day_),
  PROTOBUF_FIELD_OFFSET(::time_point, hour_),
  PROTOBUF_FIELD_OFFSET(::time_point, minute_),
  PROTOBUF_FIELD_OFFSET(::time_point, seconds_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::rsa_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rsa_message, public_modulus_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, public_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_p_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_q_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_dp_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_dq_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ecc_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::key_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::key_message, key_name_),
  PROTOBUF_FIELD_OFFSET(::key_message, key_type_),
  PROTOBUF_FIELD_OFFSET(::key_message, key_format_),
  PROTOBUF_FIELD_OFFSET(::key_message, rsa_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, ecc_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, secret_key_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, certificate_),
  PROTOBUF_FIELD_OFFSET(::key_message, other_key_formats_),
  PROTOBUF_FIELD_OFFSET(::key_message, not_before_),
  PROTOBUF_FIELD_OFFSET(::key_message, not_after_),
  0,
  1,
  2,
  8,
  9,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, encrypted_key_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, encrypted_data_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::entity_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::entity_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::entity_message, entity_type_),
  PROTOBUF_FIELD_OFFSET(::entity_message, key_),
  PROTOBUF_FIELD_OFFSET(::entity_message, measurement_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::vse_clause, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vse_clause, subject_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, verb_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, object_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, clause_),
  1,
  0,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vse_clauses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vse_clauses, clauses_),
  PROTOBUF_FIELD_OFFSET(::attestation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::attestation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::attestation, enclave_type_),
  PROTOBUF_FIELD_OFFSET(::attestation, key_id_),
  PROTOBUF_FIELD_OFFSET(::attestation, measurement_),
  PROTOBUF_FIELD_OFFSET(::attestation, time_),
  PROTOBUF_FIELD_OFFSET(::attestation, clause_),
  PROTOBUF_FIELD_OFFSET(::attestation, description_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::claim_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::claim_message, claim_format_),
  PROTOBUF_FIELD_OFFSET(::claim_message, claim_descriptor_),
  PROTOBUF_FIELD_OFFSET(::claim_message, not_before_),
  PROTOBUF_FIELD_OFFSET(::claim_message, not_after_),
  PROTOBUF_FIELD_OFFSET(::claim_message, serialized_claim_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, serialized_claim_message_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signing_key_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signing_algorithm_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signature_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::oe_assertion, user_data_),
  PROTOBUF_FIELD_OFFSET(::oe_assertion, oe_report_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::evidence, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::evidence, evidence_type_),
  PROTOBUF_FIELD_OFFSET(::evidence, serialized_evidence_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::evidence_package, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::evidence_package, prover_type_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, fact_assertion_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::certifier_rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::certifier_rules, rule_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proved_statements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proved_statements, proved_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proof_step, s1_),
  PROTOBUF_FIELD_OFFSET(::proof_step, s2_),
  PROTOBUF_FIELD_OFFSET(::proof_step, conclusion_),
  PROTOBUF_FIELD_OFFSET(::proof_step, rule_applied_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proof, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proof, to_prove_),
  PROTOBUF_FIELD_OFFSET(::proof, already_proved_),
  PROTOBUF_FIELD_OFFSET(::proof, steps_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trust_request_message, requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, submitted_evidence_type_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, purpose_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, support_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trust_response_message, status_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, artifact_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_type_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_descriptor_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, address_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_key_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, tag_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::channel_key_message, tag_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, auth_key_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, trusted_service_address_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, trusted_service_key_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, tag_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_claim, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, claim_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::policy_store_message, policy_key_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, trusted_services_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, channel_authentication_keys_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, storage_info_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, signed_claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, blobs_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::claims_sequence, claims_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, claims_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, sc_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, block_),
  PROTOBUF_FIELD_OFFSET(::run_request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::run_request, location_),
  PROTOBUF_FIELD_OFFSET(::run_request, cert_),
  PROTOBUF_FIELD_OFFSET(::run_request, args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::run_response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::run_response, status_),
  0,
  PROTOBUF_FIELD_OFFSET(::app_request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::app_request, function_),
  PROTOBUF_FIELD_OFFSET(::app_request, args_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::app_response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::app_response, function_),
  PROTOBUF_FIELD_OFFSET(::app_response, status_),
  PROTOBUF_FIELD_OFFSET(::app_response, args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, b_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::time_point)},
  { 18, 31, -1, sizeof(::rsa_message)},
  { 38, -1, -1, sizeof(::ecc_message)},
  { 44, 60, -1, sizeof(::key_message)},
  { 70, 78, -1, sizeof(::protected_blob_message)},
  { 80, 89, -1, sizeof(::entity_message)},
  { 92, 102, -1, sizeof(::vse_clause)},
  { 106, -1, -1, sizeof(::vse_clauses)},
  { 113, 125, -1, sizeof(::attestation)},
  { 131, 142, -1, sizeof(::claim_message)},
  { 147, 157, -1, sizeof(::signed_claim_message)},
  { 161, 169, -1, sizeof(::oe_assertion)},
  { 171, 179, -1, sizeof(::evidence)},
  { 181, 189, -1, sizeof(::evidence_package)},
  { 191, -1, -1, sizeof(::certifier_rules)},
  { 198, -1, -1, sizeof(::proved_statements)},
  { 205, 215, -1, sizeof(::proof_step)},
  { 219, 228, -1, sizeof(::proof)},
  { 231, 242, -1, sizeof(::trust_request_message)},
  { 247, 257, -1, sizeof(::trust_response_message)},
  { 261, 272, -1, sizeof(::storage_info_message)},
  { 277, 285, -1, sizeof(::channel_key_message)},
  { 287, 296, -1, sizeof(::trusted_service_message)},
  { 299, 307, -1, sizeof(::tagged_claim)},
  { 309, -1, -1, sizeof(::tagged_claims_sequence)},
  { 316, 329, -1, sizeof(::policy_store_message)},
  { 336, -1, -1, sizeof(::claims_sequence)},
  { 343, -1, -1, sizeof(::signed_claim_sequence)},
  { 350, 358, -1, sizeof(::tagged_signed_claim)},
  { 360, -1, -1, sizeof(::buffer_sequence)},
  { 367, 376, -1, sizeof(::run_request)},
  { 379, 386, -1, sizeof(::run_response)},
  { 387, 395, -1, sizeof(::app_request)},
  { 397, 406, -1, sizeof(::app_response)},
  { 409, 417, -1, sizeof(::tagged_blob_message)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_time_point_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_rsa_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ecc_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_key_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_protected_blob_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_entity_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_vse_clause_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_vse_clauses_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_attestation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_claim_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_signed_claim_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_oe_assertion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_evidence_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_evidence_package_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_certifier_rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_proved_statements_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_proof_step_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_proof_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_trust_request_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_trust_response_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_storage_info_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_channel_key_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_trusted_service_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_tagged_claim_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_tagged_claims_sequence_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_policy_store_message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_claims_sequence_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_signed_claim_sequence_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_tagged_signed_claim_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_buffer_sequence_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_run_request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_run_response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_app_request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_app_response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_tagged_blob_message_default_instance_),
};

const char descriptor_table_protodef_certifier_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017certifier.proto\"e\n\ntime_point\022\014\n\004year\030"
  "\001 \001(\005\022\r\n\005month\030\002 \001(\005\022\013\n\003day\030\003 \001(\005\022\014\n\004hou"
  "r\030\004 \001(\005\022\016\n\006minute\030\005 \001(\005\022\017\n\007seconds\030\006 \001(\001"
  "\"\246\001\n\013rsa_message\022\026\n\016public_modulus\030\001 \001(\014"
  "\022\027\n\017public_exponent\030\002 \001(\014\022\030\n\020private_exp"
  "onent\030\003 \001(\014\022\021\n\tprivate_p\030\004 \001(\014\022\021\n\tprivat"
  "e_q\030\005 \001(\014\022\022\n\nprivate_dp\030\006 \001(\014\022\022\n\nprivate"
  "_dq\030\007 \001(\014\"\r\n\013ecc_message\"\363\001\n\013key_message"
  "\022\020\n\010key_name\030\001 \001(\t\022\020\n\010key_type\030\002 \001(\t\022\022\n\n"
  "key_format\030\003 \001(\t\022\035\n\007rsa_key\030\004 \001(\0132\014.rsa_"
  "message\022\035\n\007ecc_key\030\005 \001(\0132\014.ecc_message\022\027"
  "\n\017secret_key_bits\030\006 \001(\014\022\023\n\013certificate\030\007"
  " \001(\014\022\031\n\021other_key_formats\030\010 \001(\014\022\022\n\nnot_b"
  "efore\030\t \001(\t\022\021\n\tnot_after\030\n \001(\t\"G\n\026protec"
  "ted_blob_message\022\025\n\rencrypted_key\030\001 \001(\014\022"
  "\026\n\016encrypted_data\030\002 \001(\014\"U\n\016entity_messag"
  "e\022\023\n\013entity_type\030\001 \001(\t\022\031\n\003key\030\002 \001(\0132\014.ke"
  "y_message\022\023\n\013measurement\030\003 \001(\014\"z\n\nvse_cl"
  "ause\022 \n\007subject\030\001 \001(\0132\017.entity_message\022\014"
  "\n\004verb\030\002 \001(\t\022\037\n\006object\030\003 \001(\0132\017.entity_me"
  "ssage\022\033\n\006clause\030\004 \001(\0132\013.vse_clause\"+\n\013vs"
  "e_clauses\022\034\n\007clauses\030\001 \003(\0132\013.vse_clause\""
  "\210\001\n\013attestation\022\024\n\014enclave_type\030\001 \001(\t\022\016\n"
  "\006key_id\030\002 \001(\t\022\023\n\013measurement\030\003 \001(\014\022\014\n\004ti"
  "me\030\004 \001(\t\022\033\n\006clause\030\005 \001(\0132\013.vse_clause\022\023\n"
  "\013description\030\006 \001(\t\"\200\001\n\rclaim_message\022\024\n\014"
  "claim_format\030\001 \001(\t\022\030\n\020claim_descriptor\030\002"
  " \001(\t\022\022\n\nnot_before\030\003 \001(\t\022\021\n\tnot_after\030\004 "
  "\001(\t\022\030\n\020serialized_claim\030\005 \001(\014\"\211\001\n\024signed"
  "_claim_message\022 \n\030serialized_claim_messa"
  "ge\030\001 \001(\014\022!\n\013signing_key\030\002 \001(\0132\014.key_mess"
  "age\022\031\n\021signing_algorithm\030\003 \001(\t\022\021\n\tsignat"
  "ure\030\004 \001(\014\"4\n\014oe_assertion\022\021\n\tuser_data\030\001"
  " \001(\014\022\021\n\toe_report\030\002 \001(\014\">\n\010evidence\022\025\n\re"
  "vidence_type\030\001 \001(\t\022\033\n\023serialized_evidenc"
  "e\030\002 \001(\014\"J\n\020evidence_package\022\023\n\013prover_ty"
  "pe\030\001 \001(\t\022!\n\016fact_assertion\030\002 \003(\0132\t.evide"
  "nce\"\037\n\017certifier_rules\022\014\n\004rule\030\001 \003(\t\"0\n\021"
  "proved_statements\022\033\n\006proved\030\001 \003(\0132\013.vse_"
  "clause\"u\n\nproof_step\022\027\n\002s1\030\001 \001(\0132\013.vse_c"
  "lause\022\027\n\002s2\030\002 \001(\0132\013.vse_clause\022\037\n\nconclu"
  "sion\030\003 \001(\0132\013.vse_clause\022\024\n\014rule_applied\030"
  "\004 \001(\005\"g\n\005proof\022\035\n\010to_prove\030\001 \001(\0132\013.vse_c"
  "lause\022#\n\016already_proved\030\002 \003(\0132\013.vse_clau"
  "se\022\032\n\005steps\030\003 \003(\0132\013.proof_step\"\254\001\n\025trust"
  "_request_message\022\036\n\026requesting_enclave_t"
  "ag\030\001 \001(\t\022\035\n\025providing_enclave_tag\030\002 \001(\t\022"
  "\037\n\027submitted_evidence_type\030\003 \001(\t\022\017\n\007purp"
  "ose\030\004 \001(\t\022\"\n\007support\030\005 \001(\0132\021.evidence_pa"
  "ckage\"y\n\026trust_response_message\022\016\n\006statu"
  "s\030\001 \001(\t\022\036\n\026requesting_enclave_tag\030\002 \001(\t\022"
  "\035\n\025providing_enclave_tag\030\003 \001(\t\022\020\n\010artifa"
  "ct\030\004 \001(\014\"\211\001\n\024storage_info_message\022\024\n\014sto"
  "rage_type\030\001 \001(\t\022\032\n\022storage_descriptor\030\002 "
  "\001(\t\022\017\n\007address\030\003 \001(\t\022!\n\013storage_key\030\004 \001("
  "\0132\014.key_message\022\013\n\003tag\030\005 \001(\t\"B\n\023channel_"
  "key_message\022\013\n\003tag\030\001 \001(\t\022\036\n\010auth_key\030\002 \001"
  "(\0132\014.key_message\"r\n\027trusted_service_mess"
  "age\022\037\n\027trusted_service_address\030\001 \001(\t\022)\n\023"
  "trusted_service_key\030\002 \001(\0132\014.key_message\022"
  "\013\n\003tag\030\003 \001(\t\":\n\014tagged_claim\022\013\n\003tag\030\001 \001("
  "\t\022\035\n\005claim\030\002 \001(\0132\016.claim_message\"7\n\026tagg"
  "ed_claims_sequence\022\035\n\006claims\030\001 \003(\0132\r.tag"
  "ged_claim\"\305\002\n\024policy_store_message\022 \n\npo"
  "licy_key\030\001 \001(\0132\014.key_message\0222\n\020trusted_"
  "services\030\002 \003(\0132\030.trusted_service_message"
  "\0229\n\033channel_authentication_keys\030\003 \003(\0132\024."
  "channel_key_message\022\035\n\006claims\030\004 \003(\0132\r.ta"
  "gged_claim\022+\n\014storage_info\030\005 \003(\0132\025.stora"
  "ge_info_message\022+\n\rsigned_claims\030\006 \003(\0132\024"
  ".tagged_signed_claim\022#\n\005blobs\030\007 \003(\0132\024.ta"
  "gged_blob_message\"1\n\017claims_sequence\022\036\n\006"
  "claims\030\001 \003(\0132\016.claim_message\">\n\025signed_c"
  "laim_sequence\022%\n\006claims\030\001 \003(\0132\025.signed_c"
  "laim_message\"E\n\023tagged_signed_claim\022\013\n\003t"
  "ag\030\001 \001(\t\022!\n\002sc\030\002 \001(\0132\025.signed_claim_mess"
  "age\" \n\017buffer_sequence\022\r\n\005block\030\001 \003(\014\";\n"
  "\013run_request\022\020\n\010location\030\001 \001(\t\022\014\n\004cert\030\002"
  " \001(\014\022\014\n\004args\030\003 \003(\t\"\036\n\014run_response\022\016\n\006st"
  "atus\030\001 \001(\t\"-\n\013app_request\022\020\n\010function\030\001 "
  "\001(\t\022\014\n\004args\030\002 \003(\014\">\n\014app_response\022\020\n\010fun"
  "ction\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022\014\n\004args\030\003 \003("
  "\014\"-\n\023tagged_blob_message\022\013\n\003tag\030\001 \001(\t\022\t\n"
  "\001b\030\002 \001(\014"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_certifier_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_certifier_2eproto = {
  false, false, 3328, descriptor_table_protodef_certifier_2eproto, "certifier.proto", 
  &descriptor_table_certifier_2eproto_once, nullptr, 0, 35,
  schemas, file_default_instances, TableStruct_certifier_2eproto::offsets,
  file_level_metadata_certifier_2eproto, file_level_enum_descriptors_certifier_2eproto, file_level_service_descriptors_certifier_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_certifier_2eproto_getter() {
  return &descriptor_table_certifier_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_certifier_2eproto(&descriptor_table_certifier_2eproto);

// ===================================================================

class time_point::_Internal {
 public:
  using HasBits = decltype(std::declval<time_point>()._has_bits_);
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_month(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_day(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hour(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minute(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

time_point::time_point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:time_point)
}
time_point::time_point(const time_point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&year_, &from.year_,
    static_cast<size_t>(reinterpret_cast<char*>(&minute_) -
    reinterpret_cast<char*>(&year_)) + sizeof(minute_));
  // @@protoc_insertion_point(copy_constructor:time_point)
}

inline void time_point::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&year_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minute_) -
    reinterpret_cast<char*>(&year_)) + sizeof(minute_));
}

time_point::~time_point() {
  // @@protoc_insertion_point(destructor:time_point)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void time_point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void time_point::ArenaDtor(void* object) {
  time_point* _this = reinterpret_cast< time_point* >(object);
  (void)_this;
}
void time_point::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void time_point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void time_point::Clear() {
// @@protoc_insertion_point(message_clear_start:time_point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&year_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minute_) -
        reinterpret_cast<char*>(&year_)) + sizeof(minute_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* time_point::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 year = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_year(&has_bits);
          year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 month = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_month(&has_bits);
          month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 day = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_day(&has_bits);
          day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hour = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hour(&has_bits);
          hour_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minute = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_minute(&has_bits);
          minute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* time_point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:time_point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 year = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_year(), target);
  }

  // optional int32 month = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_month(), target);
  }

  // optional int32 day = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_day(), target);
  }

  // optional int32 hour = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_hour(), target);
  }

  // optional int32 minute = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_minute(), target);
  }

  // optional double seconds = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:time_point)
  return target;
}

size_t time_point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:time_point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 year = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_year());
    }

    // optional int32 month = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_month());
    }

    // optional int32 day = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_day());
    }

    // optional int32 hour = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_hour());
    }

    // optional double seconds = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int32 minute = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_minute());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData time_point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    time_point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*time_point::GetClassData() const { return &_class_data_; }

void time_point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<time_point *>(to)->MergeFrom(
      static_cast<const time_point &>(from));
}


void time_point::MergeFrom(const time_point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:time_point)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      year_ = from.year_;
    }
    if (cached_has_bits & 0x00000002u) {
      month_ = from.month_;
    }
    if (cached_has_bits & 0x00000004u) {
      day_ = from.day_;
    }
    if (cached_has_bits & 0x00000008u) {
      hour_ = from.hour_;
    }
    if (cached_has_bits & 0x00000010u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      minute_ = from.minute_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void time_point::CopyFrom(const time_point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:time_point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time_point::IsInitialized() const {
  return true;
}

void time_point::InternalSwap(time_point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(time_point, minute_)
      + sizeof(time_point::minute_)
      - PROTOBUF_FIELD_OFFSET(time_point, year_)>(
          reinterpret_cast<char*>(&year_),
          reinterpret_cast<char*>(&other->year_));
}

::PROTOBUF_NAMESPACE_ID::Metadata time_point::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[0]);
}

// ===================================================================

class rsa_message::_Internal {
 public:
  using HasBits = decltype(std::declval<rsa_message>()._has_bits_);
  static void set_has_public_modulus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_public_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_private_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_private_p(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_private_q(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_private_dp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_private_dq(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

rsa_message::rsa_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rsa_message)
}
rsa_message::rsa_message(const rsa_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  public_modulus_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    public_modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_modulus()) {
    public_modulus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_public_modulus(), 
      GetArenaForAllocation());
  }
  public_exponent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    public_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_exponent()) {
    public_exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_public_exponent(), 
      GetArenaForAllocation());
  }
  private_exponent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_exponent()) {
    private_exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_exponent(), 
      GetArenaForAllocation());
  }
  private_p_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_p()) {
    private_p_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_p(), 
      GetArenaForAllocation());
  }
  private_q_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_q_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_q()) {
    private_q_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_q(), 
      GetArenaForAllocation());
  }
  private_dp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_dp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dp()) {
    private_dp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_dp(), 
      GetArenaForAllocation());
  }
  private_dq_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_dq_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dq()) {
    private_dq_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_dq(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:rsa_message)
}

inline void rsa_message::SharedCtor() {
public_modulus_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  public_modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
public_exponent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  public_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_exponent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_p_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_q_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_q_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_dp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_dp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_dq_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_dq_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

rsa_message::~rsa_message() {
  // @@protoc_insertion_point(destructor:rsa_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void rsa_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  public_modulus_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  public_exponent_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_exponent_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_p_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_q_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_dp_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_dq_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void rsa_message::ArenaDtor(void* object) {
  rsa_message* _this = reinterpret_cast< rsa_message* >(object);
  (void)_this;
}
void rsa_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void rsa_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void rsa_message::Clear() {
// @@protoc_insertion_point(message_clear_start:rsa_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      public_modulus_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      public_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      private_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      private_p_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      private_q_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      private_dp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      private_dq_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* rsa_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes public_modulus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_public_modulus();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes public_exponent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_public_exponent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_exponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_private_exponent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_p = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_private_p();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_q = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_private_q();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_private_dp();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_private_dq();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* rsa_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rsa_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes public_modulus = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_public_modulus(), target);
  }

  // optional bytes public_exponent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_public_exponent(), target);
  }

  // optional bytes private_exponent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_private_exponent(), target);
  }

  // optional bytes private_p = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_private_p(), target);
  }

  // optional bytes private_q = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_private_q(), target);
  }

  // optional bytes private_dp = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_private_dp(), target);
  }

  // optional bytes private_dq = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_private_dq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rsa_message)
  return target;
}

size_t rsa_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rsa_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes public_modulus = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_modulus());
    }

    // optional bytes public_exponent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_exponent());
    }

    // optional bytes private_exponent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_exponent());
    }

    // optional bytes private_p = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_p());
    }

    // optional bytes private_q = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_q());
    }

    // optional bytes private_dp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dp());
    }

    // optional bytes private_dq = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dq());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData rsa_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    rsa_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*rsa_message::GetClassData() const { return &_class_data_; }

void rsa_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<rsa_message *>(to)->MergeFrom(
      static_cast<const rsa_message &>(from));
}


void rsa_message::MergeFrom(const rsa_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rsa_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_public_modulus(from._internal_public_modulus());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_public_exponent(from._internal_public_exponent());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_private_exponent(from._internal_private_exponent());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_private_p(from._internal_private_p());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_private_q(from._internal_private_q());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_private_dp(from._internal_private_dp());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_private_dq(from._internal_private_dq());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void rsa_message::CopyFrom(const rsa_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rsa_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rsa_message::IsInitialized() const {
  return true;
}

void rsa_message::InternalSwap(rsa_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &public_modulus_, lhs_arena,
      &other->public_modulus_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &public_exponent_, lhs_arena,
      &other->public_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_exponent_, lhs_arena,
      &other->private_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_p_, lhs_arena,
      &other->private_p_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_q_, lhs_arena,
      &other->private_q_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_dp_, lhs_arena,
      &other->private_dp_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_dq_, lhs_arena,
      &other->private_dq_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata rsa_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[1]);
}

// ===================================================================

class ecc_message::_Internal {
 public:
};

ecc_message::ecc_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:ecc_message)
}
ecc_message::ecc_message(const ecc_message& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ecc_message)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ecc_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ecc_message::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ecc_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[2]);
}

// ===================================================================

class key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<key_message>()._has_bits_);
  static void set_has_key_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::rsa_message& rsa_key(const key_message* msg);
  static void set_has_rsa_key(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ecc_message& ecc_key(const key_message* msg);
  static void set_has_ecc_key(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_secret_key_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_other_key_formats(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::rsa_message&
key_message::_Internal::rsa_key(const key_message* msg) {
  return *msg->rsa_key_;
}
const ::ecc_message&
key_message::_Internal::ecc_key(const key_message* msg) {
  return *msg->ecc_key_;
}
key_message::key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:key_message)
}
key_message::key_message(const key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_name()) {
    key_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_name(), 
      GetArenaForAllocation());
  }
  key_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_type()) {
    key_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_type(), 
      GetArenaForAllocation());
  }
  key_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_format()) {
    key_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_format(), 
      GetArenaForAllocation());
  }
  secret_key_bits_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    secret_key_bits_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secret_key_bits()) {
    secret_key_bits_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_secret_key_bits(), 
      GetArenaForAllocation());
  }
  certificate_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    certificate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_certificate()) {
    certificate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_certificate(), 
      GetArenaForAllocation());
  }
  other_key_formats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    other_key_formats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_other_key_formats()) {
    other_key_formats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_other_key_formats(), 
      GetArenaForAllocation());
  }
  not_before_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_not_before(), 
      GetArenaForAllocation());
  }
  not_after_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_not_after(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rsa_key()) {
    rsa_key_ = new ::rsa_message(*from.rsa_key_);
  } else {
    rsa_key_ = nullptr;
  }
  if (from._internal_has_ecc_key()) {
    ecc_key_ = new ::ecc_message(*from.ecc_key_);
  } else {
    ecc_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:key_message)
}

inline void key_message::SharedCtor() {
key_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
secret_key_bits_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  secret_key_bits_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
certificate_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  certificate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
other_key_formats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  other_key_formats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_before_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_after_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rsa_key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ecc_key_) -
    reinterpret_cast<char*>(&rsa_key_)) + sizeof(ecc_key_));
}

key_message::~key_message() {
  // @@protoc_insertion_point(destructor:key_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_format_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  secret_key_bits_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  certificate_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  other_key_formats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_before_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_after_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete rsa_key_;
  if (this != internal_default_instance()) delete ecc_key_;
}

void key_message::ArenaDtor(void* object) {
  key_message* _this = reinterpret_cast< key_message* >(object);
  (void)_this;
}
void key_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void key_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      key_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      key_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      key_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      secret_key_bits_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      certificate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      other_key_formats_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      not_after_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(rsa_key_ != nullptr);
      rsa_key_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(ecc_key_ != nullptr);
      ecc_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* key_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "key_message.key_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string key_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "key_message.key_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string key_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key_format();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "key_message.key_format");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .rsa_message rsa_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsa_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ecc_message ecc_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecc_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secret_key_bits = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_secret_key_bits();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes certificate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_certificate();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes other_key_formats = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_other_key_formats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_not_before();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "key_message.not_before");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_not_after();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "key_message.not_after");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_name().data(), static_cast<int>(this->_internal_key_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key_name(), target);
  }

  // optional string key_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_type().data(), static_cast<int>(this->_internal_key_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key_type(), target);
  }

  // optional string key_format = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_format().data(), static_cast<int>(this->_internal_key_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_format");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_key_format(), target);
  }

  // optional .rsa_message rsa_key = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::rsa_key(this), target, stream);
  }

  // optional .ecc_message ecc_key = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ecc_key(this), target, stream);
  }

  // optional bytes secret_key_bits = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_secret_key_bits(), target);
  }

  // optional bytes certificate = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_certificate(), target);
  }

  // optional bytes other_key_formats = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_other_key_formats(), target);
  }

  // optional string not_before = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_before");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_not_before(), target);
  }

  // optional string not_after = 10;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_after");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_not_after(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:key_message)
  return target;
}

size_t key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string key_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_name());
    }

    // optional string key_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_type());
    }

    // optional string key_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_format());
    }

    // optional bytes secret_key_bits = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secret_key_bits());
    }

    // optional bytes certificate = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_certificate());
    }

    // optional bytes other_key_formats = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_other_key_formats());
    }

    // optional string not_before = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .rsa_message rsa_key = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rsa_key_);
    }

    // optional .ecc_message ecc_key = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ecc_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*key_message::GetClassData() const { return &_class_data_; }

void key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<key_message *>(to)->MergeFrom(
      static_cast<const key_message &>(from));
}


void key_message::MergeFrom(const key_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:key_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key_name(from._internal_key_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_key_type(from._internal_key_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_key_format(from._internal_key_format());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_secret_key_bits(from._internal_secret_key_bits());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_certificate(from._internal_certificate());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_other_key_formats(from._internal_other_key_formats());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_not_after(from._internal_not_after());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_rsa_key()->::rsa_message::MergeFrom(from._internal_rsa_key());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_ecc_key()->::ecc_message::MergeFrom(from._internal_ecc_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void key_message::CopyFrom(const key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool key_message::IsInitialized() const {
  return true;
}

void key_message::InternalSwap(key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_name_, lhs_arena,
      &other->key_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_type_, lhs_arena,
      &other->key_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_format_, lhs_arena,
      &other->key_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &secret_key_bits_, lhs_arena,
      &other->secret_key_bits_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &certificate_, lhs_arena,
      &other->certificate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &other_key_formats_, lhs_arena,
      &other->other_key_formats_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &not_before_, lhs_arena,
      &other->not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &not_after_, lhs_arena,
      &other->not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(key_message, ecc_key_)
      + sizeof(key_message::ecc_key_)
      - PROTOBUF_FIELD_OFFSET(key_message, rsa_key_)>(
          reinterpret_cast<char*>(&rsa_key_),
          reinterpret_cast<char*>(&other->rsa_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata key_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[3]);
}

// ===================================================================

class protected_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<protected_blob_message>()._has_bits_);
  static void set_has_encrypted_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encrypted_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

protected_blob_message::protected_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:protected_blob_message)
}
protected_blob_message::protected_blob_message(const protected_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_key()) {
    encrypted_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_key(), 
      GetArenaForAllocation());
  }
  encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_data()) {
    encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protected_blob_message)
}

inline void protected_blob_message::SharedCtor() {
encrypted_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

protected_blob_message::~protected_blob_message() {
  // @@protoc_insertion_point(destructor:protected_blob_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void protected_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void protected_blob_message::ArenaDtor(void* object) {
  protected_blob_message* _this = reinterpret_cast< protected_blob_message* >(object);
  (void)_this;
}
void protected_blob_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void protected_blob_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void protected_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      encrypted_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      encrypted_data_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* protected_blob_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes encrypted_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encrypted_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* protected_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes encrypted_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_key(), target);
  }

  // optional bytes encrypted_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_encrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protected_blob_message)
  return target;
}

size_t protected_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protected_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes encrypted_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_key());
    }

    // optional bytes encrypted_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData protected_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    protected_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*protected_blob_message::GetClassData() const { return &_class_data_; }

void protected_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<protected_blob_message *>(to)->MergeFrom(
      static_cast<const protected_blob_message &>(from));
}


void protected_blob_message::MergeFrom(const protected_blob_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protected_blob_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_encrypted_key(from._internal_encrypted_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_encrypted_data(from._internal_encrypted_data());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void protected_blob_message::CopyFrom(const protected_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protected_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool protected_blob_message::IsInitialized() const {
  return true;
}

void protected_blob_message::InternalSwap(protected_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_key_, lhs_arena,
      &other->encrypted_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata protected_blob_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[4]);
}

// ===================================================================

class entity_message::_Internal {
 public:
  using HasBits = decltype(std::declval<entity_message>()._has_bits_);
  static void set_has_entity_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& key(const entity_message* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
entity_message::_Internal::key(const entity_message* msg) {
  return *msg->key_;
}
entity_message::entity_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:entity_message)
}
entity_message::entity_message(const entity_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  entity_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    entity_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_type()) {
    entity_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_entity_type(), 
      GetArenaForAllocation());
  }
  measurement_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_measurement()) {
    measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_measurement(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    key_ = new ::key_message(*from.key_);
  } else {
    key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:entity_message)
}

inline void entity_message::SharedCtor() {
entity_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  entity_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
measurement_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_ = nullptr;
}

entity_message::~entity_message() {
  // @@protoc_insertion_point(destructor:entity_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void entity_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  entity_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  measurement_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete key_;
}

void entity_message::ArenaDtor(void* object) {
  entity_message* _this = reinterpret_cast< entity_message* >(object);
  (void)_this;
}
void entity_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void entity_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void entity_message::Clear() {
// @@protoc_insertion_point(message_clear_start:entity_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      entity_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* entity_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string entity_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entity_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "entity_message.entity_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes measurement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_measurement();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* entity_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:entity_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string entity_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_entity_type().data(), static_cast<int>(this->_internal_entity_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "entity_message.entity_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_entity_type(), target);
  }

  // optional .key_message key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::key(this), target, stream);
  }

  // optional bytes measurement = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_measurement(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:entity_message)
  return target;
}

size_t entity_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:entity_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string entity_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_entity_type());
    }

    // optional bytes measurement = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_measurement());
    }

    // optional .key_message key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData entity_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    entity_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*entity_message::GetClassData() const { return &_class_data_; }

void entity_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<entity_message *>(to)->MergeFrom(
      static_cast<const entity_message &>(from));
}


void entity_message::MergeFrom(const entity_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:entity_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_entity_type(from._internal_entity_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_measurement(from._internal_measurement());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_key()->::key_message::MergeFrom(from._internal_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void entity_message::CopyFrom(const entity_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:entity_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool entity_message::IsInitialized() const {
  return true;
}

void entity_message::InternalSwap(entity_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &entity_type_, lhs_arena,
      &other->entity_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &measurement_, lhs_arena,
      &other->measurement_, rhs_arena
  );
  swap(key_, other->key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata entity_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[5]);
}

// ===================================================================

class vse_clause::_Internal {
 public:
  using HasBits = decltype(std::declval<vse_clause>()._has_bits_);
  static const ::entity_message& subject(const vse_clause* msg);
  static void set_has_subject(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_verb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::entity_message& object(const vse_clause* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::vse_clause& clause(const vse_clause* msg);
  static void set_has_clause(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::entity_message&
vse_clause::_Internal::subject(const vse_clause* msg) {
  return *msg->subject_;
}
const ::entity_message&
vse_clause::_Internal::object(const vse_clause* msg) {
  return *msg->object_;
}
const ::vse_clause&
vse_clause::_Internal::clause(const vse_clause* msg) {
  return *msg->clause_;
}
vse_clause::vse_clause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vse_clause)
}
vse_clause::vse_clause(const vse_clause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  verb_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    verb_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verb()) {
    verb_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_verb(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_subject()) {
    subject_ = new ::entity_message(*from.subject_);
  } else {
    subject_ = nullptr;
  }
  if (from._internal_has_object()) {
    object_ = new ::entity_message(*from.object_);
  } else {
    object_ = nullptr;
  }
  if (from._internal_has_clause()) {
    clause_ = new ::vse_clause(*from.clause_);
  } else {
    clause_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vse_clause)
}

inline void vse_clause::SharedCtor() {
verb_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  verb_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subject_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&clause_) -
    reinterpret_cast<char*>(&subject_)) + sizeof(clause_));
}

vse_clause::~vse_clause() {
  // @@protoc_insertion_point(destructor:vse_clause)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void vse_clause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  verb_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete subject_;
  if (this != internal_default_instance()) delete object_;
  if (this != internal_default_instance()) delete clause_;
}

void vse_clause::ArenaDtor(void* object) {
  vse_clause* _this = reinterpret_cast< vse_clause* >(object);
  (void)_this;
}
void vse_clause::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void vse_clause::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void vse_clause::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      verb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(subject_ != nullptr);
      subject_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(object_ != nullptr);
      object_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(clause_ != nullptr);
      clause_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clause::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .entity_message subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subject(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string verb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_verb();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vse_clause.verb");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .entity_message object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause clause = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_clause(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .entity_message subject = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subject(this), target, stream);
  }

  // optional string verb = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_verb().data(), static_cast<int>(this->_internal_verb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_clause.verb");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_verb(), target);
  }

  // optional .entity_message object = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::object(this), target, stream);
  }

  // optional .vse_clause clause = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::clause(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clause)
  return target;
}

size_t vse_clause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string verb = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_verb());
    }

    // optional .entity_message subject = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *subject_);
    }

    // optional .entity_message object = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_);
    }

    // optional .vse_clause clause = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *clause_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    vse_clause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clause::GetClassData() const { return &_class_data_; }

void vse_clause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<vse_clause *>(to)->MergeFrom(
      static_cast<const vse_clause &>(from));
}


void vse_clause::MergeFrom(const vse_clause& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vse_clause)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_verb(from._internal_verb());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_subject()->::entity_message::MergeFrom(from._internal_subject());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_object()->::entity_message::MergeFrom(from._internal_object());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_clause()->::vse_clause::MergeFrom(from._internal_clause());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clause::CopyFrom(const vse_clause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clause::IsInitialized() const {
  return true;
}

void vse_clause::InternalSwap(vse_clause* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &verb_, lhs_arena,
      &other->verb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(vse_clause, clause_)
      + sizeof(vse_clause::clause_)
      - PROTOBUF_FIELD_OFFSET(vse_clause, subject_)>(
          reinterpret_cast<char*>(&subject_),
          reinterpret_cast<char*>(&other->subject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clause::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[6]);
}

// ===================================================================

class vse_clauses::_Internal {
 public:
};

vse_clauses::vse_clauses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  clauses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vse_clauses)
}
vse_clauses::vse_clauses(const vse_clauses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      clauses_(from.clauses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vse_clauses)
}

inline void vse_clauses::SharedCtor() {
}

vse_clauses::~vse_clauses() {
  // @@protoc_insertion_point(destructor:vse_clauses)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void vse_clauses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void vse_clauses::ArenaDtor(void* object) {
  vse_clauses* _this = reinterpret_cast< vse_clauses* >(object);
  (void)_this;
}
void vse_clauses::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void vse_clauses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void vse_clauses::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clauses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clauses::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause clauses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clauses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clauses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_clauses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_clauses(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clauses)
  return target;
}

size_t vse_clauses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clauses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  total_size += 1UL * this->_internal_clauses_size();
  for (const auto& msg : this->clauses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clauses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    vse_clauses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clauses::GetClassData() const { return &_class_data_; }

void vse_clauses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<vse_clauses *>(to)->MergeFrom(
      static_cast<const vse_clauses &>(from));
}


void vse_clauses::MergeFrom(const vse_clauses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vse_clauses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  clauses_.MergeFrom(from.clauses_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clauses::CopyFrom(const vse_clauses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clauses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clauses::IsInitialized() const {
  return true;
}

void vse_clauses::InternalSwap(vse_clauses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  clauses_.InternalSwap(&other->clauses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clauses::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[7]);
}

// ===================================================================

class attestation::_Internal {
 public:
  using HasBits = decltype(std::declval<attestation>()._has_bits_);
  static void set_has_enclave_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::vse_clause& clause(const attestation* msg);
  static void set_has_clause(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::vse_clause&
attestation::_Internal::clause(const attestation* msg) {
  return *msg->clause_;
}
attestation::attestation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:attestation)
}
attestation::attestation(const attestation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enclave_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    enclave_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enclave_type()) {
    enclave_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_enclave_type(), 
      GetArenaForAllocation());
  }
  key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_id()) {
    key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_id(), 
      GetArenaForAllocation());
  }
  measurement_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_measurement()) {
    measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_measurement(), 
      GetArenaForAllocation());
  }
  time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_time()) {
    time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_time(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_clause()) {
    clause_ = new ::vse_clause(*from.clause_);
  } else {
    clause_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:attestation)
}

inline void attestation::SharedCtor() {
enclave_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  enclave_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
measurement_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clause_ = nullptr;
}

attestation::~attestation() {
  // @@protoc_insertion_point(destructor:attestation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void attestation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  enclave_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  measurement_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  time_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete clause_;
}

void attestation::ArenaDtor(void* object) {
  attestation* _this = reinterpret_cast< attestation* >(object);
  (void)_this;
}
void attestation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void attestation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void attestation::Clear() {
// @@protoc_insertion_point(message_clear_start:attestation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      enclave_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      key_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(clause_ != nullptr);
      clause_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* attestation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string enclave_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enclave_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "attestation.enclave_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string key_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "attestation.key_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes measurement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_measurement();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_time();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "attestation.time");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause clause = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_clause(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "attestation.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* attestation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:attestation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string enclave_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_enclave_type().data(), static_cast<int>(this->_internal_enclave_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.enclave_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_enclave_type(), target);
  }

  // optional string key_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.key_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key_id(), target);
  }

  // optional bytes measurement = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_measurement(), target);
  }

  // optional string time = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_time().data(), static_cast<int>(this->_internal_time().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.time");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_time(), target);
  }

  // optional .vse_clause clause = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::clause(this), target, stream);
  }

  // optional string description = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.description");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:attestation)
  return target;
}

size_t attestation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:attestation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string enclave_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_enclave_type());
    }

    // optional string key_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_id());
    }

    // optional bytes measurement = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_measurement());
    }

    // optional string time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time());
    }

    // optional string description = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional .vse_clause clause = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *clause_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData attestation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    attestation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*attestation::GetClassData() const { return &_class_data_; }

void attestation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<attestation *>(to)->MergeFrom(
      static_cast<const attestation &>(from));
}


void attestation::MergeFrom(const attestation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:attestation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_enclave_type(from._internal_enclave_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_key_id(from._internal_key_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_measurement(from._internal_measurement());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_time(from._internal_time());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_clause()->::vse_clause::MergeFrom(from._internal_clause());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void attestation::CopyFrom(const attestation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:attestation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attestation::IsInitialized() const {
  return true;
}

void attestation::InternalSwap(attestation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &enclave_type_, lhs_arena,
      &other->enclave_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_id_, lhs_arena,
      &other->key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &measurement_, lhs_arena,
      &other->measurement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &time_, lhs_arena,
      &other->time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  swap(clause_, other->clause_);
}

::PROTOBUF_NAMESPACE_ID::Metadata attestation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[8]);
}

// ===================================================================

class claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<claim_message>()._has_bits_);
  static void set_has_claim_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_claim_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_serialized_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

claim_message::claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:claim_message)
}
claim_message::claim_message(const claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  claim_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    claim_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_format()) {
    claim_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_claim_format(), 
      GetArenaForAllocation());
  }
  claim_descriptor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    claim_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_descriptor()) {
    claim_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_claim_descriptor(), 
      GetArenaForAllocation());
  }
  not_before_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_not_before(), 
      GetArenaForAllocation());
  }
  not_after_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_not_after(), 
      GetArenaForAllocation());
  }
  serialized_claim_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_claim_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim()) {
    serialized_claim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serialized_claim(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:claim_message)
}

inline void claim_message::SharedCtor() {
claim_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  claim_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
claim_descriptor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  claim_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_before_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_after_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serialized_claim_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_claim_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

claim_message::~claim_message() {
  // @@protoc_insertion_point(destructor:claim_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  claim_format_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  claim_descriptor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_before_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_after_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serialized_claim_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void claim_message::ArenaDtor(void* object) {
  claim_message* _this = reinterpret_cast< claim_message* >(object);
  (void)_this;
}
void claim_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void claim_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      claim_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      claim_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      not_after_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      serialized_claim_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claim_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string claim_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_claim_format();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "claim_message.claim_format");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string claim_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_claim_descriptor();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "claim_message.claim_descriptor");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_not_before();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "claim_message.not_before");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_not_after();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "claim_message.not_after");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_claim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serialized_claim();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string claim_format = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_format().data(), static_cast<int>(this->_internal_claim_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_format");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_claim_format(), target);
  }

  // optional string claim_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_descriptor().data(), static_cast<int>(this->_internal_claim_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_claim_descriptor(), target);
  }

  // optional string not_before = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_before");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_not_before(), target);
  }

  // optional string not_after = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_after");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_not_after(), target);
  }

  // optional bytes serialized_claim = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_serialized_claim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claim_message)
  return target;
}

size_t claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string claim_format = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_format());
    }

    // optional string claim_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_descriptor());
    }

    // optional string not_before = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

    // optional bytes serialized_claim = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claim_message::GetClassData() const { return &_class_data_; }

void claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<claim_message *>(to)->MergeFrom(
      static_cast<const claim_message &>(from));
}


void claim_message::MergeFrom(const claim_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:claim_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_claim_format(from._internal_claim_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_claim_descriptor(from._internal_claim_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_not_after(from._internal_not_after());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_serialized_claim(from._internal_serialized_claim());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claim_message::CopyFrom(const claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claim_message::IsInitialized() const {
  return true;
}

void claim_message::InternalSwap(claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &claim_format_, lhs_arena,
      &other->claim_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &claim_descriptor_, lhs_arena,
      &other->claim_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &not_before_, lhs_arena,
      &other->not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &not_after_, lhs_arena,
      &other->not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serialized_claim_, lhs_arena,
      &other->serialized_claim_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata claim_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[9]);
}

// ===================================================================

class signed_claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<signed_claim_message>()._has_bits_);
  static void set_has_serialized_claim_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& signing_key(const signed_claim_message* msg);
  static void set_has_signing_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::key_message&
signed_claim_message::_Internal::signing_key(const signed_claim_message* msg) {
  return *msg->signing_key_;
}
signed_claim_message::signed_claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:signed_claim_message)
}
signed_claim_message::signed_claim_message(const signed_claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  serialized_claim_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_claim_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim_message()) {
    serialized_claim_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serialized_claim_message(), 
      GetArenaForAllocation());
  }
  signing_algorithm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signing_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signing_algorithm()) {
    signing_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signing_algorithm(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_signing_key()) {
    signing_key_ = new ::key_message(*from.signing_key_);
  } else {
    signing_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:signed_claim_message)
}

inline void signed_claim_message::SharedCtor() {
serialized_claim_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_claim_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_algorithm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signing_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_key_ = nullptr;
}

signed_claim_message::~signed_claim_message() {
  // @@protoc_insertion_point(destructor:signed_claim_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void signed_claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serialized_claim_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signing_algorithm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete signing_key_;
}

void signed_claim_message::ArenaDtor(void* object) {
  signed_claim_message* _this = reinterpret_cast< signed_claim_message* >(object);
  (void)_this;
}
void signed_claim_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void signed_claim_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void signed_claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      serialized_claim_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      signing_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(signing_key_ != nullptr);
      signing_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes serialized_claim_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialized_claim_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message signing_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signing_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signing_algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signing_algorithm();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "signed_claim_message.signing_algorithm");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes serialized_claim_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serialized_claim_message(), target);
  }

  // optional .key_message signing_key = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::signing_key(this), target, stream);
  }

  // optional string signing_algorithm = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signing_algorithm().data(), static_cast<int>(this->_internal_signing_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "signed_claim_message.signing_algorithm");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_signing_algorithm(), target);
  }

  // optional bytes signature = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_message)
  return target;
}

size_t signed_claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes serialized_claim_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim_message());
    }

    // optional string signing_algorithm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signing_algorithm());
    }

    // optional bytes signature = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .key_message signing_key = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *signing_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    signed_claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_message::GetClassData() const { return &_class_data_; }

void signed_claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<signed_claim_message *>(to)->MergeFrom(
      static_cast<const signed_claim_message &>(from));
}


void signed_claim_message::MergeFrom(const signed_claim_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_serialized_claim_message(from._internal_serialized_claim_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_signing_algorithm(from._internal_signing_algorithm());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_signing_key()->::key_message::MergeFrom(from._internal_signing_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_message::CopyFrom(const signed_claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_message::IsInitialized() const {
  return true;
}

void signed_claim_message::InternalSwap(signed_claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serialized_claim_message_, lhs_arena,
      &other->serialized_claim_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signing_algorithm_, lhs_arena,
      &other->signing_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  swap(signing_key_, other->signing_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[10]);
}

// ===================================================================

class oe_assertion::_Internal {
 public:
  using HasBits = decltype(std::declval<oe_assertion>()._has_bits_);
  static void set_has_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_oe_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

oe_assertion::oe_assertion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:oe_assertion)
}
oe_assertion::oe_assertion(const oe_assertion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_data()) {
    user_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_data(), 
      GetArenaForAllocation());
  }
  oe_report_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    oe_report_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oe_report()) {
    oe_report_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_oe_report(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:oe_assertion)
}

inline void oe_assertion::SharedCtor() {
user_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
oe_report_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  oe_report_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

oe_assertion::~oe_assertion() {
  // @@protoc_insertion_point(destructor:oe_assertion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void oe_assertion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  oe_report_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void oe_assertion::ArenaDtor(void* object) {
  oe_assertion* _this = reinterpret_cast< oe_assertion* >(object);
  (void)_this;
}
void oe_assertion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void oe_assertion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void oe_assertion::Clear() {
// @@protoc_insertion_point(message_clear_start:oe_assertion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      oe_report_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* oe_assertion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes user_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes oe_report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oe_report();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* oe_assertion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:oe_assertion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes user_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_user_data(), target);
  }

  // optional bytes oe_report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_oe_report(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:oe_assertion)
  return target;
}

size_t oe_assertion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:oe_assertion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes user_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_data());
    }

    // optional bytes oe_report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_oe_report());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData oe_assertion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    oe_assertion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*oe_assertion::GetClassData() const { return &_class_data_; }

void oe_assertion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<oe_assertion *>(to)->MergeFrom(
      static_cast<const oe_assertion &>(from));
}


void oe_assertion::MergeFrom(const oe_assertion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:oe_assertion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_data(from._internal_user_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_oe_report(from._internal_oe_report());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void oe_assertion::CopyFrom(const oe_assertion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:oe_assertion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool oe_assertion::IsInitialized() const {
  return true;
}

void oe_assertion::InternalSwap(oe_assertion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_data_, lhs_arena,
      &other->user_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &oe_report_, lhs_arena,
      &other->oe_report_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata oe_assertion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[11]);
}

// ===================================================================

class evidence::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence>()._has_bits_);
  static void set_has_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serialized_evidence(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

evidence::evidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:evidence)
}
evidence::evidence(const evidence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  evidence_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_evidence_type()) {
    evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_evidence_type(), 
      GetArenaForAllocation());
  }
  serialized_evidence_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_evidence_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_evidence()) {
    serialized_evidence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serialized_evidence(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence)
}

inline void evidence::SharedCtor() {
evidence_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serialized_evidence_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_evidence_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence::~evidence() {
  // @@protoc_insertion_point(destructor:evidence)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void evidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  evidence_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serialized_evidence_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void evidence::ArenaDtor(void* object) {
  evidence* _this = reinterpret_cast< evidence* >(object);
  (void)_this;
}
void evidence::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void evidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void evidence::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      serialized_evidence_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string evidence_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_evidence_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "evidence.evidence_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_evidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serialized_evidence();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string evidence_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_evidence_type().data(), static_cast<int>(this->_internal_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence.evidence_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_evidence_type(), target);
  }

  // optional bytes serialized_evidence = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_serialized_evidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence)
  return target;
}

size_t evidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string evidence_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_evidence_type());
    }

    // optional bytes serialized_evidence = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_evidence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    evidence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence::GetClassData() const { return &_class_data_; }

void evidence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<evidence *>(to)->MergeFrom(
      static_cast<const evidence &>(from));
}


void evidence::MergeFrom(const evidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:evidence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_evidence_type(from._internal_evidence_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_serialized_evidence(from._internal_serialized_evidence());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence::CopyFrom(const evidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence::IsInitialized() const {
  return true;
}

void evidence::InternalSwap(evidence* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &evidence_type_, lhs_arena,
      &other->evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serialized_evidence_, lhs_arena,
      &other->serialized_evidence_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[12]);
}

// ===================================================================

class evidence_package::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence_package>()._has_bits_);
  static void set_has_prover_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

evidence_package::evidence_package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fact_assertion_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:evidence_package)
}
evidence_package::evidence_package(const evidence_package& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fact_assertion_(from.fact_assertion_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  prover_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    prover_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prover_type()) {
    prover_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_prover_type(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence_package)
}

inline void evidence_package::SharedCtor() {
prover_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  prover_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence_package::~evidence_package() {
  // @@protoc_insertion_point(destructor:evidence_package)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void evidence_package::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  prover_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void evidence_package::ArenaDtor(void* object) {
  evidence_package* _this = reinterpret_cast< evidence_package* >(object);
  (void)_this;
}
void evidence_package::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void evidence_package::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void evidence_package::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence_package)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fact_assertion_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    prover_type_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence_package::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prover_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prover_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "evidence_package.prover_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .evidence fact_assertion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fact_assertion(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence_package::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence_package)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string prover_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prover_type().data(), static_cast<int>(this->_internal_prover_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence_package.prover_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prover_type(), target);
  }

  // repeated .evidence fact_assertion = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fact_assertion_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fact_assertion(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence_package)
  return target;
}

size_t evidence_package::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence_package)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .evidence fact_assertion = 2;
  total_size += 1UL * this->_internal_fact_assertion_size();
  for (const auto& msg : this->fact_assertion_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string prover_type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prover_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence_package::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    evidence_package::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence_package::GetClassData() const { return &_class_data_; }

void evidence_package::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<evidence_package *>(to)->MergeFrom(
      static_cast<const evidence_package &>(from));
}


void evidence_package::MergeFrom(const evidence_package& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:evidence_package)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fact_assertion_.MergeFrom(from.fact_assertion_);
  if (from._internal_has_prover_type()) {
    _internal_set_prover_type(from._internal_prover_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence_package::CopyFrom(const evidence_package& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence_package)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence_package::IsInitialized() const {
  return true;
}

void evidence_package::InternalSwap(evidence_package* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fact_assertion_.InternalSwap(&other->fact_assertion_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &prover_type_, lhs_arena,
      &other->prover_type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence_package::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[13]);
}

// ===================================================================

class certifier_rules::_Internal {
 public:
};

certifier_rules::certifier_rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  rule_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:certifier_rules)
}
certifier_rules::certifier_rules(const certifier_rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      rule_(from.rule_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:certifier_rules)
}

inline void certifier_rules::SharedCtor() {
}

certifier_rules::~certifier_rules() {
  // @@protoc_insertion_point(destructor:certifier_rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void certifier_rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void certifier_rules::ArenaDtor(void* object) {
  certifier_rules* _this = reinterpret_cast< certifier_rules* >(object);
  (void)_this;
}
void certifier_rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void certifier_rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void certifier_rules::Clear() {
// @@protoc_insertion_point(message_clear_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rule_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* certifier_rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string rule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rule();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "certifier_rules.rule");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* certifier_rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string rule = 1;
  for (int i = 0, n = this->_internal_rule_size(); i < n; i++) {
    const auto& s = this->_internal_rule(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "certifier_rules.rule");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:certifier_rules)
  return target;
}

size_t certifier_rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:certifier_rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string rule = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(rule_.size());
  for (int i = 0, n = rule_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      rule_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData certifier_rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    certifier_rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*certifier_rules::GetClassData() const { return &_class_data_; }

void certifier_rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<certifier_rules *>(to)->MergeFrom(
      static_cast<const certifier_rules &>(from));
}


void certifier_rules::MergeFrom(const certifier_rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:certifier_rules)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  rule_.MergeFrom(from.rule_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void certifier_rules::CopyFrom(const certifier_rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:certifier_rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool certifier_rules::IsInitialized() const {
  return true;
}

void certifier_rules::InternalSwap(certifier_rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  rule_.InternalSwap(&other->rule_);
}

::PROTOBUF_NAMESPACE_ID::Metadata certifier_rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[14]);
}

// ===================================================================

class proved_statements::_Internal {
 public:
};

proved_statements::proved_statements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  proved_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proved_statements)
}
proved_statements::proved_statements(const proved_statements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      proved_(from.proved_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proved_statements)
}

inline void proved_statements::SharedCtor() {
}

proved_statements::~proved_statements() {
  // @@protoc_insertion_point(destructor:proved_statements)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void proved_statements::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void proved_statements::ArenaDtor(void* object) {
  proved_statements* _this = reinterpret_cast< proved_statements* >(object);
  (void)_this;
}
void proved_statements::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void proved_statements::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proved_statements::Clear() {
// @@protoc_insertion_point(message_clear_start:proved_statements)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  proved_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proved_statements::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause proved = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proved_statements::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proved_statements)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_proved_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_proved(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proved_statements)
  return target;
}

size_t proved_statements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proved_statements)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  total_size += 1UL * this->_internal_proved_size();
  for (const auto& msg : this->proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proved_statements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proved_statements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proved_statements::GetClassData() const { return &_class_data_; }

void proved_statements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proved_statements *>(to)->MergeFrom(
      static_cast<const proved_statements &>(from));
}


void proved_statements::MergeFrom(const proved_statements& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proved_statements)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  proved_.MergeFrom(from.proved_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proved_statements::CopyFrom(const proved_statements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proved_statements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proved_statements::IsInitialized() const {
  return true;
}

void proved_statements::InternalSwap(proved_statements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  proved_.InternalSwap(&other->proved_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proved_statements::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[15]);
}

// ===================================================================

class proof_step::_Internal {
 public:
  using HasBits = decltype(std::declval<proof_step>()._has_bits_);
  static const ::vse_clause& s1(const proof_step* msg);
  static void set_has_s1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::vse_clause& s2(const proof_step* msg);
  static void set_has_s2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::vse_clause& conclusion(const proof_step* msg);
  static void set_has_conclusion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_applied(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::vse_clause&
proof_step::_Internal::s1(const proof_step* msg) {
  return *msg->s1_;
}
const ::vse_clause&
proof_step::_Internal::s2(const proof_step* msg) {
  return *msg->s2_;
}
const ::vse_clause&
proof_step::_Internal::conclusion(const proof_step* msg) {
  return *msg->conclusion_;
}
proof_step::proof_step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proof_step)
}
proof_step::proof_step(const proof_step& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_s1()) {
    s1_ = new ::vse_clause(*from.s1_);
  } else {
    s1_ = nullptr;
  }
  if (from._internal_has_s2()) {
    s2_ = new ::vse_clause(*from.s2_);
  } else {
    s2_ = nullptr;
  }
  if (from._internal_has_conclusion()) {
    conclusion_ = new ::vse_clause(*from.conclusion_);
  } else {
    conclusion_ = nullptr;
  }
  rule_applied_ = from.rule_applied_;
  // @@protoc_insertion_point(copy_constructor:proof_step)
}

inline void proof_step::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&s1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rule_applied_) -
    reinterpret_cast<char*>(&s1_)) + sizeof(rule_applied_));
}

proof_step::~proof_step() {
  // @@protoc_insertion_point(destructor:proof_step)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void proof_step::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete s1_;
  if (this != internal_default_instance()) delete s2_;
  if (this != internal_default_instance()) delete conclusion_;
}

void proof_step::ArenaDtor(void* object) {
  proof_step* _this = reinterpret_cast< proof_step* >(object);
  (void)_this;
}
void proof_step::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void proof_step::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proof_step::Clear() {
// @@protoc_insertion_point(message_clear_start:proof_step)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(s1_ != nullptr);
      s1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(s2_ != nullptr);
      s2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(conclusion_ != nullptr);
      conclusion_->Clear();
    }
  }
  rule_applied_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof_step::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause s1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_s1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause s2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_s2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause conclusion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conclusion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rule_applied = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_applied(&has_bits);
          rule_applied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof_step::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof_step)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .vse_clause s1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::s1(this), target, stream);
  }

  // optional .vse_clause s2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::s2(this), target, stream);
  }

  // optional .vse_clause conclusion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::conclusion(this), target, stream);
  }

  // optional int32 rule_applied = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_rule_applied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof_step)
  return target;
}

size_t proof_step::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof_step)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .vse_clause s1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s1_);
    }

    // optional .vse_clause s2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s2_);
    }

    // optional .vse_clause conclusion = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conclusion_);
    }

    // optional int32 rule_applied = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_rule_applied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof_step::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proof_step::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof_step::GetClassData() const { return &_class_data_; }

void proof_step::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proof_step *>(to)->MergeFrom(
      static_cast<const proof_step &>(from));
}


void proof_step::MergeFrom(const proof_step& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proof_step)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_s1()->::vse_clause::MergeFrom(from._internal_s1());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_s2()->::vse_clause::MergeFrom(from._internal_s2());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_conclusion()->::vse_clause::MergeFrom(from._internal_conclusion());
    }
    if (cached_has_bits & 0x00000008u) {
      rule_applied_ = from.rule_applied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof_step::CopyFrom(const proof_step& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof_step)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof_step::IsInitialized() const {
  return true;
}

void proof_step::InternalSwap(proof_step* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(proof_step, rule_applied_)
      + sizeof(proof_step::rule_applied_)
      - PROTOBUF_FIELD_OFFSET(proof_step, s1_)>(
          reinterpret_cast<char*>(&s1_),
          reinterpret_cast<char*>(&other->s1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata proof_step::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[16]);
}

// ===================================================================

class proof::_Internal {
 public:
  using HasBits = decltype(std::declval<proof>()._has_bits_);
  static const ::vse_clause& to_prove(const proof* msg);
  static void set_has_to_prove(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::vse_clause&
proof::_Internal::to_prove(const proof* msg) {
  return *msg->to_prove_;
}
proof::proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  already_proved_(arena),
  steps_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proof)
}
proof::proof(const proof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      already_proved_(from.already_proved_),
      steps_(from.steps_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_to_prove()) {
    to_prove_ = new ::vse_clause(*from.to_prove_);
  } else {
    to_prove_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proof)
}

inline void proof::SharedCtor() {
to_prove_ = nullptr;
}

proof::~proof() {
  // @@protoc_insertion_point(destructor:proof)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void proof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete to_prove_;
}

void proof::ArenaDtor(void* object) {
  proof* _this = reinterpret_cast< proof* >(object);
  (void)_this;
}
void proof::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void proof::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proof::Clear() {
// @@protoc_insertion_point(message_clear_start:proof)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  already_proved_.Clear();
  steps_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(to_prove_ != nullptr);
    to_prove_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause to_prove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_prove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vse_clause already_proved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_already_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proof_step steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_steps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .vse_clause to_prove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::to_prove(this), target, stream);
  }

  // repeated .vse_clause already_proved = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_already_proved_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_already_proved(i), target, stream);
  }

  // repeated .proof_step steps = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_steps_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_steps(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof)
  return target;
}

size_t proof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause already_proved = 2;
  total_size += 1UL * this->_internal_already_proved_size();
  for (const auto& msg : this->already_proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .proof_step steps = 3;
  total_size += 1UL * this->_internal_steps_size();
  for (const auto& msg : this->steps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .vse_clause to_prove = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *to_prove_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof::GetClassData() const { return &_class_data_; }

void proof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proof *>(to)->MergeFrom(
      static_cast<const proof &>(from));
}


void proof::MergeFrom(const proof& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proof)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  already_proved_.MergeFrom(from.already_proved_);
  steps_.MergeFrom(from.steps_);
  if (from._internal_has_to_prove()) {
    _internal_mutable_to_prove()->::vse_clause::MergeFrom(from._internal_to_prove());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof::CopyFrom(const proof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof::IsInitialized() const {
  return true;
}

void proof::InternalSwap(proof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  already_proved_.InternalSwap(&other->already_proved_);
  steps_.InternalSwap(&other->steps_);
  swap(to_prove_, other->to_prove_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proof::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[17]);
}

// ===================================================================

class trust_request_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_request_message>()._has_bits_);
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_submitted_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_purpose(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::evidence_package& support(const trust_request_message* msg);
  static void set_has_support(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::evidence_package&
trust_request_message::_Internal::support(const trust_request_message* msg) {
  return *msg->support_;
}
trust_request_message::trust_request_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:trust_request_message)
}
trust_request_message::trust_request_message(const trust_request_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  requesting_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_requesting_enclave_tag(), 
      GetArenaForAllocation());
  }
  providing_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_providing_enclave_tag(), 
      GetArenaForAllocation());
  }
  submitted_evidence_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    submitted_evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_submitted_evidence_type()) {
    submitted_evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_submitted_evidence_type(), 
      GetArenaForAllocation());
  }
  purpose_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_purpose()) {
    purpose_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_purpose(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_support()) {
    support_ = new ::evidence_package(*from.support_);
  } else {
    support_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:trust_request_message)
}

inline void trust_request_message::SharedCtor() {
requesting_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
providing_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
submitted_evidence_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  submitted_evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
purpose_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
support_ = nullptr;
}

trust_request_message::~trust_request_message() {
  // @@protoc_insertion_point(destructor:trust_request_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void trust_request_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  requesting_enclave_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  providing_enclave_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  submitted_evidence_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  purpose_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete support_;
}

void trust_request_message::ArenaDtor(void* object) {
  trust_request_message* _this = reinterpret_cast< trust_request_message* >(object);
  (void)_this;
}
void trust_request_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void trust_request_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trust_request_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      submitted_evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      purpose_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(support_ != nullptr);
      support_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_request_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string requesting_enclave_tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_request_message.requesting_enclave_tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_request_message.providing_enclave_tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string submitted_evidence_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_submitted_evidence_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_request_message.submitted_evidence_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string purpose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_purpose();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_request_message.purpose");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .evidence_package support = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_request_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string requesting_enclave_tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_providing_enclave_tag(), target);
  }

  // optional string submitted_evidence_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_submitted_evidence_type().data(), static_cast<int>(this->_internal_submitted_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.submitted_evidence_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_submitted_evidence_type(), target);
  }

  // optional string purpose = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_purpose().data(), static_cast<int>(this->_internal_purpose().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.purpose");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_purpose(), target);
  }

  // optional .evidence_package support = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::support(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_request_message)
  return target;
}

size_t trust_request_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_request_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string requesting_enclave_tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional string submitted_evidence_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_submitted_evidence_type());
    }

    // optional string purpose = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_purpose());
    }

    // optional .evidence_package support = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *support_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_request_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trust_request_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_request_message::GetClassData() const { return &_class_data_; }

void trust_request_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trust_request_message *>(to)->MergeFrom(
      static_cast<const trust_request_message &>(from));
}


void trust_request_message::MergeFrom(const trust_request_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trust_request_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_submitted_evidence_type(from._internal_submitted_evidence_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_purpose(from._internal_purpose());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_support()->::evidence_package::MergeFrom(from._internal_support());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_request_message::CopyFrom(const trust_request_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_request_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_request_message::IsInitialized() const {
  return true;
}

void trust_request_message::InternalSwap(trust_request_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &requesting_enclave_tag_, lhs_arena,
      &other->requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &providing_enclave_tag_, lhs_arena,
      &other->providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &submitted_evidence_type_, lhs_arena,
      &other->submitted_evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &purpose_, lhs_arena,
      &other->purpose_, rhs_arena
  );
  swap(support_, other->support_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_request_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[18]);
}

// ===================================================================

class trust_response_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_response_message>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_artifact(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

trust_response_message::trust_response_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:trust_response_message)
}
trust_response_message::trust_response_message(const trust_response_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  requesting_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_requesting_enclave_tag(), 
      GetArenaForAllocation());
  }
  providing_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_providing_enclave_tag(), 
      GetArenaForAllocation());
  }
  artifact_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artifact()) {
    artifact_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:trust_response_message)
}

inline void trust_response_message::SharedCtor() {
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
providing_enclave_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
artifact_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

trust_response_message::~trust_response_message() {
  // @@protoc_insertion_point(destructor:trust_response_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void trust_response_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  requesting_enclave_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  providing_enclave_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  artifact_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void trust_response_message::ArenaDtor(void* object) {
  trust_response_message* _this = reinterpret_cast< trust_response_message* >(object);
  (void)_this;
}
void trust_response_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void trust_response_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trust_response_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      artifact_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_response_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_response_message.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_response_message.requesting_enclave_tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trust_response_message.providing_enclave_tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes artifact = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_artifact();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_response_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  // optional string requesting_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_providing_enclave_tag(), target);
  }

  // optional bytes artifact = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_artifact(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_response_message)
  return target;
}

size_t trust_response_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_response_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string requesting_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional bytes artifact = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_artifact());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_response_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trust_response_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_response_message::GetClassData() const { return &_class_data_; }

void trust_response_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trust_response_message *>(to)->MergeFrom(
      static_cast<const trust_response_message &>(from));
}


void trust_response_message::MergeFrom(const trust_response_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trust_response_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_artifact(from._internal_artifact());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_response_message::CopyFrom(const trust_response_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_response_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_response_message::IsInitialized() const {
  return true;
}

void trust_response_message::InternalSwap(trust_response_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &requesting_enclave_tag_, lhs_arena,
      &other->requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &providing_enclave_tag_, lhs_arena,
      &other->providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_, lhs_arena,
      &other->artifact_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_response_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[19]);
}

// ===================================================================

class storage_info_message::_Internal {
 public:
  using HasBits = decltype(std::declval<storage_info_message>()._has_bits_);
  static void set_has_storage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storage_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::key_message& storage_key(const storage_info_message* msg);
  static void set_has_storage_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::key_message&
storage_info_message::_Internal::storage_key(const storage_info_message* msg) {
  return *msg->storage_key_;
}
storage_info_message::storage_info_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:storage_info_message)
}
storage_info_message::storage_info_message(const storage_info_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  storage_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    storage_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_type()) {
    storage_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_storage_type(), 
      GetArenaForAllocation());
  }
  storage_descriptor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    storage_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_descriptor()) {
    storage_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_storage_descriptor(), 
      GetArenaForAllocation());
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_address(), 
      GetArenaForAllocation());
  }
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_storage_key()) {
    storage_key_ = new ::key_message(*from.storage_key_);
  } else {
    storage_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:storage_info_message)
}

inline void storage_info_message::SharedCtor() {
storage_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  storage_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
storage_descriptor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  storage_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
storage_key_ = nullptr;
}

storage_info_message::~storage_info_message() {
  // @@protoc_insertion_point(destructor:storage_info_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void storage_info_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  storage_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  storage_descriptor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete storage_key_;
}

void storage_info_message::ArenaDtor(void* object) {
  storage_info_message* _this = reinterpret_cast< storage_info_message* >(object);
  (void)_this;
}
void storage_info_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void storage_info_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void storage_info_message::Clear() {
// @@protoc_insertion_point(message_clear_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      storage_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      storage_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(storage_key_ != nullptr);
      storage_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* storage_info_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string storage_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_storage_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "storage_info_message.storage_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string storage_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_storage_descriptor();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "storage_info_message.storage_descriptor");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "storage_info_message.address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message storage_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "storage_info_message.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* storage_info_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string storage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_type().data(), static_cast<int>(this->_internal_storage_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_storage_type(), target);
  }

  // optional string storage_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_descriptor().data(), static_cast<int>(this->_internal_storage_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_storage_descriptor(), target);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_address(), target);
  }

  // optional .key_message storage_key = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::storage_key(this), target, stream);
  }

  // optional string tag = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.tag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage_info_message)
  return target;
}

size_t storage_info_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage_info_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string storage_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_type());
    }

    // optional string storage_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_descriptor());
    }

    // optional string address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional string tag = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message storage_key = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *storage_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData storage_info_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    storage_info_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*storage_info_message::GetClassData() const { return &_class_data_; }

void storage_info_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<storage_info_message *>(to)->MergeFrom(
      static_cast<const storage_info_message &>(from));
}


void storage_info_message::MergeFrom(const storage_info_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage_info_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_storage_type(from._internal_storage_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_storage_descriptor(from._internal_storage_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_storage_key()->::key_message::MergeFrom(from._internal_storage_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void storage_info_message::CopyFrom(const storage_info_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage_info_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool storage_info_message::IsInitialized() const {
  return true;
}

void storage_info_message::InternalSwap(storage_info_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &storage_type_, lhs_arena,
      &other->storage_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &storage_descriptor_, lhs_arena,
      &other->storage_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &address_, lhs_arena,
      &other->address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(storage_key_, other->storage_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata storage_info_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[20]);
}

// ===================================================================

class channel_key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<channel_key_message>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& auth_key(const channel_key_message* msg);
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
channel_key_message::_Internal::auth_key(const channel_key_message* msg) {
  return *msg->auth_key_;
}
channel_key_message::channel_key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:channel_key_message)
}
channel_key_message::channel_key_message(const channel_key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_auth_key()) {
    auth_key_ = new ::key_message(*from.auth_key_);
  } else {
    auth_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:channel_key_message)
}

inline void channel_key_message::SharedCtor() {
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
auth_key_ = nullptr;
}

channel_key_message::~channel_key_message() {
  // @@protoc_insertion_point(destructor:channel_key_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void channel_key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete auth_key_;
}

void channel_key_message::ArenaDtor(void* object) {
  channel_key_message* _this = reinterpret_cast< channel_key_message* >(object);
  (void)_this;
}
void channel_key_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void channel_key_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void channel_key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(auth_key_ != nullptr);
      auth_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* channel_key_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "channel_key_message.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message auth_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* channel_key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "channel_key_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .key_message auth_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::auth_key(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:channel_key_message)
  return target;
}

size_t channel_key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:channel_key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message auth_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *auth_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData channel_key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    channel_key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*channel_key_message::GetClassData() const { return &_class_data_; }

void channel_key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<channel_key_message *>(to)->MergeFrom(
      static_cast<const channel_key_message &>(from));
}


void channel_key_message::MergeFrom(const channel_key_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:channel_key_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_auth_key()->::key_message::MergeFrom(from._internal_auth_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void channel_key_message::CopyFrom(const channel_key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:channel_key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool channel_key_message::IsInitialized() const {
  return true;
}

void channel_key_message::InternalSwap(channel_key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(auth_key_, other->auth_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata channel_key_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[21]);
}

// ===================================================================

class trusted_service_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trusted_service_message>()._has_bits_);
  static void set_has_trusted_service_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& trusted_service_key(const trusted_service_message* msg);
  static void set_has_trusted_service_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
trusted_service_message::_Internal::trusted_service_key(const trusted_service_message* msg) {
  return *msg->trusted_service_key_;
}
trusted_service_message::trusted_service_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:trusted_service_message)
}
trusted_service_message::trusted_service_message(const trusted_service_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  trusted_service_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trusted_service_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trusted_service_address()) {
    trusted_service_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trusted_service_address(), 
      GetArenaForAllocation());
  }
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_trusted_service_key()) {
    trusted_service_key_ = new ::key_message(*from.trusted_service_key_);
  } else {
    trusted_service_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:trusted_service_message)
}

inline void trusted_service_message::SharedCtor() {
trusted_service_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trusted_service_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trusted_service_key_ = nullptr;
}

trusted_service_message::~trusted_service_message() {
  // @@protoc_insertion_point(destructor:trusted_service_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void trusted_service_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  trusted_service_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete trusted_service_key_;
}

void trusted_service_message::ArenaDtor(void* object) {
  trusted_service_message* _this = reinterpret_cast< trusted_service_message* >(object);
  (void)_this;
}
void trusted_service_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void trusted_service_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trusted_service_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      trusted_service_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(trusted_service_key_ != nullptr);
      trusted_service_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trusted_service_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trusted_service_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trusted_service_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trusted_service_message.trusted_service_address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message trusted_service_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trusted_service_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "trusted_service_message.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trusted_service_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string trusted_service_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_trusted_service_address().data(), static_cast<int>(this->_internal_trusted_service_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.trusted_service_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_trusted_service_address(), target);
  }

  // optional .key_message trusted_service_key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::trusted_service_key(this), target, stream);
  }

  // optional string tag = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trusted_service_message)
  return target;
}

size_t trusted_service_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trusted_service_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string trusted_service_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trusted_service_address());
    }

    // optional string tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message trusted_service_key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trusted_service_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trusted_service_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trusted_service_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trusted_service_message::GetClassData() const { return &_class_data_; }

void trusted_service_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trusted_service_message *>(to)->MergeFrom(
      static_cast<const trusted_service_message &>(from));
}


void trusted_service_message::MergeFrom(const trusted_service_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trusted_service_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_trusted_service_address(from._internal_trusted_service_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_trusted_service_key()->::key_message::MergeFrom(from._internal_trusted_service_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trusted_service_message::CopyFrom(const trusted_service_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trusted_service_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trusted_service_message::IsInitialized() const {
  return true;
}

void trusted_service_message::InternalSwap(trusted_service_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trusted_service_address_, lhs_arena,
      &other->trusted_service_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(trusted_service_key_, other->trusted_service_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trusted_service_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[22]);
}

// ===================================================================

class tagged_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_claim>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::claim_message& claim(const tagged_claim* msg);
  static void set_has_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::claim_message&
tagged_claim::_Internal::claim(const tagged_claim* msg) {
  return *msg->claim_;
}
tagged_claim::tagged_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tagged_claim)
}
tagged_claim::tagged_claim(const tagged_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_claim()) {
    claim_ = new ::claim_message(*from.claim_);
  } else {
    claim_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tagged_claim)
}

inline void tagged_claim::SharedCtor() {
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
claim_ = nullptr;
}

tagged_claim::~tagged_claim() {
  // @@protoc_insertion_point(destructor:tagged_claim)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void tagged_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete claim_;
}

void tagged_claim::ArenaDtor(void* object) {
  tagged_claim* _this = reinterpret_cast< tagged_claim* >(object);
  (void)_this;
}
void tagged_claim::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void tagged_claim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(claim_ != nullptr);
      claim_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claim::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "tagged_claim.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .claim_message claim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_claim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .claim_message claim = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::claim(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claim)
  return target;
}

size_t tagged_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .claim_message claim = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *claim_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claim::GetClassData() const { return &_class_data_; }

void tagged_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_claim *>(to)->MergeFrom(
      static_cast<const tagged_claim &>(from));
}


void tagged_claim::MergeFrom(const tagged_claim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_claim)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_claim()->::claim_message::MergeFrom(from._internal_claim());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claim::CopyFrom(const tagged_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claim::IsInitialized() const {
  return true;
}

void tagged_claim::InternalSwap(tagged_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(claim_, other->claim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claim::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[23]);
}

// ===================================================================

class tagged_claims_sequence::_Internal {
 public:
};

tagged_claims_sequence::tagged_claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tagged_claims_sequence)
}
tagged_claims_sequence::tagged_claims_sequence(const tagged_claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tagged_claims_sequence)
}

inline void tagged_claims_sequence::SharedCtor() {
}

tagged_claims_sequence::~tagged_claims_sequence() {
  // @@protoc_insertion_point(destructor:tagged_claims_sequence)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void tagged_claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void tagged_claims_sequence::ArenaDtor(void* object) {
  tagged_claims_sequence* _this = reinterpret_cast< tagged_claims_sequence* >(object);
  (void)_this;
}
void tagged_claims_sequence::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void tagged_claims_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claims_sequence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tagged_claim claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_claims_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_claims(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claims_sequence)
  return target;
}

size_t tagged_claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claims_sequence::GetClassData() const { return &_class_data_; }

void tagged_claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_claims_sequence *>(to)->MergeFrom(
      static_cast<const tagged_claims_sequence &>(from));
}


void tagged_claims_sequence::MergeFrom(const tagged_claims_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_claims_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claims_sequence::CopyFrom(const tagged_claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claims_sequence::IsInitialized() const {
  return true;
}

void tagged_claims_sequence::InternalSwap(tagged_claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claims_sequence::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[24]);
}

// ===================================================================

class policy_store_message::_Internal {
 public:
  using HasBits = decltype(std::declval<policy_store_message>()._has_bits_);
  static const ::key_message& policy_key(const policy_store_message* msg);
  static void set_has_policy_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::key_message&
policy_store_message::_Internal::policy_key(const policy_store_message* msg) {
  return *msg->policy_key_;
}
policy_store_message::policy_store_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trusted_services_(arena),
  channel_authentication_keys_(arena),
  claims_(arena),
  storage_info_(arena),
  signed_claims_(arena),
  blobs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:policy_store_message)
}
policy_store_message::policy_store_message(const policy_store_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      trusted_services_(from.trusted_services_),
      channel_authentication_keys_(from.channel_authentication_keys_),
      claims_(from.claims_),
      storage_info_(from.storage_info_),
      signed_claims_(from.signed_claims_),
      blobs_(from.blobs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_policy_key()) {
    policy_key_ = new ::key_message(*from.policy_key_);
  } else {
    policy_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:policy_store_message)
}

inline void policy_store_message::SharedCtor() {
policy_key_ = nullptr;
}

policy_store_message::~policy_store_message() {
  // @@protoc_insertion_point(destructor:policy_store_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void policy_store_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete policy_key_;
}

void policy_store_message::ArenaDtor(void* object) {
  policy_store_message* _this = reinterpret_cast< policy_store_message* >(object);
  (void)_this;
}
void policy_store_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void policy_store_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void policy_store_message::Clear() {
// @@protoc_insertion_point(message_clear_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trusted_services_.Clear();
  channel_authentication_keys_.Clear();
  claims_.Clear();
  storage_info_.Clear();
  signed_claims_.Clear();
  blobs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(policy_key_ != nullptr);
    policy_key_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* policy_store_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .key_message policy_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .trusted_service_message trusted_services = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trusted_services(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .channel_key_message channel_authentication_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channel_authentication_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_claim claims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .storage_info_message storage_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_storage_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_signed_claim signed_claims = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signed_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_blob_message blobs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* policy_store_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .key_message policy_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::policy_key(this), target, stream);
  }

  // repeated .trusted_service_message trusted_services = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trusted_services_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_trusted_services(i), target, stream);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_channel_authentication_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_channel_authentication_keys(i), target, stream);
  }

  // repeated .tagged_claim claims = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_claims_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_claims(i), target, stream);
  }

  // repeated .storage_info_message storage_info = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_storage_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_storage_info(i), target, stream);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_signed_claims_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_signed_claims(i), target, stream);
  }

  // repeated .tagged_blob_message blobs = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_blobs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_blobs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:policy_store_message)
  return target;
}

size_t policy_store_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:policy_store_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trusted_service_message trusted_services = 2;
  total_size += 1UL * this->_internal_trusted_services_size();
  for (const auto& msg : this->trusted_services_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  total_size += 1UL * this->_internal_channel_authentication_keys_size();
  for (const auto& msg : this->channel_authentication_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_claim claims = 4;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .storage_info_message storage_info = 5;
  total_size += 1UL * this->_internal_storage_info_size();
  for (const auto& msg : this->storage_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  total_size += 1UL * this->_internal_signed_claims_size();
  for (const auto& msg : this->signed_claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_blob_message blobs = 7;
  total_size += 1UL * this->_internal_blobs_size();
  for (const auto& msg : this->blobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .key_message policy_key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *policy_key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData policy_store_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    policy_store_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*policy_store_message::GetClassData() const { return &_class_data_; }

void policy_store_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<policy_store_message *>(to)->MergeFrom(
      static_cast<const policy_store_message &>(from));
}


void policy_store_message::MergeFrom(const policy_store_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:policy_store_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trusted_services_.MergeFrom(from.trusted_services_);
  channel_authentication_keys_.MergeFrom(from.channel_authentication_keys_);
  claims_.MergeFrom(from.claims_);
  storage_info_.MergeFrom(from.storage_info_);
  signed_claims_.MergeFrom(from.signed_claims_);
  blobs_.MergeFrom(from.blobs_);
  if (from._internal_has_policy_key()) {
    _internal_mutable_policy_key()->::key_message::MergeFrom(from._internal_policy_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void policy_store_message::CopyFrom(const policy_store_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:policy_store_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool policy_store_message::IsInitialized() const {
  return true;
}

void policy_store_message::InternalSwap(policy_store_message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trusted_services_.InternalSwap(&other->trusted_services_);
  channel_authentication_keys_.InternalSwap(&other->channel_authentication_keys_);
  claims_.InternalSwap(&other->claims_);
  storage_info_.InternalSwap(&other->storage_info_);
  signed_claims_.InternalSwap(&other->signed_claims_);
  blobs_.InternalSwap(&other->blobs_);
  swap(policy_key_, other->policy_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata policy_store_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[25]);
}

// ===================================================================

class claims_sequence::_Internal {
 public:
};

claims_sequence::claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:claims_sequence)
}
claims_sequence::claims_sequence(const claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:claims_sequence)
}

inline void claims_sequence::SharedCtor() {
}

claims_sequence::~claims_sequence() {
  // @@protoc_insertion_point(destructor:claims_sequence)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void claims_sequence::ArenaDtor(void* object) {
  claims_sequence* _this = reinterpret_cast< claims_sequence* >(object);
  (void)_this;
}
void claims_sequence::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void claims_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claims_sequence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_claims_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_claims(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claims_sequence)
  return target;
}

size_t claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claims_sequence::GetClassData() const { return &_class_data_; }

void claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<claims_sequence *>(to)->MergeFrom(
      static_cast<const claims_sequence &>(from));
}


void claims_sequence::MergeFrom(const claims_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:claims_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claims_sequence::CopyFrom(const claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claims_sequence::IsInitialized() const {
  return true;
}

void claims_sequence::InternalSwap(claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata claims_sequence::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[26]);
}

// ===================================================================

class signed_claim_sequence::_Internal {
 public:
};

signed_claim_sequence::signed_claim_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:signed_claim_sequence)
}
signed_claim_sequence::signed_claim_sequence(const signed_claim_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signed_claim_sequence)
}

inline void signed_claim_sequence::SharedCtor() {
}

signed_claim_sequence::~signed_claim_sequence() {
  // @@protoc_insertion_point(destructor:signed_claim_sequence)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void signed_claim_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void signed_claim_sequence::ArenaDtor(void* object) {
  signed_claim_sequence* _this = reinterpret_cast< signed_claim_sequence* >(object);
  (void)_this;
}
void signed_claim_sequence::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void signed_claim_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void signed_claim_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_sequence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .signed_claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_claims_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_claims(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_sequence)
  return target;
}

size_t signed_claim_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    signed_claim_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_sequence::GetClassData() const { return &_class_data_; }

void signed_claim_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<signed_claim_sequence *>(to)->MergeFrom(
      static_cast<const signed_claim_sequence &>(from));
}


void signed_claim_sequence::MergeFrom(const signed_claim_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_sequence::CopyFrom(const signed_claim_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_sequence::IsInitialized() const {
  return true;
}

void signed_claim_sequence::InternalSwap(signed_claim_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_sequence::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[27]);
}

// ===================================================================

class tagged_signed_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_signed_claim>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::signed_claim_message& sc(const tagged_signed_claim* msg);
  static void set_has_sc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::signed_claim_message&
tagged_signed_claim::_Internal::sc(const tagged_signed_claim* msg) {
  return *msg->sc_;
}
tagged_signed_claim::tagged_signed_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tagged_signed_claim)
}
tagged_signed_claim::tagged_signed_claim(const tagged_signed_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sc()) {
    sc_ = new ::signed_claim_message(*from.sc_);
  } else {
    sc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tagged_signed_claim)
}

inline void tagged_signed_claim::SharedCtor() {
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sc_ = nullptr;
}

tagged_signed_claim::~tagged_signed_claim() {
  // @@protoc_insertion_point(destructor:tagged_signed_claim)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void tagged_signed_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sc_;
}

void tagged_signed_claim::ArenaDtor(void* object) {
  tagged_signed_claim* _this = reinterpret_cast< tagged_signed_claim* >(object);
  (void)_this;
}
void tagged_signed_claim::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void tagged_signed_claim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_signed_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(sc_ != nullptr);
      sc_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_signed_claim::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "tagged_signed_claim.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .signed_claim_message sc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_signed_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_signed_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .signed_claim_message sc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::sc(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_signed_claim)
  return target;
}

size_t tagged_signed_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_signed_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .signed_claim_message sc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sc_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_signed_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_signed_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_signed_claim::GetClassData() const { return &_class_data_; }

void tagged_signed_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_signed_claim *>(to)->MergeFrom(
      static_cast<const tagged_signed_claim &>(from));
}


void tagged_signed_claim::MergeFrom(const tagged_signed_claim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_signed_claim)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_sc()->::signed_claim_message::MergeFrom(from._internal_sc());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_signed_claim::CopyFrom(const tagged_signed_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_signed_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_signed_claim::IsInitialized() const {
  return true;
}

void tagged_signed_claim::InternalSwap(tagged_signed_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(sc_, other->sc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_signed_claim::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[28]);
}

// ===================================================================

class buffer_sequence::_Internal {
 public:
};

buffer_sequence::buffer_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  block_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:buffer_sequence)
}
buffer_sequence::buffer_sequence(const buffer_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      block_(from.block_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buffer_sequence)
}

inline void buffer_sequence::SharedCtor() {
}

buffer_sequence::~buffer_sequence() {
  // @@protoc_insertion_point(destructor:buffer_sequence)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void buffer_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void buffer_sequence::ArenaDtor(void* object) {
  buffer_sequence* _this = reinterpret_cast< buffer_sequence* >(object);
  (void)_this;
}
void buffer_sequence::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void buffer_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void buffer_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  block_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* buffer_sequence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_block();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* buffer_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes block = 1;
  for (int i = 0, n = this->_internal_block_size(); i < n; i++) {
    const auto& s = this->_internal_block(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buffer_sequence)
  return target;
}

size_t buffer_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buffer_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes block = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(block_.size());
  for (int i = 0, n = block_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      block_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData buffer_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    buffer_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*buffer_sequence::GetClassData() const { return &_class_data_; }

void buffer_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<buffer_sequence *>(to)->MergeFrom(
      static_cast<const buffer_sequence &>(from));
}


void buffer_sequence::MergeFrom(const buffer_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buffer_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  block_.MergeFrom(from.block_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void buffer_sequence::CopyFrom(const buffer_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buffer_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool buffer_sequence::IsInitialized() const {
  return true;
}

void buffer_sequence::InternalSwap(buffer_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  block_.InternalSwap(&other->block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata buffer_sequence::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[29]);
}

// ===================================================================

class run_request::_Internal {
 public:
  using HasBits = decltype(std::declval<run_request>()._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

run_request::run_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:run_request)
}
run_request::run_request(const run_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_location(), 
      GetArenaForAllocation());
  }
  cert_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert()) {
    cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cert(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_request)
}

inline void run_request::SharedCtor() {
location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cert_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_request::~run_request() {
  // @@protoc_insertion_point(destructor:run_request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void run_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cert_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void run_request::ArenaDtor(void* object) {
  run_request* _this = reinterpret_cast< run_request* >(object);
  (void)_this;
}
void run_request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void run_request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void run_request::Clear() {
// @@protoc_insertion_point(message_clear_start:run_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      cert_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "run_request.location");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes cert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cert();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "run_request.args");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string location = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.location");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_location(), target);
  }

  // optional bytes cert = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_cert(), target);
  }

  // repeated string args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.args");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_request)
  return target;
}

size_t run_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      args_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string location = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional bytes cert = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cert());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    run_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_request::GetClassData() const { return &_class_data_; }

void run_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<run_request *>(to)->MergeFrom(
      static_cast<const run_request &>(from));
}


void run_request::MergeFrom(const run_request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:run_request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_cert(from._internal_cert());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_request::CopyFrom(const run_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_request::IsInitialized() const {
  return true;
}

void run_request::InternalSwap(run_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &location_, lhs_arena,
      &other->location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cert_, lhs_arena,
      &other->cert_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[30]);
}

// ===================================================================

class run_response::_Internal {
 public:
  using HasBits = decltype(std::declval<run_response>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

run_response::run_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:run_response)
}
run_response::run_response(const run_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_response)
}

inline void run_response::SharedCtor() {
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_response::~run_response() {
  // @@protoc_insertion_point(destructor:run_response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void run_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void run_response::ArenaDtor(void* object) {
  run_response* _this = reinterpret_cast< run_response* >(object);
  (void)_this;
}
void run_response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void run_response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void run_response::Clear() {
// @@protoc_insertion_point(message_clear_start:run_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    status_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "run_response.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_response.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_response)
  return target;
}

size_t run_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    run_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_response::GetClassData() const { return &_class_data_; }

void run_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<run_response *>(to)->MergeFrom(
      static_cast<const run_response &>(from));
}


void run_response::MergeFrom(const run_response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:run_response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_response::CopyFrom(const run_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_response::IsInitialized() const {
  return true;
}

void run_response::InternalSwap(run_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[31]);
}

// ===================================================================

class app_request::_Internal {
 public:
  using HasBits = decltype(std::declval<app_request>()._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

app_request::app_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:app_request)
}
app_request::app_request(const app_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  function_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_function(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_request)
}

inline void app_request::SharedCtor() {
function_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_request::~app_request() {
  // @@protoc_insertion_point(destructor:app_request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void app_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  function_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void app_request::ArenaDtor(void* object) {
  app_request* _this = reinterpret_cast< app_request* >(object);
  (void)_this;
}
void app_request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void app_request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void app_request::Clear() {
// @@protoc_insertion_point(message_clear_start:app_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    function_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "app_request.function");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_request.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // repeated bytes args = 2;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_request)
  return target;
}

size_t app_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      args_.Get(i));
  }

  // optional string function = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_function());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    app_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_request::GetClassData() const { return &_class_data_; }

void app_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<app_request *>(to)->MergeFrom(
      static_cast<const app_request &>(from));
}


void app_request::MergeFrom(const app_request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:app_request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  if (from._internal_has_function()) {
    _internal_set_function(from._internal_function());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_request::CopyFrom(const app_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_request::IsInitialized() const {
  return true;
}

void app_request::InternalSwap(app_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &function_, lhs_arena,
      &other->function_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[32]);
}

// ===================================================================

class app_response::_Internal {
 public:
  using HasBits = decltype(std::declval<app_response>()._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

app_response::app_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:app_response)
}
app_response::app_response(const app_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  function_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_function(), 
      GetArenaForAllocation());
  }
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_response)
}

inline void app_response::SharedCtor() {
function_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_response::~app_response() {
  // @@protoc_insertion_point(destructor:app_response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void app_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  function_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void app_response::ArenaDtor(void* object) {
  app_response* _this = reinterpret_cast< app_response* >(object);
  (void)_this;
}
void app_response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void app_response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void app_response::Clear() {
// @@protoc_insertion_point(message_clear_start:app_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      function_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      status_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "app_response.function");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "app_response.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // optional string status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  // repeated bytes args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_response)
  return target;
}

size_t app_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      args_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string function = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_function());
    }

    // optional string status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    app_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_response::GetClassData() const { return &_class_data_; }

void app_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<app_response *>(to)->MergeFrom(
      static_cast<const app_response &>(from));
}


void app_response::MergeFrom(const app_response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:app_response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_function(from._internal_function());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_status(from._internal_status());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_response::CopyFrom(const app_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_response::IsInitialized() const {
  return true;
}

void app_response::InternalSwap(app_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &function_, lhs_arena,
      &other->function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[33]);
}

// ===================================================================

class tagged_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_blob_message>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

tagged_blob_message::tagged_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tagged_blob_message)
}
tagged_blob_message::tagged_blob_message(const tagged_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tag(), 
      GetArenaForAllocation());
  }
  b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_b()) {
    b_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_b(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tagged_blob_message)
}

inline void tagged_blob_message::SharedCtor() {
tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

tagged_blob_message::~tagged_blob_message() {
  // @@protoc_insertion_point(destructor:tagged_blob_message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void tagged_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  b_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void tagged_blob_message::ArenaDtor(void* object) {
  tagged_blob_message* _this = reinterpret_cast< tagged_blob_message* >(object);
  (void)_this;
}
void tagged_blob_message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void tagged_blob_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      b_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_blob_message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "tagged_blob_message.tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes b = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_b();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_blob_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional bytes b = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_blob_message)
  return target;
}

size_t tagged_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional bytes b = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_b());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_blob_message::GetClassData() const { return &_class_data_; }

void tagged_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_blob_message *>(to)->MergeFrom(
      static_cast<const tagged_blob_message &>(from));
}


void tagged_blob_message::MergeFrom(const tagged_blob_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_blob_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_b(from._internal_b());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_blob_message::CopyFrom(const tagged_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_blob_message::IsInitialized() const {
  return true;
}

void tagged_blob_message::InternalSwap(tagged_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &b_, lhs_arena,
      &other->b_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_blob_message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[34]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::time_point* Arena::CreateMaybeMessage< ::time_point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::time_point >(arena);
}
template<> PROTOBUF_NOINLINE ::rsa_message* Arena::CreateMaybeMessage< ::rsa_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rsa_message >(arena);
}
template<> PROTOBUF_NOINLINE ::ecc_message* Arena::CreateMaybeMessage< ::ecc_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ecc_message >(arena);
}
template<> PROTOBUF_NOINLINE ::key_message* Arena::CreateMaybeMessage< ::key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::protected_blob_message* Arena::CreateMaybeMessage< ::protected_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protected_blob_message >(arena);
}
template<> PROTOBUF_NOINLINE ::entity_message* Arena::CreateMaybeMessage< ::entity_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::entity_message >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clause* Arena::CreateMaybeMessage< ::vse_clause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clause >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clauses* Arena::CreateMaybeMessage< ::vse_clauses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clauses >(arena);
}
template<> PROTOBUF_NOINLINE ::attestation* Arena::CreateMaybeMessage< ::attestation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::attestation >(arena);
}
template<> PROTOBUF_NOINLINE ::claim_message* Arena::CreateMaybeMessage< ::claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_message* Arena::CreateMaybeMessage< ::signed_claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::oe_assertion* Arena::CreateMaybeMessage< ::oe_assertion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::oe_assertion >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence* Arena::CreateMaybeMessage< ::evidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence_package* Arena::CreateMaybeMessage< ::evidence_package >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence_package >(arena);
}
template<> PROTOBUF_NOINLINE ::certifier_rules* Arena::CreateMaybeMessage< ::certifier_rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::certifier_rules >(arena);
}
template<> PROTOBUF_NOINLINE ::proved_statements* Arena::CreateMaybeMessage< ::proved_statements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proved_statements >(arena);
}
template<> PROTOBUF_NOINLINE ::proof_step* Arena::CreateMaybeMessage< ::proof_step >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof_step >(arena);
}
template<> PROTOBUF_NOINLINE ::proof* Arena::CreateMaybeMessage< ::proof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_request_message* Arena::CreateMaybeMessage< ::trust_request_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_request_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_response_message* Arena::CreateMaybeMessage< ::trust_response_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_response_message >(arena);
}
template<> PROTOBUF_NOINLINE ::storage_info_message* Arena::CreateMaybeMessage< ::storage_info_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage_info_message >(arena);
}
template<> PROTOBUF_NOINLINE ::channel_key_message* Arena::CreateMaybeMessage< ::channel_key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::channel_key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trusted_service_message* Arena::CreateMaybeMessage< ::trusted_service_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trusted_service_message >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claim* Arena::CreateMaybeMessage< ::tagged_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claims_sequence* Arena::CreateMaybeMessage< ::tagged_claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::policy_store_message* Arena::CreateMaybeMessage< ::policy_store_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::policy_store_message >(arena);
}
template<> PROTOBUF_NOINLINE ::claims_sequence* Arena::CreateMaybeMessage< ::claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_sequence* Arena::CreateMaybeMessage< ::signed_claim_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_signed_claim* Arena::CreateMaybeMessage< ::tagged_signed_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_signed_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::buffer_sequence* Arena::CreateMaybeMessage< ::buffer_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buffer_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::run_request* Arena::CreateMaybeMessage< ::run_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_request >(arena);
}
template<> PROTOBUF_NOINLINE ::run_response* Arena::CreateMaybeMessage< ::run_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_response >(arena);
}
template<> PROTOBUF_NOINLINE ::app_request* Arena::CreateMaybeMessage< ::app_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_request >(arena);
}
template<> PROTOBUF_NOINLINE ::app_response* Arena::CreateMaybeMessage< ::app_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_response >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_blob_message* Arena::CreateMaybeMessage< ::tagged_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_blob_message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
