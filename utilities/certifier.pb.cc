// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certifier.proto

#include "certifier.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR time_point::time_point(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.year_)*/0
  , /*decltype(_impl_.month_)*/0
  , /*decltype(_impl_.day_)*/0
  , /*decltype(_impl_.hour_)*/0
  , /*decltype(_impl_.seconds_)*/0
  , /*decltype(_impl_.minute_)*/0} {}
struct time_pointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR time_pointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~time_pointDefaultTypeInternal() {}
  union {
    time_point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 time_pointDefaultTypeInternal _time_point_default_instance_;
PROTOBUF_CONSTEXPR rsa_message::rsa_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.public_modulus_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_exponent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.private_exponent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.private_p_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.private_q_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.private_dp_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.private_dq_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct rsa_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR rsa_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~rsa_messageDefaultTypeInternal() {}
  union {
    rsa_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 rsa_messageDefaultTypeInternal _rsa_message_default_instance_;
PROTOBUF_CONSTEXPR ecc_message::ecc_message(
    ::_pbi::ConstantInitialized) {}
struct ecc_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ecc_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ecc_messageDefaultTypeInternal() {}
  union {
    ecc_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ecc_messageDefaultTypeInternal _ecc_message_default_instance_;
PROTOBUF_CONSTEXPR key_message::key_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secret_key_bits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.other_key_formats_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.not_before_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.not_after_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsa_key_)*/nullptr
  , /*decltype(_impl_.ecc_key_)*/nullptr} {}
struct key_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR key_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~key_messageDefaultTypeInternal() {}
  union {
    key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 key_messageDefaultTypeInternal _key_message_default_instance_;
PROTOBUF_CONSTEXPR protected_blob_message::protected_blob_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.encrypted_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encrypted_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct protected_blob_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR protected_blob_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~protected_blob_messageDefaultTypeInternal() {}
  union {
    protected_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 protected_blob_messageDefaultTypeInternal _protected_blob_message_default_instance_;
PROTOBUF_CONSTEXPR entity_message::entity_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.measurement_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/nullptr} {}
struct entity_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR entity_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~entity_messageDefaultTypeInternal() {}
  union {
    entity_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 entity_messageDefaultTypeInternal _entity_message_default_instance_;
PROTOBUF_CONSTEXPR vse_clause::vse_clause(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.verb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subject_)*/nullptr
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.clause_)*/nullptr} {}
struct vse_clauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vse_clauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vse_clauseDefaultTypeInternal() {}
  union {
    vse_clause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vse_clauseDefaultTypeInternal _vse_clause_default_instance_;
PROTOBUF_CONSTEXPR vse_clauses::vse_clauses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clauses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct vse_clausesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vse_clausesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vse_clausesDefaultTypeInternal() {}
  union {
    vse_clauses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vse_clausesDefaultTypeInternal _vse_clauses_default_instance_;
PROTOBUF_CONSTEXPR attestation::attestation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enclave_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.measurement_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clause_)*/nullptr} {}
struct attestationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR attestationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~attestationDefaultTypeInternal() {}
  union {
    attestation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 attestationDefaultTypeInternal _attestation_default_instance_;
PROTOBUF_CONSTEXPR claim_message::claim_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.claim_format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.claim_descriptor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.not_before_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.not_after_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serialized_claim_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct claim_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR claim_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~claim_messageDefaultTypeInternal() {}
  union {
    claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 claim_messageDefaultTypeInternal _claim_message_default_instance_;
PROTOBUF_CONSTEXPR signed_claim_message::signed_claim_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.serialized_claim_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signing_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signing_key_)*/nullptr} {}
struct signed_claim_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR signed_claim_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~signed_claim_messageDefaultTypeInternal() {}
  union {
    signed_claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 signed_claim_messageDefaultTypeInternal _signed_claim_message_default_instance_;
PROTOBUF_CONSTEXPR oe_assertion::oe_assertion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.oe_report_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct oe_assertionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR oe_assertionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~oe_assertionDefaultTypeInternal() {}
  union {
    oe_assertion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 oe_assertionDefaultTypeInternal _oe_assertion_default_instance_;
PROTOBUF_CONSTEXPR evidence::evidence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.evidence_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serialized_evidence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct evidenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR evidenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~evidenceDefaultTypeInternal() {}
  union {
    evidence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 evidenceDefaultTypeInternal _evidence_default_instance_;
PROTOBUF_CONSTEXPR evidence_package::evidence_package(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fact_assertion_)*/{}
  , /*decltype(_impl_.prover_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct evidence_packageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR evidence_packageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~evidence_packageDefaultTypeInternal() {}
  union {
    evidence_package _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 evidence_packageDefaultTypeInternal _evidence_package_default_instance_;
PROTOBUF_CONSTEXPR certifier_rules::certifier_rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rule_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct certifier_rulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR certifier_rulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~certifier_rulesDefaultTypeInternal() {}
  union {
    certifier_rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 certifier_rulesDefaultTypeInternal _certifier_rules_default_instance_;
PROTOBUF_CONSTEXPR proved_statements::proved_statements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proved_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct proved_statementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proved_statementsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proved_statementsDefaultTypeInternal() {}
  union {
    proved_statements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proved_statementsDefaultTypeInternal _proved_statements_default_instance_;
PROTOBUF_CONSTEXPR proof_step::proof_step(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.s1_)*/nullptr
  , /*decltype(_impl_.s2_)*/nullptr
  , /*decltype(_impl_.conclusion_)*/nullptr
  , /*decltype(_impl_.rule_applied_)*/0} {}
struct proof_stepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proof_stepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proof_stepDefaultTypeInternal() {}
  union {
    proof_step _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proof_stepDefaultTypeInternal _proof_step_default_instance_;
PROTOBUF_CONSTEXPR proof::proof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.already_proved_)*/{}
  , /*decltype(_impl_.steps_)*/{}
  , /*decltype(_impl_.to_prove_)*/nullptr} {}
struct proofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proofDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proofDefaultTypeInternal() {}
  union {
    proof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proofDefaultTypeInternal _proof_default_instance_;
PROTOBUF_CONSTEXPR trust_request_message::trust_request_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.requesting_enclave_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.providing_enclave_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.submitted_evidence_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.purpose_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.support_)*/nullptr} {}
struct trust_request_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trust_request_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trust_request_messageDefaultTypeInternal() {}
  union {
    trust_request_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trust_request_messageDefaultTypeInternal _trust_request_message_default_instance_;
PROTOBUF_CONSTEXPR trust_response_message::trust_response_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.requesting_enclave_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.providing_enclave_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.artifact_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct trust_response_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trust_response_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trust_response_messageDefaultTypeInternal() {}
  union {
    trust_response_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trust_response_messageDefaultTypeInternal _trust_response_message_default_instance_;
PROTOBUF_CONSTEXPR storage_info_message::storage_info_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.storage_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storage_descriptor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storage_key_)*/nullptr} {}
struct storage_info_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR storage_info_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~storage_info_messageDefaultTypeInternal() {}
  union {
    storage_info_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 storage_info_messageDefaultTypeInternal _storage_info_message_default_instance_;
PROTOBUF_CONSTEXPR channel_key_message::channel_key_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_key_)*/nullptr} {}
struct channel_key_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR channel_key_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~channel_key_messageDefaultTypeInternal() {}
  union {
    channel_key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 channel_key_messageDefaultTypeInternal _channel_key_message_default_instance_;
PROTOBUF_CONSTEXPR trusted_service_message::trusted_service_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trusted_service_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.trusted_service_key_)*/nullptr} {}
struct trusted_service_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trusted_service_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trusted_service_messageDefaultTypeInternal() {}
  union {
    trusted_service_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trusted_service_messageDefaultTypeInternal _trusted_service_message_default_instance_;
PROTOBUF_CONSTEXPR tagged_claim::tagged_claim(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.claim_)*/nullptr} {}
struct tagged_claimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_claimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_claimDefaultTypeInternal() {}
  union {
    tagged_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_claimDefaultTypeInternal _tagged_claim_default_instance_;
PROTOBUF_CONSTEXPR tagged_claims_sequence::tagged_claims_sequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.claims_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct tagged_claims_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_claims_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_claims_sequenceDefaultTypeInternal() {}
  union {
    tagged_claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_claims_sequenceDefaultTypeInternal _tagged_claims_sequence_default_instance_;
PROTOBUF_CONSTEXPR policy_store_message::policy_store_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trusted_services_)*/{}
  , /*decltype(_impl_.channel_authentication_keys_)*/{}
  , /*decltype(_impl_.claims_)*/{}
  , /*decltype(_impl_.storage_info_)*/{}
  , /*decltype(_impl_.signed_claims_)*/{}
  , /*decltype(_impl_.blobs_)*/{}
  , /*decltype(_impl_.policy_key_)*/nullptr} {}
struct policy_store_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR policy_store_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~policy_store_messageDefaultTypeInternal() {}
  union {
    policy_store_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 policy_store_messageDefaultTypeInternal _policy_store_message_default_instance_;
PROTOBUF_CONSTEXPR claims_sequence::claims_sequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.claims_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct claims_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR claims_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~claims_sequenceDefaultTypeInternal() {}
  union {
    claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 claims_sequenceDefaultTypeInternal _claims_sequence_default_instance_;
PROTOBUF_CONSTEXPR signed_claim_sequence::signed_claim_sequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.claims_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct signed_claim_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR signed_claim_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~signed_claim_sequenceDefaultTypeInternal() {}
  union {
    signed_claim_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 signed_claim_sequenceDefaultTypeInternal _signed_claim_sequence_default_instance_;
PROTOBUF_CONSTEXPR tagged_signed_claim::tagged_signed_claim(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sc_)*/nullptr} {}
struct tagged_signed_claimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_signed_claimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_signed_claimDefaultTypeInternal() {}
  union {
    tagged_signed_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_signed_claimDefaultTypeInternal _tagged_signed_claim_default_instance_;
PROTOBUF_CONSTEXPR buffer_sequence::buffer_sequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct buffer_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR buffer_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~buffer_sequenceDefaultTypeInternal() {}
  union {
    buffer_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 buffer_sequenceDefaultTypeInternal _buffer_sequence_default_instance_;
PROTOBUF_CONSTEXPR run_request::run_request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cert_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct run_requestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR run_requestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~run_requestDefaultTypeInternal() {}
  union {
    run_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 run_requestDefaultTypeInternal _run_request_default_instance_;
PROTOBUF_CONSTEXPR run_response::run_response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct run_responseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR run_responseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~run_responseDefaultTypeInternal() {}
  union {
    run_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 run_responseDefaultTypeInternal _run_response_default_instance_;
PROTOBUF_CONSTEXPR app_request::app_request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.function_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct app_requestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR app_requestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~app_requestDefaultTypeInternal() {}
  union {
    app_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 app_requestDefaultTypeInternal _app_request_default_instance_;
PROTOBUF_CONSTEXPR app_response::app_response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.function_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct app_responseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR app_responseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~app_responseDefaultTypeInternal() {}
  union {
    app_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 app_responseDefaultTypeInternal _app_response_default_instance_;
PROTOBUF_CONSTEXPR tagged_blob_message::tagged_blob_message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.b_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct tagged_blob_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_blob_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_blob_messageDefaultTypeInternal() {}
  union {
    tagged_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_blob_messageDefaultTypeInternal _tagged_blob_message_default_instance_;
static ::_pb::Metadata file_level_metadata_certifier_2eproto[35];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_certifier_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_certifier_2eproto = nullptr;

const uint32_t TableStruct_certifier_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::time_point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.year_),
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.month_),
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.day_),
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.hour_),
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.minute_),
  PROTOBUF_FIELD_OFFSET(::time_point, _impl_.seconds_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.public_modulus_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.public_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.private_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.private_p_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.private_q_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.private_dp_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _impl_.private_dq_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ecc_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.key_name_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.key_type_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.key_format_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.rsa_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.ecc_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.secret_key_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.certificate_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.other_key_formats_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.not_before_),
  PROTOBUF_FIELD_OFFSET(::key_message, _impl_.not_after_),
  0,
  1,
  2,
  8,
  9,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _impl_.encrypted_key_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _impl_.encrypted_data_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::entity_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::entity_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::entity_message, _impl_.entity_type_),
  PROTOBUF_FIELD_OFFSET(::entity_message, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::entity_message, _impl_.measurement_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::vse_clause, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::vse_clause, _impl_.subject_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _impl_.verb_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _impl_.object_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _impl_.clause_),
  1,
  0,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vse_clauses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::vse_clauses, _impl_.clauses_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::attestation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.enclave_type_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.key_id_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.measurement_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.clause_),
  PROTOBUF_FIELD_OFFSET(::attestation, _impl_.description_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_.claim_format_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_.claim_descriptor_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_.not_before_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_.not_after_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _impl_.serialized_claim_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _impl_.serialized_claim_message_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _impl_.signing_key_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _impl_.signing_algorithm_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _impl_.signature_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _impl_.user_data_),
  PROTOBUF_FIELD_OFFSET(::oe_assertion, _impl_.oe_report_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::evidence, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::evidence, _impl_.evidence_type_),
  PROTOBUF_FIELD_OFFSET(::evidence, _impl_.serialized_evidence_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::evidence_package, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::evidence_package, _impl_.prover_type_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, _impl_.fact_assertion_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::certifier_rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::certifier_rules, _impl_.rule_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proved_statements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::proved_statements, _impl_.proved_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::proof_step, _impl_.s1_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _impl_.s2_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _impl_.conclusion_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _impl_.rule_applied_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proof, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::proof, _impl_.to_prove_),
  PROTOBUF_FIELD_OFFSET(::proof, _impl_.already_proved_),
  PROTOBUF_FIELD_OFFSET(::proof, _impl_.steps_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_.requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_.providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_.submitted_evidence_type_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_.purpose_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _impl_.support_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _impl_.requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _impl_.providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _impl_.artifact_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_.storage_type_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_.storage_descriptor_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_.storage_key_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _impl_.tag_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _impl_.auth_key_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _impl_.trusted_service_address_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _impl_.trusted_service_key_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _impl_.tag_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _impl_.claim_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, _impl_.claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.policy_key_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.trusted_services_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.channel_authentication_keys_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.storage_info_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.signed_claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _impl_.blobs_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::claims_sequence, _impl_.claims_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, _impl_.claims_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _impl_.sc_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, _impl_.block_),
  PROTOBUF_FIELD_OFFSET(::run_request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::run_request, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::run_request, _impl_.cert_),
  PROTOBUF_FIELD_OFFSET(::run_request, _impl_.args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::run_response, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::run_response, _impl_.status_),
  0,
  PROTOBUF_FIELD_OFFSET(::app_request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::app_request, _impl_.function_),
  PROTOBUF_FIELD_OFFSET(::app_request, _impl_.args_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::app_response, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::app_response, _impl_.function_),
  PROTOBUF_FIELD_OFFSET(::app_response, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::app_response, _impl_.args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _impl_.b_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 14, -1, sizeof(::time_point)},
  { 20, 35, -1, sizeof(::rsa_message)},
  { 42, -1, -1, sizeof(::ecc_message)},
  { 50, 68, -1, sizeof(::key_message)},
  { 78, 88, -1, sizeof(::protected_blob_message)},
  { 90, 101, -1, sizeof(::entity_message)},
  { 104, 116, -1, sizeof(::vse_clause)},
  { 120, -1, -1, sizeof(::vse_clauses)},
  { 129, 143, -1, sizeof(::attestation)},
  { 149, 162, -1, sizeof(::claim_message)},
  { 167, 179, -1, sizeof(::signed_claim_message)},
  { 183, 193, -1, sizeof(::oe_assertion)},
  { 195, 205, -1, sizeof(::evidence)},
  { 207, 217, -1, sizeof(::evidence_package)},
  { 219, -1, -1, sizeof(::certifier_rules)},
  { 228, -1, -1, sizeof(::proved_statements)},
  { 237, 249, -1, sizeof(::proof_step)},
  { 253, 264, -1, sizeof(::proof)},
  { 267, 280, -1, sizeof(::trust_request_message)},
  { 285, 297, -1, sizeof(::trust_response_message)},
  { 301, 314, -1, sizeof(::storage_info_message)},
  { 319, 329, -1, sizeof(::channel_key_message)},
  { 331, 342, -1, sizeof(::trusted_service_message)},
  { 345, 355, -1, sizeof(::tagged_claim)},
  { 357, -1, -1, sizeof(::tagged_claims_sequence)},
  { 366, 381, -1, sizeof(::policy_store_message)},
  { 388, -1, -1, sizeof(::claims_sequence)},
  { 397, -1, -1, sizeof(::signed_claim_sequence)},
  { 406, 416, -1, sizeof(::tagged_signed_claim)},
  { 418, -1, -1, sizeof(::buffer_sequence)},
  { 427, 438, -1, sizeof(::run_request)},
  { 441, 450, -1, sizeof(::run_response)},
  { 451, 461, -1, sizeof(::app_request)},
  { 463, 474, -1, sizeof(::app_response)},
  { 477, 487, -1, sizeof(::tagged_blob_message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_time_point_default_instance_._instance,
  &::_rsa_message_default_instance_._instance,
  &::_ecc_message_default_instance_._instance,
  &::_key_message_default_instance_._instance,
  &::_protected_blob_message_default_instance_._instance,
  &::_entity_message_default_instance_._instance,
  &::_vse_clause_default_instance_._instance,
  &::_vse_clauses_default_instance_._instance,
  &::_attestation_default_instance_._instance,
  &::_claim_message_default_instance_._instance,
  &::_signed_claim_message_default_instance_._instance,
  &::_oe_assertion_default_instance_._instance,
  &::_evidence_default_instance_._instance,
  &::_evidence_package_default_instance_._instance,
  &::_certifier_rules_default_instance_._instance,
  &::_proved_statements_default_instance_._instance,
  &::_proof_step_default_instance_._instance,
  &::_proof_default_instance_._instance,
  &::_trust_request_message_default_instance_._instance,
  &::_trust_response_message_default_instance_._instance,
  &::_storage_info_message_default_instance_._instance,
  &::_channel_key_message_default_instance_._instance,
  &::_trusted_service_message_default_instance_._instance,
  &::_tagged_claim_default_instance_._instance,
  &::_tagged_claims_sequence_default_instance_._instance,
  &::_policy_store_message_default_instance_._instance,
  &::_claims_sequence_default_instance_._instance,
  &::_signed_claim_sequence_default_instance_._instance,
  &::_tagged_signed_claim_default_instance_._instance,
  &::_buffer_sequence_default_instance_._instance,
  &::_run_request_default_instance_._instance,
  &::_run_response_default_instance_._instance,
  &::_app_request_default_instance_._instance,
  &::_app_response_default_instance_._instance,
  &::_tagged_blob_message_default_instance_._instance,
};

const char descriptor_table_protodef_certifier_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017certifier.proto\"e\n\ntime_point\022\014\n\004year\030"
  "\001 \001(\005\022\r\n\005month\030\002 \001(\005\022\013\n\003day\030\003 \001(\005\022\014\n\004hou"
  "r\030\004 \001(\005\022\016\n\006minute\030\005 \001(\005\022\017\n\007seconds\030\006 \001(\001"
  "\"\246\001\n\013rsa_message\022\026\n\016public_modulus\030\001 \001(\014"
  "\022\027\n\017public_exponent\030\002 \001(\014\022\030\n\020private_exp"
  "onent\030\003 \001(\014\022\021\n\tprivate_p\030\004 \001(\014\022\021\n\tprivat"
  "e_q\030\005 \001(\014\022\022\n\nprivate_dp\030\006 \001(\014\022\022\n\nprivate"
  "_dq\030\007 \001(\014\"\r\n\013ecc_message\"\363\001\n\013key_message"
  "\022\020\n\010key_name\030\001 \001(\t\022\020\n\010key_type\030\002 \001(\t\022\022\n\n"
  "key_format\030\003 \001(\t\022\035\n\007rsa_key\030\004 \001(\0132\014.rsa_"
  "message\022\035\n\007ecc_key\030\005 \001(\0132\014.ecc_message\022\027"
  "\n\017secret_key_bits\030\006 \001(\014\022\023\n\013certificate\030\007"
  " \001(\014\022\031\n\021other_key_formats\030\010 \001(\014\022\022\n\nnot_b"
  "efore\030\t \001(\t\022\021\n\tnot_after\030\n \001(\t\"G\n\026protec"
  "ted_blob_message\022\025\n\rencrypted_key\030\001 \001(\014\022"
  "\026\n\016encrypted_data\030\002 \001(\014\"U\n\016entity_messag"
  "e\022\023\n\013entity_type\030\001 \001(\t\022\031\n\003key\030\002 \001(\0132\014.ke"
  "y_message\022\023\n\013measurement\030\003 \001(\014\"z\n\nvse_cl"
  "ause\022 \n\007subject\030\001 \001(\0132\017.entity_message\022\014"
  "\n\004verb\030\002 \001(\t\022\037\n\006object\030\003 \001(\0132\017.entity_me"
  "ssage\022\033\n\006clause\030\004 \001(\0132\013.vse_clause\"+\n\013vs"
  "e_clauses\022\034\n\007clauses\030\001 \003(\0132\013.vse_clause\""
  "\210\001\n\013attestation\022\024\n\014enclave_type\030\001 \001(\t\022\016\n"
  "\006key_id\030\002 \001(\t\022\023\n\013measurement\030\003 \001(\014\022\014\n\004ti"
  "me\030\004 \001(\t\022\033\n\006clause\030\005 \001(\0132\013.vse_clause\022\023\n"
  "\013description\030\006 \001(\t\"\200\001\n\rclaim_message\022\024\n\014"
  "claim_format\030\001 \001(\t\022\030\n\020claim_descriptor\030\002"
  " \001(\t\022\022\n\nnot_before\030\003 \001(\t\022\021\n\tnot_after\030\004 "
  "\001(\t\022\030\n\020serialized_claim\030\005 \001(\014\"\211\001\n\024signed"
  "_claim_message\022 \n\030serialized_claim_messa"
  "ge\030\001 \001(\014\022!\n\013signing_key\030\002 \001(\0132\014.key_mess"
  "age\022\031\n\021signing_algorithm\030\003 \001(\t\022\021\n\tsignat"
  "ure\030\004 \001(\014\"4\n\014oe_assertion\022\021\n\tuser_data\030\001"
  " \001(\014\022\021\n\toe_report\030\002 \001(\014\">\n\010evidence\022\025\n\re"
  "vidence_type\030\001 \001(\t\022\033\n\023serialized_evidenc"
  "e\030\002 \001(\014\"J\n\020evidence_package\022\023\n\013prover_ty"
  "pe\030\001 \001(\t\022!\n\016fact_assertion\030\002 \003(\0132\t.evide"
  "nce\"\037\n\017certifier_rules\022\014\n\004rule\030\001 \003(\t\"0\n\021"
  "proved_statements\022\033\n\006proved\030\001 \003(\0132\013.vse_"
  "clause\"u\n\nproof_step\022\027\n\002s1\030\001 \001(\0132\013.vse_c"
  "lause\022\027\n\002s2\030\002 \001(\0132\013.vse_clause\022\037\n\nconclu"
  "sion\030\003 \001(\0132\013.vse_clause\022\024\n\014rule_applied\030"
  "\004 \001(\005\"g\n\005proof\022\035\n\010to_prove\030\001 \001(\0132\013.vse_c"
  "lause\022#\n\016already_proved\030\002 \003(\0132\013.vse_clau"
  "se\022\032\n\005steps\030\003 \003(\0132\013.proof_step\"\254\001\n\025trust"
  "_request_message\022\036\n\026requesting_enclave_t"
  "ag\030\001 \001(\t\022\035\n\025providing_enclave_tag\030\002 \001(\t\022"
  "\037\n\027submitted_evidence_type\030\003 \001(\t\022\017\n\007purp"
  "ose\030\004 \001(\t\022\"\n\007support\030\005 \001(\0132\021.evidence_pa"
  "ckage\"y\n\026trust_response_message\022\016\n\006statu"
  "s\030\001 \001(\t\022\036\n\026requesting_enclave_tag\030\002 \001(\t\022"
  "\035\n\025providing_enclave_tag\030\003 \001(\t\022\020\n\010artifa"
  "ct\030\004 \001(\014\"\211\001\n\024storage_info_message\022\024\n\014sto"
  "rage_type\030\001 \001(\t\022\032\n\022storage_descriptor\030\002 "
  "\001(\t\022\017\n\007address\030\003 \001(\t\022!\n\013storage_key\030\004 \001("
  "\0132\014.key_message\022\013\n\003tag\030\005 \001(\t\"B\n\023channel_"
  "key_message\022\013\n\003tag\030\001 \001(\t\022\036\n\010auth_key\030\002 \001"
  "(\0132\014.key_message\"r\n\027trusted_service_mess"
  "age\022\037\n\027trusted_service_address\030\001 \001(\t\022)\n\023"
  "trusted_service_key\030\002 \001(\0132\014.key_message\022"
  "\013\n\003tag\030\003 \001(\t\":\n\014tagged_claim\022\013\n\003tag\030\001 \001("
  "\t\022\035\n\005claim\030\002 \001(\0132\016.claim_message\"7\n\026tagg"
  "ed_claims_sequence\022\035\n\006claims\030\001 \003(\0132\r.tag"
  "ged_claim\"\305\002\n\024policy_store_message\022 \n\npo"
  "licy_key\030\001 \001(\0132\014.key_message\0222\n\020trusted_"
  "services\030\002 \003(\0132\030.trusted_service_message"
  "\0229\n\033channel_authentication_keys\030\003 \003(\0132\024."
  "channel_key_message\022\035\n\006claims\030\004 \003(\0132\r.ta"
  "gged_claim\022+\n\014storage_info\030\005 \003(\0132\025.stora"
  "ge_info_message\022+\n\rsigned_claims\030\006 \003(\0132\024"
  ".tagged_signed_claim\022#\n\005blobs\030\007 \003(\0132\024.ta"
  "gged_blob_message\"1\n\017claims_sequence\022\036\n\006"
  "claims\030\001 \003(\0132\016.claim_message\">\n\025signed_c"
  "laim_sequence\022%\n\006claims\030\001 \003(\0132\025.signed_c"
  "laim_message\"E\n\023tagged_signed_claim\022\013\n\003t"
  "ag\030\001 \001(\t\022!\n\002sc\030\002 \001(\0132\025.signed_claim_mess"
  "age\" \n\017buffer_sequence\022\r\n\005block\030\001 \003(\014\";\n"
  "\013run_request\022\020\n\010location\030\001 \001(\t\022\014\n\004cert\030\002"
  " \001(\014\022\014\n\004args\030\003 \003(\t\"\036\n\014run_response\022\016\n\006st"
  "atus\030\001 \001(\t\"-\n\013app_request\022\020\n\010function\030\001 "
  "\001(\t\022\014\n\004args\030\002 \003(\014\">\n\014app_response\022\020\n\010fun"
  "ction\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022\014\n\004args\030\003 \003("
  "\014\"-\n\023tagged_blob_message\022\013\n\003tag\030\001 \001(\t\022\t\n"
  "\001b\030\002 \001(\014"
  ;
static ::_pbi::once_flag descriptor_table_certifier_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_certifier_2eproto = {
    false, false, 3328, descriptor_table_protodef_certifier_2eproto,
    "certifier.proto",
    &descriptor_table_certifier_2eproto_once, nullptr, 0, 35,
    schemas, file_default_instances, TableStruct_certifier_2eproto::offsets,
    file_level_metadata_certifier_2eproto, file_level_enum_descriptors_certifier_2eproto,
    file_level_service_descriptors_certifier_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_certifier_2eproto_getter() {
  return &descriptor_table_certifier_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_certifier_2eproto(&descriptor_table_certifier_2eproto);

// ===================================================================

class time_point::_Internal {
 public:
  using HasBits = decltype(std::declval<time_point>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(time_point, _impl_._has_bits_);
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_month(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_day(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hour(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minute(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

time_point::time_point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:time_point)
}
time_point::time_point(const time_point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  time_point* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.year_){}
    , decltype(_impl_.month_){}
    , decltype(_impl_.day_){}
    , decltype(_impl_.hour_){}
    , decltype(_impl_.seconds_){}
    , decltype(_impl_.minute_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.year_, &from._impl_.year_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.minute_) -
    reinterpret_cast<char*>(&_impl_.year_)) + sizeof(_impl_.minute_));
  // @@protoc_insertion_point(copy_constructor:time_point)
}

inline void time_point::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.year_){0}
    , decltype(_impl_.month_){0}
    , decltype(_impl_.day_){0}
    , decltype(_impl_.hour_){0}
    , decltype(_impl_.seconds_){0}
    , decltype(_impl_.minute_){0}
  };
}

time_point::~time_point() {
  // @@protoc_insertion_point(destructor:time_point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void time_point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void time_point::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void time_point::Clear() {
// @@protoc_insertion_point(message_clear_start:time_point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.year_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.minute_) -
        reinterpret_cast<char*>(&_impl_.year_)) + sizeof(_impl_.minute_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* time_point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 year = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_year(&has_bits);
          _impl_.year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 month = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_month(&has_bits);
          _impl_.month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 day = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_day(&has_bits);
          _impl_.day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hour = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hour(&has_bits);
          _impl_.hour_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minute = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_minute(&has_bits);
          _impl_.minute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* time_point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:time_point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 year = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_year(), target);
  }

  // optional int32 month = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_month(), target);
  }

  // optional int32 day = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_day(), target);
  }

  // optional int32 hour = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_hour(), target);
  }

  // optional int32 minute = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_minute(), target);
  }

  // optional double seconds = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:time_point)
  return target;
}

size_t time_point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:time_point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 year = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_year());
    }

    // optional int32 month = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_month());
    }

    // optional int32 day = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_day());
    }

    // optional int32 hour = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hour());
    }

    // optional double seconds = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int32 minute = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minute());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData time_point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    time_point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*time_point::GetClassData() const { return &_class_data_; }


void time_point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<time_point*>(&to_msg);
  auto& from = static_cast<const time_point&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:time_point)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.year_ = from._impl_.year_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.month_ = from._impl_.month_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.day_ = from._impl_.day_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hour_ = from._impl_.hour_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.seconds_ = from._impl_.seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.minute_ = from._impl_.minute_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void time_point::CopyFrom(const time_point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:time_point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time_point::IsInitialized() const {
  return true;
}

void time_point::InternalSwap(time_point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(time_point, _impl_.minute_)
      + sizeof(time_point::_impl_.minute_)
      - PROTOBUF_FIELD_OFFSET(time_point, _impl_.year_)>(
          reinterpret_cast<char*>(&_impl_.year_),
          reinterpret_cast<char*>(&other->_impl_.year_));
}

::PROTOBUF_NAMESPACE_ID::Metadata time_point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[0]);
}

// ===================================================================

class rsa_message::_Internal {
 public:
  using HasBits = decltype(std::declval<rsa_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(rsa_message, _impl_._has_bits_);
  static void set_has_public_modulus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_public_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_private_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_private_p(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_private_q(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_private_dp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_private_dq(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

rsa_message::rsa_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:rsa_message)
}
rsa_message::rsa_message(const rsa_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  rsa_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_modulus_){}
    , decltype(_impl_.public_exponent_){}
    , decltype(_impl_.private_exponent_){}
    , decltype(_impl_.private_p_){}
    , decltype(_impl_.private_q_){}
    , decltype(_impl_.private_dp_){}
    , decltype(_impl_.private_dq_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.public_modulus_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_modulus_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_modulus()) {
    _this->_impl_.public_modulus_.Set(from._internal_public_modulus(), 
      _this->GetArenaForAllocation());
  }
  _impl_.public_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_exponent()) {
    _this->_impl_.public_exponent_.Set(from._internal_public_exponent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.private_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_exponent()) {
    _this->_impl_.private_exponent_.Set(from._internal_private_exponent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.private_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_p()) {
    _this->_impl_.private_p_.Set(from._internal_private_p(), 
      _this->GetArenaForAllocation());
  }
  _impl_.private_q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_q_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_q()) {
    _this->_impl_.private_q_.Set(from._internal_private_q(), 
      _this->GetArenaForAllocation());
  }
  _impl_.private_dp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_dp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dp()) {
    _this->_impl_.private_dp_.Set(from._internal_private_dp(), 
      _this->GetArenaForAllocation());
  }
  _impl_.private_dq_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_dq_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dq()) {
    _this->_impl_.private_dq_.Set(from._internal_private_dq(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:rsa_message)
}

inline void rsa_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_modulus_){}
    , decltype(_impl_.public_exponent_){}
    , decltype(_impl_.private_exponent_){}
    , decltype(_impl_.private_p_){}
    , decltype(_impl_.private_q_){}
    , decltype(_impl_.private_dp_){}
    , decltype(_impl_.private_dq_){}
  };
  _impl_.public_modulus_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_modulus_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.private_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.private_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.private_q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_q_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.private_dp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_dp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.private_dq_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.private_dq_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

rsa_message::~rsa_message() {
  // @@protoc_insertion_point(destructor:rsa_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void rsa_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_modulus_.Destroy();
  _impl_.public_exponent_.Destroy();
  _impl_.private_exponent_.Destroy();
  _impl_.private_p_.Destroy();
  _impl_.private_q_.Destroy();
  _impl_.private_dp_.Destroy();
  _impl_.private_dq_.Destroy();
}

void rsa_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void rsa_message::Clear() {
// @@protoc_insertion_point(message_clear_start:rsa_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.public_modulus_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.public_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.private_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.private_p_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.private_q_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.private_dp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.private_dq_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* rsa_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes public_modulus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_public_modulus();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes public_exponent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_public_exponent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_exponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_private_exponent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_p = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_private_p();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_q = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_private_q();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_private_dp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_private_dq();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* rsa_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rsa_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes public_modulus = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_public_modulus(), target);
  }

  // optional bytes public_exponent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_public_exponent(), target);
  }

  // optional bytes private_exponent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_private_exponent(), target);
  }

  // optional bytes private_p = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_private_p(), target);
  }

  // optional bytes private_q = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_private_q(), target);
  }

  // optional bytes private_dp = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_private_dp(), target);
  }

  // optional bytes private_dq = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_private_dq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rsa_message)
  return target;
}

size_t rsa_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rsa_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes public_modulus = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_modulus());
    }

    // optional bytes public_exponent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_exponent());
    }

    // optional bytes private_exponent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_exponent());
    }

    // optional bytes private_p = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_p());
    }

    // optional bytes private_q = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_q());
    }

    // optional bytes private_dp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dp());
    }

    // optional bytes private_dq = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dq());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData rsa_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    rsa_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*rsa_message::GetClassData() const { return &_class_data_; }


void rsa_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<rsa_message*>(&to_msg);
  auto& from = static_cast<const rsa_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:rsa_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_public_modulus(from._internal_public_modulus());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_public_exponent(from._internal_public_exponent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_private_exponent(from._internal_private_exponent());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_private_p(from._internal_private_p());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_private_q(from._internal_private_q());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_private_dp(from._internal_private_dp());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_private_dq(from._internal_private_dq());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void rsa_message::CopyFrom(const rsa_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rsa_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rsa_message::IsInitialized() const {
  return true;
}

void rsa_message::InternalSwap(rsa_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_modulus_, lhs_arena,
      &other->_impl_.public_modulus_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_exponent_, lhs_arena,
      &other->_impl_.public_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.private_exponent_, lhs_arena,
      &other->_impl_.private_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.private_p_, lhs_arena,
      &other->_impl_.private_p_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.private_q_, lhs_arena,
      &other->_impl_.private_q_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.private_dp_, lhs_arena,
      &other->_impl_.private_dp_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.private_dq_, lhs_arena,
      &other->_impl_.private_dq_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata rsa_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[1]);
}

// ===================================================================

class ecc_message::_Internal {
 public:
};

ecc_message::ecc_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:ecc_message)
}
ecc_message::ecc_message(const ecc_message& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ecc_message* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ecc_message)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ecc_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ecc_message::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ecc_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[2]);
}

// ===================================================================

class key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<key_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(key_message, _impl_._has_bits_);
  static void set_has_key_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::rsa_message& rsa_key(const key_message* msg);
  static void set_has_rsa_key(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ecc_message& ecc_key(const key_message* msg);
  static void set_has_ecc_key(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_secret_key_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_other_key_formats(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::rsa_message&
key_message::_Internal::rsa_key(const key_message* msg) {
  return *msg->_impl_.rsa_key_;
}
const ::ecc_message&
key_message::_Internal::ecc_key(const key_message* msg) {
  return *msg->_impl_.ecc_key_;
}
key_message::key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:key_message)
}
key_message::key_message(const key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  key_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_name_){}
    , decltype(_impl_.key_type_){}
    , decltype(_impl_.key_format_){}
    , decltype(_impl_.secret_key_bits_){}
    , decltype(_impl_.certificate_){}
    , decltype(_impl_.other_key_formats_){}
    , decltype(_impl_.not_before_){}
    , decltype(_impl_.not_after_){}
    , decltype(_impl_.rsa_key_){nullptr}
    , decltype(_impl_.ecc_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_name()) {
    _this->_impl_.key_name_.Set(from._internal_key_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_type()) {
    _this->_impl_.key_type_.Set(from._internal_key_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_format()) {
    _this->_impl_.key_format_.Set(from._internal_key_format(), 
      _this->GetArenaForAllocation());
  }
  _impl_.secret_key_bits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_key_bits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secret_key_bits()) {
    _this->_impl_.secret_key_bits_.Set(from._internal_secret_key_bits(), 
      _this->GetArenaForAllocation());
  }
  _impl_.certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_certificate()) {
    _this->_impl_.certificate_.Set(from._internal_certificate(), 
      _this->GetArenaForAllocation());
  }
  _impl_.other_key_formats_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.other_key_formats_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_other_key_formats()) {
    _this->_impl_.other_key_formats_.Set(from._internal_other_key_formats(), 
      _this->GetArenaForAllocation());
  }
  _impl_.not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    _this->_impl_.not_before_.Set(from._internal_not_before(), 
      _this->GetArenaForAllocation());
  }
  _impl_.not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    _this->_impl_.not_after_.Set(from._internal_not_after(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rsa_key()) {
    _this->_impl_.rsa_key_ = new ::rsa_message(*from._impl_.rsa_key_);
  }
  if (from._internal_has_ecc_key()) {
    _this->_impl_.ecc_key_ = new ::ecc_message(*from._impl_.ecc_key_);
  }
  // @@protoc_insertion_point(copy_constructor:key_message)
}

inline void key_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_name_){}
    , decltype(_impl_.key_type_){}
    , decltype(_impl_.key_format_){}
    , decltype(_impl_.secret_key_bits_){}
    , decltype(_impl_.certificate_){}
    , decltype(_impl_.other_key_formats_){}
    , decltype(_impl_.not_before_){}
    , decltype(_impl_.not_after_){}
    , decltype(_impl_.rsa_key_){nullptr}
    , decltype(_impl_.ecc_key_){nullptr}
  };
  _impl_.key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secret_key_bits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_key_bits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.other_key_formats_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.other_key_formats_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

key_message::~key_message() {
  // @@protoc_insertion_point(destructor:key_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_name_.Destroy();
  _impl_.key_type_.Destroy();
  _impl_.key_format_.Destroy();
  _impl_.secret_key_bits_.Destroy();
  _impl_.certificate_.Destroy();
  _impl_.other_key_formats_.Destroy();
  _impl_.not_before_.Destroy();
  _impl_.not_after_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rsa_key_;
  if (this != internal_default_instance()) delete _impl_.ecc_key_;
}

void key_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.key_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.key_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.secret_key_bits_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.certificate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.other_key_formats_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.not_after_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.rsa_key_ != nullptr);
      _impl_.rsa_key_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.ecc_key_ != nullptr);
      _impl_.ecc_key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* key_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string key_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string key_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .rsa_message rsa_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsa_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ecc_message ecc_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecc_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secret_key_bits = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_secret_key_bits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes certificate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes other_key_formats = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_other_key_formats();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_not_before();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.not_before");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_not_after();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.not_after");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string key_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_name().data(), static_cast<int>(this->_internal_key_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key_name(), target);
  }

  // optional string key_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_type().data(), static_cast<int>(this->_internal_key_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key_type(), target);
  }

  // optional string key_format = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_format().data(), static_cast<int>(this->_internal_key_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_format");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_key_format(), target);
  }

  // optional .rsa_message rsa_key = 4;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rsa_key(this),
        _Internal::rsa_key(this).GetCachedSize(), target, stream);
  }

  // optional .ecc_message ecc_key = 5;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::ecc_key(this),
        _Internal::ecc_key(this).GetCachedSize(), target, stream);
  }

  // optional bytes secret_key_bits = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_secret_key_bits(), target);
  }

  // optional bytes certificate = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_certificate(), target);
  }

  // optional bytes other_key_formats = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_other_key_formats(), target);
  }

  // optional string not_before = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_before");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_not_before(), target);
  }

  // optional string not_after = 10;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_after");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_not_after(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:key_message)
  return target;
}

size_t key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string key_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_name());
    }

    // optional string key_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_type());
    }

    // optional string key_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_format());
    }

    // optional bytes secret_key_bits = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secret_key_bits());
    }

    // optional bytes certificate = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_certificate());
    }

    // optional bytes other_key_formats = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_other_key_formats());
    }

    // optional string not_before = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .rsa_message rsa_key = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsa_key_);
    }

    // optional .ecc_message ecc_key = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ecc_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*key_message::GetClassData() const { return &_class_data_; }


void key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<key_message*>(&to_msg);
  auto& from = static_cast<const key_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:key_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key_name(from._internal_key_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_key_type(from._internal_key_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_key_format(from._internal_key_format());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_secret_key_bits(from._internal_secret_key_bits());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_certificate(from._internal_certificate());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_other_key_formats(from._internal_other_key_formats());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_not_after(from._internal_not_after());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_rsa_key()->::rsa_message::MergeFrom(
          from._internal_rsa_key());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_ecc_key()->::ecc_message::MergeFrom(
          from._internal_ecc_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void key_message::CopyFrom(const key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool key_message::IsInitialized() const {
  return true;
}

void key_message::InternalSwap(key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_name_, lhs_arena,
      &other->_impl_.key_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_type_, lhs_arena,
      &other->_impl_.key_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_format_, lhs_arena,
      &other->_impl_.key_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secret_key_bits_, lhs_arena,
      &other->_impl_.secret_key_bits_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.certificate_, lhs_arena,
      &other->_impl_.certificate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.other_key_formats_, lhs_arena,
      &other->_impl_.other_key_formats_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.not_before_, lhs_arena,
      &other->_impl_.not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.not_after_, lhs_arena,
      &other->_impl_.not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(key_message, _impl_.ecc_key_)
      + sizeof(key_message::_impl_.ecc_key_)
      - PROTOBUF_FIELD_OFFSET(key_message, _impl_.rsa_key_)>(
          reinterpret_cast<char*>(&_impl_.rsa_key_),
          reinterpret_cast<char*>(&other->_impl_.rsa_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata key_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[3]);
}

// ===================================================================

class protected_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<protected_blob_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(protected_blob_message, _impl_._has_bits_);
  static void set_has_encrypted_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encrypted_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

protected_blob_message::protected_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protected_blob_message)
}
protected_blob_message::protected_blob_message(const protected_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  protected_blob_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encrypted_key_){}
    , decltype(_impl_.encrypted_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.encrypted_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_key()) {
    _this->_impl_.encrypted_key_.Set(from._internal_encrypted_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encrypted_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_data()) {
    _this->_impl_.encrypted_data_.Set(from._internal_encrypted_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protected_blob_message)
}

inline void protected_blob_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encrypted_key_){}
    , decltype(_impl_.encrypted_data_){}
  };
  _impl_.encrypted_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encrypted_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

protected_blob_message::~protected_blob_message() {
  // @@protoc_insertion_point(destructor:protected_blob_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void protected_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encrypted_key_.Destroy();
  _impl_.encrypted_data_.Destroy();
}

void protected_blob_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void protected_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.encrypted_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.encrypted_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* protected_blob_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes encrypted_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encrypted_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* protected_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes encrypted_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_key(), target);
  }

  // optional bytes encrypted_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_encrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protected_blob_message)
  return target;
}

size_t protected_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protected_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes encrypted_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_key());
    }

    // optional bytes encrypted_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData protected_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    protected_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*protected_blob_message::GetClassData() const { return &_class_data_; }


void protected_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<protected_blob_message*>(&to_msg);
  auto& from = static_cast<const protected_blob_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protected_blob_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_encrypted_key(from._internal_encrypted_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_encrypted_data(from._internal_encrypted_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void protected_blob_message::CopyFrom(const protected_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protected_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool protected_blob_message::IsInitialized() const {
  return true;
}

void protected_blob_message::InternalSwap(protected_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encrypted_key_, lhs_arena,
      &other->_impl_.encrypted_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encrypted_data_, lhs_arena,
      &other->_impl_.encrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata protected_blob_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[4]);
}

// ===================================================================

class entity_message::_Internal {
 public:
  using HasBits = decltype(std::declval<entity_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(entity_message, _impl_._has_bits_);
  static void set_has_entity_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& key(const entity_message* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
entity_message::_Internal::key(const entity_message* msg) {
  return *msg->_impl_.key_;
}
entity_message::entity_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:entity_message)
}
entity_message::entity_message(const entity_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  entity_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_type_){}
    , decltype(_impl_.measurement_){}
    , decltype(_impl_.key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_type()) {
    _this->_impl_.entity_type_.Set(from._internal_entity_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_measurement()) {
    _this->_impl_.measurement_.Set(from._internal_measurement(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::key_message(*from._impl_.key_);
  }
  // @@protoc_insertion_point(copy_constructor:entity_message)
}

inline void entity_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_type_){}
    , decltype(_impl_.measurement_){}
    , decltype(_impl_.key_){nullptr}
  };
  _impl_.entity_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

entity_message::~entity_message() {
  // @@protoc_insertion_point(destructor:entity_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void entity_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entity_type_.Destroy();
  _impl_.measurement_.Destroy();
  if (this != internal_default_instance()) delete _impl_.key_;
}

void entity_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void entity_message::Clear() {
// @@protoc_insertion_point(message_clear_start:entity_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.entity_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.key_ != nullptr);
      _impl_.key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* entity_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string entity_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entity_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "entity_message.entity_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes measurement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_measurement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* entity_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:entity_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string entity_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_entity_type().data(), static_cast<int>(this->_internal_entity_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "entity_message.entity_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_entity_type(), target);
  }

  // optional .key_message key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // optional bytes measurement = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_measurement(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:entity_message)
  return target;
}

size_t entity_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:entity_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string entity_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_entity_type());
    }

    // optional bytes measurement = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_measurement());
    }

    // optional .key_message key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData entity_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    entity_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*entity_message::GetClassData() const { return &_class_data_; }


void entity_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<entity_message*>(&to_msg);
  auto& from = static_cast<const entity_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:entity_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_type(from._internal_entity_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_measurement(from._internal_measurement());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_key()->::key_message::MergeFrom(
          from._internal_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void entity_message::CopyFrom(const entity_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:entity_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool entity_message::IsInitialized() const {
  return true;
}

void entity_message::InternalSwap(entity_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_type_, lhs_arena,
      &other->_impl_.entity_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.measurement_, lhs_arena,
      &other->_impl_.measurement_, rhs_arena
  );
  swap(_impl_.key_, other->_impl_.key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata entity_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[5]);
}

// ===================================================================

class vse_clause::_Internal {
 public:
  using HasBits = decltype(std::declval<vse_clause>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(vse_clause, _impl_._has_bits_);
  static const ::entity_message& subject(const vse_clause* msg);
  static void set_has_subject(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_verb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::entity_message& object(const vse_clause* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::vse_clause& clause(const vse_clause* msg);
  static void set_has_clause(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::entity_message&
vse_clause::_Internal::subject(const vse_clause* msg) {
  return *msg->_impl_.subject_;
}
const ::entity_message&
vse_clause::_Internal::object(const vse_clause* msg) {
  return *msg->_impl_.object_;
}
const ::vse_clause&
vse_clause::_Internal::clause(const vse_clause* msg) {
  return *msg->_impl_.clause_;
}
vse_clause::vse_clause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vse_clause)
}
vse_clause::vse_clause(const vse_clause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  vse_clause* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.verb_){}
    , decltype(_impl_.subject_){nullptr}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.clause_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.verb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verb()) {
    _this->_impl_.verb_.Set(from._internal_verb(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_subject()) {
    _this->_impl_.subject_ = new ::entity_message(*from._impl_.subject_);
  }
  if (from._internal_has_object()) {
    _this->_impl_.object_ = new ::entity_message(*from._impl_.object_);
  }
  if (from._internal_has_clause()) {
    _this->_impl_.clause_ = new ::vse_clause(*from._impl_.clause_);
  }
  // @@protoc_insertion_point(copy_constructor:vse_clause)
}

inline void vse_clause::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.verb_){}
    , decltype(_impl_.subject_){nullptr}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.clause_){nullptr}
  };
  _impl_.verb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

vse_clause::~vse_clause() {
  // @@protoc_insertion_point(destructor:vse_clause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vse_clause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.verb_.Destroy();
  if (this != internal_default_instance()) delete _impl_.subject_;
  if (this != internal_default_instance()) delete _impl_.object_;
  if (this != internal_default_instance()) delete _impl_.clause_;
}

void vse_clause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vse_clause::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.verb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.subject_ != nullptr);
      _impl_.subject_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.object_ != nullptr);
      _impl_.object_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.clause_ != nullptr);
      _impl_.clause_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .entity_message subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subject(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string verb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_verb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "vse_clause.verb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .entity_message object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause clause = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_clause(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .entity_message subject = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::subject(this),
        _Internal::subject(this).GetCachedSize(), target, stream);
  }

  // optional string verb = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_verb().data(), static_cast<int>(this->_internal_verb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_clause.verb");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_verb(), target);
  }

  // optional .entity_message object = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause clause = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::clause(this),
        _Internal::clause(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clause)
  return target;
}

size_t vse_clause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string verb = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_verb());
    }

    // optional .entity_message subject = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.subject_);
    }

    // optional .entity_message object = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_);
    }

    // optional .vse_clause clause = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.clause_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    vse_clause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clause::GetClassData() const { return &_class_data_; }


void vse_clause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<vse_clause*>(&to_msg);
  auto& from = static_cast<const vse_clause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vse_clause)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_verb(from._internal_verb());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_subject()->::entity_message::MergeFrom(
          from._internal_subject());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_object()->::entity_message::MergeFrom(
          from._internal_object());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_clause()->::vse_clause::MergeFrom(
          from._internal_clause());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clause::CopyFrom(const vse_clause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clause::IsInitialized() const {
  return true;
}

void vse_clause::InternalSwap(vse_clause* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verb_, lhs_arena,
      &other->_impl_.verb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(vse_clause, _impl_.clause_)
      + sizeof(vse_clause::_impl_.clause_)
      - PROTOBUF_FIELD_OFFSET(vse_clause, _impl_.subject_)>(
          reinterpret_cast<char*>(&_impl_.subject_),
          reinterpret_cast<char*>(&other->_impl_.subject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[6]);
}

// ===================================================================

class vse_clauses::_Internal {
 public:
};

vse_clauses::vse_clauses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vse_clauses)
}
vse_clauses::vse_clauses(const vse_clauses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  vse_clauses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clauses_){from._impl_.clauses_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vse_clauses)
}

inline void vse_clauses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clauses_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

vse_clauses::~vse_clauses() {
  // @@protoc_insertion_point(destructor:vse_clauses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vse_clauses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clauses_.~RepeatedPtrField();
}

void vse_clauses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vse_clauses::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clauses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clauses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause clauses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clauses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clauses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_clauses_size()); i < n; i++) {
    const auto& repfield = this->_internal_clauses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clauses)
  return target;
}

size_t vse_clauses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clauses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  total_size += 1UL * this->_internal_clauses_size();
  for (const auto& msg : this->_impl_.clauses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clauses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    vse_clauses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clauses::GetClassData() const { return &_class_data_; }


void vse_clauses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<vse_clauses*>(&to_msg);
  auto& from = static_cast<const vse_clauses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vse_clauses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.clauses_.MergeFrom(from._impl_.clauses_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clauses::CopyFrom(const vse_clauses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clauses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clauses::IsInitialized() const {
  return true;
}

void vse_clauses::InternalSwap(vse_clauses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.clauses_.InternalSwap(&other->_impl_.clauses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clauses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[7]);
}

// ===================================================================

class attestation::_Internal {
 public:
  using HasBits = decltype(std::declval<attestation>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(attestation, _impl_._has_bits_);
  static void set_has_enclave_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::vse_clause& clause(const attestation* msg);
  static void set_has_clause(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::vse_clause&
attestation::_Internal::clause(const attestation* msg) {
  return *msg->_impl_.clause_;
}
attestation::attestation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:attestation)
}
attestation::attestation(const attestation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  attestation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enclave_type_){}
    , decltype(_impl_.key_id_){}
    , decltype(_impl_.measurement_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.clause_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.enclave_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enclave_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enclave_type()) {
    _this->_impl_.enclave_type_.Set(from._internal_enclave_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_id()) {
    _this->_impl_.key_id_.Set(from._internal_key_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_measurement()) {
    _this->_impl_.measurement_.Set(from._internal_measurement(), 
      _this->GetArenaForAllocation());
  }
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_time()) {
    _this->_impl_.time_.Set(from._internal_time(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_clause()) {
    _this->_impl_.clause_ = new ::vse_clause(*from._impl_.clause_);
  }
  // @@protoc_insertion_point(copy_constructor:attestation)
}

inline void attestation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enclave_type_){}
    , decltype(_impl_.key_id_){}
    , decltype(_impl_.measurement_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.clause_){nullptr}
  };
  _impl_.enclave_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enclave_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

attestation::~attestation() {
  // @@protoc_insertion_point(destructor:attestation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void attestation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enclave_type_.Destroy();
  _impl_.key_id_.Destroy();
  _impl_.measurement_.Destroy();
  _impl_.time_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.clause_;
}

void attestation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void attestation::Clear() {
// @@protoc_insertion_point(message_clear_start:attestation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enclave_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.key_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.clause_ != nullptr);
      _impl_.clause_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* attestation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string enclave_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enclave_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation.enclave_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string key_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation.key_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes measurement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_measurement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation.time");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause clause = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_clause(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* attestation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:attestation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string enclave_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_enclave_type().data(), static_cast<int>(this->_internal_enclave_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.enclave_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_enclave_type(), target);
  }

  // optional string key_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.key_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key_id(), target);
  }

  // optional bytes measurement = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_measurement(), target);
  }

  // optional string time = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_time().data(), static_cast<int>(this->_internal_time().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.time");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_time(), target);
  }

  // optional .vse_clause clause = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::clause(this),
        _Internal::clause(this).GetCachedSize(), target, stream);
  }

  // optional string description = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation.description");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:attestation)
  return target;
}

size_t attestation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:attestation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string enclave_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_enclave_type());
    }

    // optional string key_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_id());
    }

    // optional bytes measurement = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_measurement());
    }

    // optional string time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time());
    }

    // optional string description = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional .vse_clause clause = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.clause_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData attestation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    attestation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*attestation::GetClassData() const { return &_class_data_; }


void attestation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<attestation*>(&to_msg);
  auto& from = static_cast<const attestation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:attestation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_enclave_type(from._internal_enclave_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_key_id(from._internal_key_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_measurement(from._internal_measurement());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_time(from._internal_time());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_clause()->::vse_clause::MergeFrom(
          from._internal_clause());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void attestation::CopyFrom(const attestation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:attestation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attestation::IsInitialized() const {
  return true;
}

void attestation::InternalSwap(attestation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.enclave_type_, lhs_arena,
      &other->_impl_.enclave_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_id_, lhs_arena,
      &other->_impl_.key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.measurement_, lhs_arena,
      &other->_impl_.measurement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_, lhs_arena,
      &other->_impl_.time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.clause_, other->_impl_.clause_);
}

::PROTOBUF_NAMESPACE_ID::Metadata attestation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[8]);
}

// ===================================================================

class claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<claim_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(claim_message, _impl_._has_bits_);
  static void set_has_claim_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_claim_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_serialized_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

claim_message::claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:claim_message)
}
claim_message::claim_message(const claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  claim_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_format_){}
    , decltype(_impl_.claim_descriptor_){}
    , decltype(_impl_.not_before_){}
    , decltype(_impl_.not_after_){}
    , decltype(_impl_.serialized_claim_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.claim_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claim_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_format()) {
    _this->_impl_.claim_format_.Set(from._internal_claim_format(), 
      _this->GetArenaForAllocation());
  }
  _impl_.claim_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claim_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_descriptor()) {
    _this->_impl_.claim_descriptor_.Set(from._internal_claim_descriptor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    _this->_impl_.not_before_.Set(from._internal_not_before(), 
      _this->GetArenaForAllocation());
  }
  _impl_.not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    _this->_impl_.not_after_.Set(from._internal_not_after(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serialized_claim_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_claim_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim()) {
    _this->_impl_.serialized_claim_.Set(from._internal_serialized_claim(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:claim_message)
}

inline void claim_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_format_){}
    , decltype(_impl_.claim_descriptor_){}
    , decltype(_impl_.not_before_){}
    , decltype(_impl_.not_after_){}
    , decltype(_impl_.serialized_claim_){}
  };
  _impl_.claim_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claim_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.claim_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claim_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_claim_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_claim_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

claim_message::~claim_message() {
  // @@protoc_insertion_point(destructor:claim_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.claim_format_.Destroy();
  _impl_.claim_descriptor_.Destroy();
  _impl_.not_before_.Destroy();
  _impl_.not_after_.Destroy();
  _impl_.serialized_claim_.Destroy();
}

void claim_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.claim_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.claim_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.not_after_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.serialized_claim_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claim_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string claim_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_claim_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.claim_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string claim_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_claim_descriptor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.claim_descriptor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_not_before();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.not_before");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_not_after();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.not_after");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_claim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serialized_claim();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string claim_format = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_format().data(), static_cast<int>(this->_internal_claim_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_format");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_claim_format(), target);
  }

  // optional string claim_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_descriptor().data(), static_cast<int>(this->_internal_claim_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_claim_descriptor(), target);
  }

  // optional string not_before = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_before");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_not_before(), target);
  }

  // optional string not_after = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_after");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_not_after(), target);
  }

  // optional bytes serialized_claim = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_serialized_claim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claim_message)
  return target;
}

size_t claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string claim_format = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_format());
    }

    // optional string claim_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_descriptor());
    }

    // optional string not_before = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

    // optional bytes serialized_claim = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claim_message::GetClassData() const { return &_class_data_; }


void claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<claim_message*>(&to_msg);
  auto& from = static_cast<const claim_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:claim_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_claim_format(from._internal_claim_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_claim_descriptor(from._internal_claim_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_not_after(from._internal_not_after());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_serialized_claim(from._internal_serialized_claim());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claim_message::CopyFrom(const claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claim_message::IsInitialized() const {
  return true;
}

void claim_message::InternalSwap(claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.claim_format_, lhs_arena,
      &other->_impl_.claim_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.claim_descriptor_, lhs_arena,
      &other->_impl_.claim_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.not_before_, lhs_arena,
      &other->_impl_.not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.not_after_, lhs_arena,
      &other->_impl_.not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_claim_, lhs_arena,
      &other->_impl_.serialized_claim_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata claim_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[9]);
}

// ===================================================================

class signed_claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<signed_claim_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(signed_claim_message, _impl_._has_bits_);
  static void set_has_serialized_claim_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& signing_key(const signed_claim_message* msg);
  static void set_has_signing_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::key_message&
signed_claim_message::_Internal::signing_key(const signed_claim_message* msg) {
  return *msg->_impl_.signing_key_;
}
signed_claim_message::signed_claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:signed_claim_message)
}
signed_claim_message::signed_claim_message(const signed_claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  signed_claim_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialized_claim_message_){}
    , decltype(_impl_.signing_algorithm_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.signing_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.serialized_claim_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_claim_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim_message()) {
    _this->_impl_.serialized_claim_message_.Set(from._internal_serialized_claim_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signing_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signing_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signing_algorithm()) {
    _this->_impl_.signing_algorithm_.Set(from._internal_signing_algorithm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_signing_key()) {
    _this->_impl_.signing_key_ = new ::key_message(*from._impl_.signing_key_);
  }
  // @@protoc_insertion_point(copy_constructor:signed_claim_message)
}

inline void signed_claim_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialized_claim_message_){}
    , decltype(_impl_.signing_algorithm_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.signing_key_){nullptr}
  };
  _impl_.serialized_claim_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_claim_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signing_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signing_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

signed_claim_message::~signed_claim_message() {
  // @@protoc_insertion_point(destructor:signed_claim_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void signed_claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serialized_claim_message_.Destroy();
  _impl_.signing_algorithm_.Destroy();
  _impl_.signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.signing_key_;
}

void signed_claim_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void signed_claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.serialized_claim_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signing_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.signing_key_ != nullptr);
      _impl_.signing_key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes serialized_claim_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialized_claim_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message signing_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signing_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signing_algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signing_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "signed_claim_message.signing_algorithm");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes serialized_claim_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serialized_claim_message(), target);
  }

  // optional .key_message signing_key = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signing_key(this),
        _Internal::signing_key(this).GetCachedSize(), target, stream);
  }

  // optional string signing_algorithm = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signing_algorithm().data(), static_cast<int>(this->_internal_signing_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "signed_claim_message.signing_algorithm");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_signing_algorithm(), target);
  }

  // optional bytes signature = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_message)
  return target;
}

size_t signed_claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes serialized_claim_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim_message());
    }

    // optional string signing_algorithm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signing_algorithm());
    }

    // optional bytes signature = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .key_message signing_key = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signing_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    signed_claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_message::GetClassData() const { return &_class_data_; }


void signed_claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<signed_claim_message*>(&to_msg);
  auto& from = static_cast<const signed_claim_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_serialized_claim_message(from._internal_serialized_claim_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signing_algorithm(from._internal_signing_algorithm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_signing_key()->::key_message::MergeFrom(
          from._internal_signing_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_message::CopyFrom(const signed_claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_message::IsInitialized() const {
  return true;
}

void signed_claim_message::InternalSwap(signed_claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_claim_message_, lhs_arena,
      &other->_impl_.serialized_claim_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signing_algorithm_, lhs_arena,
      &other->_impl_.signing_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.signing_key_, other->_impl_.signing_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[10]);
}

// ===================================================================

class oe_assertion::_Internal {
 public:
  using HasBits = decltype(std::declval<oe_assertion>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(oe_assertion, _impl_._has_bits_);
  static void set_has_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_oe_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

oe_assertion::oe_assertion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:oe_assertion)
}
oe_assertion::oe_assertion(const oe_assertion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  oe_assertion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){}
    , decltype(_impl_.oe_report_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_data()) {
    _this->_impl_.user_data_.Set(from._internal_user_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.oe_report_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oe_report_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oe_report()) {
    _this->_impl_.oe_report_.Set(from._internal_oe_report(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:oe_assertion)
}

inline void oe_assertion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){}
    , decltype(_impl_.oe_report_){}
  };
  _impl_.user_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oe_report_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oe_report_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

oe_assertion::~oe_assertion() {
  // @@protoc_insertion_point(destructor:oe_assertion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void oe_assertion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_data_.Destroy();
  _impl_.oe_report_.Destroy();
}

void oe_assertion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void oe_assertion::Clear() {
// @@protoc_insertion_point(message_clear_start:oe_assertion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.oe_report_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* oe_assertion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes user_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes oe_report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oe_report();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* oe_assertion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:oe_assertion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes user_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_user_data(), target);
  }

  // optional bytes oe_report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_oe_report(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:oe_assertion)
  return target;
}

size_t oe_assertion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:oe_assertion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes user_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_data());
    }

    // optional bytes oe_report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_oe_report());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData oe_assertion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    oe_assertion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*oe_assertion::GetClassData() const { return &_class_data_; }


void oe_assertion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<oe_assertion*>(&to_msg);
  auto& from = static_cast<const oe_assertion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:oe_assertion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_user_data(from._internal_user_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_oe_report(from._internal_oe_report());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void oe_assertion::CopyFrom(const oe_assertion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:oe_assertion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool oe_assertion::IsInitialized() const {
  return true;
}

void oe_assertion::InternalSwap(oe_assertion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_data_, lhs_arena,
      &other->_impl_.user_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.oe_report_, lhs_arena,
      &other->_impl_.oe_report_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata oe_assertion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[11]);
}

// ===================================================================

class evidence::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(evidence, _impl_._has_bits_);
  static void set_has_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serialized_evidence(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

evidence::evidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:evidence)
}
evidence::evidence(const evidence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  evidence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.evidence_type_){}
    , decltype(_impl_.serialized_evidence_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_evidence_type()) {
    _this->_impl_.evidence_type_.Set(from._internal_evidence_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serialized_evidence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_evidence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_evidence()) {
    _this->_impl_.serialized_evidence_.Set(from._internal_serialized_evidence(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence)
}

inline void evidence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.evidence_type_){}
    , decltype(_impl_.serialized_evidence_){}
  };
  _impl_.evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_evidence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_evidence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence::~evidence() {
  // @@protoc_insertion_point(destructor:evidence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void evidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.evidence_type_.Destroy();
  _impl_.serialized_evidence_.Destroy();
}

void evidence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void evidence::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.serialized_evidence_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string evidence_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_evidence_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "evidence.evidence_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_evidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serialized_evidence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string evidence_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_evidence_type().data(), static_cast<int>(this->_internal_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence.evidence_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_evidence_type(), target);
  }

  // optional bytes serialized_evidence = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_serialized_evidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence)
  return target;
}

size_t evidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string evidence_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_evidence_type());
    }

    // optional bytes serialized_evidence = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_evidence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    evidence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence::GetClassData() const { return &_class_data_; }


void evidence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<evidence*>(&to_msg);
  auto& from = static_cast<const evidence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:evidence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_evidence_type(from._internal_evidence_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_serialized_evidence(from._internal_serialized_evidence());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence::CopyFrom(const evidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence::IsInitialized() const {
  return true;
}

void evidence::InternalSwap(evidence* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.evidence_type_, lhs_arena,
      &other->_impl_.evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_evidence_, lhs_arena,
      &other->_impl_.serialized_evidence_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[12]);
}

// ===================================================================

class evidence_package::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence_package>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(evidence_package, _impl_._has_bits_);
  static void set_has_prover_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

evidence_package::evidence_package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:evidence_package)
}
evidence_package::evidence_package(const evidence_package& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  evidence_package* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fact_assertion_){from._impl_.fact_assertion_}
    , decltype(_impl_.prover_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prover_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prover_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prover_type()) {
    _this->_impl_.prover_type_.Set(from._internal_prover_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence_package)
}

inline void evidence_package::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fact_assertion_){arena}
    , decltype(_impl_.prover_type_){}
  };
  _impl_.prover_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prover_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence_package::~evidence_package() {
  // @@protoc_insertion_point(destructor:evidence_package)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void evidence_package::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fact_assertion_.~RepeatedPtrField();
  _impl_.prover_type_.Destroy();
}

void evidence_package::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void evidence_package::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence_package)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fact_assertion_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.prover_type_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence_package::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prover_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prover_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "evidence_package.prover_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .evidence fact_assertion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fact_assertion(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence_package::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence_package)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string prover_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prover_type().data(), static_cast<int>(this->_internal_prover_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence_package.prover_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prover_type(), target);
  }

  // repeated .evidence fact_assertion = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fact_assertion_size()); i < n; i++) {
    const auto& repfield = this->_internal_fact_assertion(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence_package)
  return target;
}

size_t evidence_package::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence_package)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .evidence fact_assertion = 2;
  total_size += 1UL * this->_internal_fact_assertion_size();
  for (const auto& msg : this->_impl_.fact_assertion_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string prover_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prover_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence_package::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    evidence_package::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence_package::GetClassData() const { return &_class_data_; }


void evidence_package::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<evidence_package*>(&to_msg);
  auto& from = static_cast<const evidence_package&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:evidence_package)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fact_assertion_.MergeFrom(from._impl_.fact_assertion_);
  if (from._internal_has_prover_type()) {
    _this->_internal_set_prover_type(from._internal_prover_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence_package::CopyFrom(const evidence_package& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence_package)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence_package::IsInitialized() const {
  return true;
}

void evidence_package::InternalSwap(evidence_package* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.fact_assertion_.InternalSwap(&other->_impl_.fact_assertion_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prover_type_, lhs_arena,
      &other->_impl_.prover_type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence_package::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[13]);
}

// ===================================================================

class certifier_rules::_Internal {
 public:
};

certifier_rules::certifier_rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:certifier_rules)
}
certifier_rules::certifier_rules(const certifier_rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  certifier_rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rule_){from._impl_.rule_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:certifier_rules)
}

inline void certifier_rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rule_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

certifier_rules::~certifier_rules() {
  // @@protoc_insertion_point(destructor:certifier_rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void certifier_rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_.~RepeatedPtrField();
}

void certifier_rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void certifier_rules::Clear() {
// @@protoc_insertion_point(message_clear_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rule_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* certifier_rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string rule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rule();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "certifier_rules.rule");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* certifier_rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string rule = 1;
  for (int i = 0, n = this->_internal_rule_size(); i < n; i++) {
    const auto& s = this->_internal_rule(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "certifier_rules.rule");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:certifier_rules)
  return target;
}

size_t certifier_rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:certifier_rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string rule = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.rule_.size());
  for (int i = 0, n = _impl_.rule_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.rule_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData certifier_rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    certifier_rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*certifier_rules::GetClassData() const { return &_class_data_; }


void certifier_rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<certifier_rules*>(&to_msg);
  auto& from = static_cast<const certifier_rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:certifier_rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rule_.MergeFrom(from._impl_.rule_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void certifier_rules::CopyFrom(const certifier_rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:certifier_rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool certifier_rules::IsInitialized() const {
  return true;
}

void certifier_rules::InternalSwap(certifier_rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.rule_.InternalSwap(&other->_impl_.rule_);
}

::PROTOBUF_NAMESPACE_ID::Metadata certifier_rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[14]);
}

// ===================================================================

class proved_statements::_Internal {
 public:
};

proved_statements::proved_statements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proved_statements)
}
proved_statements::proved_statements(const proved_statements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  proved_statements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proved_){from._impl_.proved_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proved_statements)
}

inline void proved_statements::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proved_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

proved_statements::~proved_statements() {
  // @@protoc_insertion_point(destructor:proved_statements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proved_statements::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proved_.~RepeatedPtrField();
}

void proved_statements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void proved_statements::Clear() {
// @@protoc_insertion_point(message_clear_start:proved_statements)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proved_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proved_statements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause proved = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proved_statements::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proved_statements)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proved_size()); i < n; i++) {
    const auto& repfield = this->_internal_proved(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proved_statements)
  return target;
}

size_t proved_statements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proved_statements)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  total_size += 1UL * this->_internal_proved_size();
  for (const auto& msg : this->_impl_.proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proved_statements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    proved_statements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proved_statements::GetClassData() const { return &_class_data_; }


void proved_statements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<proved_statements*>(&to_msg);
  auto& from = static_cast<const proved_statements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proved_statements)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proved_.MergeFrom(from._impl_.proved_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proved_statements::CopyFrom(const proved_statements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proved_statements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proved_statements::IsInitialized() const {
  return true;
}

void proved_statements::InternalSwap(proved_statements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.proved_.InternalSwap(&other->_impl_.proved_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proved_statements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[15]);
}

// ===================================================================

class proof_step::_Internal {
 public:
  using HasBits = decltype(std::declval<proof_step>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(proof_step, _impl_._has_bits_);
  static const ::vse_clause& s1(const proof_step* msg);
  static void set_has_s1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::vse_clause& s2(const proof_step* msg);
  static void set_has_s2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::vse_clause& conclusion(const proof_step* msg);
  static void set_has_conclusion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_applied(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::vse_clause&
proof_step::_Internal::s1(const proof_step* msg) {
  return *msg->_impl_.s1_;
}
const ::vse_clause&
proof_step::_Internal::s2(const proof_step* msg) {
  return *msg->_impl_.s2_;
}
const ::vse_clause&
proof_step::_Internal::conclusion(const proof_step* msg) {
  return *msg->_impl_.conclusion_;
}
proof_step::proof_step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proof_step)
}
proof_step::proof_step(const proof_step& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  proof_step* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s1_){nullptr}
    , decltype(_impl_.s2_){nullptr}
    , decltype(_impl_.conclusion_){nullptr}
    , decltype(_impl_.rule_applied_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_s1()) {
    _this->_impl_.s1_ = new ::vse_clause(*from._impl_.s1_);
  }
  if (from._internal_has_s2()) {
    _this->_impl_.s2_ = new ::vse_clause(*from._impl_.s2_);
  }
  if (from._internal_has_conclusion()) {
    _this->_impl_.conclusion_ = new ::vse_clause(*from._impl_.conclusion_);
  }
  _this->_impl_.rule_applied_ = from._impl_.rule_applied_;
  // @@protoc_insertion_point(copy_constructor:proof_step)
}

inline void proof_step::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s1_){nullptr}
    , decltype(_impl_.s2_){nullptr}
    , decltype(_impl_.conclusion_){nullptr}
    , decltype(_impl_.rule_applied_){0}
  };
}

proof_step::~proof_step() {
  // @@protoc_insertion_point(destructor:proof_step)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proof_step::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.s1_;
  if (this != internal_default_instance()) delete _impl_.s2_;
  if (this != internal_default_instance()) delete _impl_.conclusion_;
}

void proof_step::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void proof_step::Clear() {
// @@protoc_insertion_point(message_clear_start:proof_step)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.s1_ != nullptr);
      _impl_.s1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.s2_ != nullptr);
      _impl_.s2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.conclusion_ != nullptr);
      _impl_.conclusion_->Clear();
    }
  }
  _impl_.rule_applied_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof_step::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause s1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_s1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause s2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_s2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause conclusion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conclusion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rule_applied = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_applied(&has_bits);
          _impl_.rule_applied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof_step::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof_step)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .vse_clause s1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::s1(this),
        _Internal::s1(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause s2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::s2(this),
        _Internal::s2(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause conclusion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::conclusion(this),
        _Internal::conclusion(this).GetCachedSize(), target, stream);
  }

  // optional int32 rule_applied = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_rule_applied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof_step)
  return target;
}

size_t proof_step::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof_step)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .vse_clause s1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.s1_);
    }

    // optional .vse_clause s2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.s2_);
    }

    // optional .vse_clause conclusion = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conclusion_);
    }

    // optional int32 rule_applied = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rule_applied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof_step::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    proof_step::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof_step::GetClassData() const { return &_class_data_; }


void proof_step::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<proof_step*>(&to_msg);
  auto& from = static_cast<const proof_step&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proof_step)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_s1()->::vse_clause::MergeFrom(
          from._internal_s1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_s2()->::vse_clause::MergeFrom(
          from._internal_s2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_conclusion()->::vse_clause::MergeFrom(
          from._internal_conclusion());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rule_applied_ = from._impl_.rule_applied_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof_step::CopyFrom(const proof_step& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof_step)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof_step::IsInitialized() const {
  return true;
}

void proof_step::InternalSwap(proof_step* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(proof_step, _impl_.rule_applied_)
      + sizeof(proof_step::_impl_.rule_applied_)
      - PROTOBUF_FIELD_OFFSET(proof_step, _impl_.s1_)>(
          reinterpret_cast<char*>(&_impl_.s1_),
          reinterpret_cast<char*>(&other->_impl_.s1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata proof_step::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[16]);
}

// ===================================================================

class proof::_Internal {
 public:
  using HasBits = decltype(std::declval<proof>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(proof, _impl_._has_bits_);
  static const ::vse_clause& to_prove(const proof* msg);
  static void set_has_to_prove(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::vse_clause&
proof::_Internal::to_prove(const proof* msg) {
  return *msg->_impl_.to_prove_;
}
proof::proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proof)
}
proof::proof(const proof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  proof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.already_proved_){from._impl_.already_proved_}
    , decltype(_impl_.steps_){from._impl_.steps_}
    , decltype(_impl_.to_prove_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_to_prove()) {
    _this->_impl_.to_prove_ = new ::vse_clause(*from._impl_.to_prove_);
  }
  // @@protoc_insertion_point(copy_constructor:proof)
}

inline void proof::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.already_proved_){arena}
    , decltype(_impl_.steps_){arena}
    , decltype(_impl_.to_prove_){nullptr}
  };
}

proof::~proof() {
  // @@protoc_insertion_point(destructor:proof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.already_proved_.~RepeatedPtrField();
  _impl_.steps_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.to_prove_;
}

void proof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void proof::Clear() {
// @@protoc_insertion_point(message_clear_start:proof)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.already_proved_.Clear();
  _impl_.steps_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.to_prove_ != nullptr);
    _impl_.to_prove_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause to_prove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_prove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vse_clause already_proved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_already_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proof_step steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_steps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .vse_clause to_prove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::to_prove(this),
        _Internal::to_prove(this).GetCachedSize(), target, stream);
  }

  // repeated .vse_clause already_proved = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_already_proved_size()); i < n; i++) {
    const auto& repfield = this->_internal_already_proved(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .proof_step steps = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_steps_size()); i < n; i++) {
    const auto& repfield = this->_internal_steps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof)
  return target;
}

size_t proof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause already_proved = 2;
  total_size += 1UL * this->_internal_already_proved_size();
  for (const auto& msg : this->_impl_.already_proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .proof_step steps = 3;
  total_size += 1UL * this->_internal_steps_size();
  for (const auto& msg : this->_impl_.steps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .vse_clause to_prove = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_prove_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    proof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof::GetClassData() const { return &_class_data_; }


void proof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<proof*>(&to_msg);
  auto& from = static_cast<const proof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proof)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.already_proved_.MergeFrom(from._impl_.already_proved_);
  _this->_impl_.steps_.MergeFrom(from._impl_.steps_);
  if (from._internal_has_to_prove()) {
    _this->_internal_mutable_to_prove()->::vse_clause::MergeFrom(
        from._internal_to_prove());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof::CopyFrom(const proof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof::IsInitialized() const {
  return true;
}

void proof::InternalSwap(proof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.already_proved_.InternalSwap(&other->_impl_.already_proved_);
  _impl_.steps_.InternalSwap(&other->_impl_.steps_);
  swap(_impl_.to_prove_, other->_impl_.to_prove_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[17]);
}

// ===================================================================

class trust_request_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_request_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(trust_request_message, _impl_._has_bits_);
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_submitted_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_purpose(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::evidence_package& support(const trust_request_message* msg);
  static void set_has_support(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::evidence_package&
trust_request_message::_Internal::support(const trust_request_message* msg) {
  return *msg->_impl_.support_;
}
trust_request_message::trust_request_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:trust_request_message)
}
trust_request_message::trust_request_message(const trust_request_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  trust_request_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requesting_enclave_tag_){}
    , decltype(_impl_.providing_enclave_tag_){}
    , decltype(_impl_.submitted_evidence_type_){}
    , decltype(_impl_.purpose_){}
    , decltype(_impl_.support_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    _this->_impl_.requesting_enclave_tag_.Set(from._internal_requesting_enclave_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    _this->_impl_.providing_enclave_tag_.Set(from._internal_providing_enclave_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.submitted_evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.submitted_evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_submitted_evidence_type()) {
    _this->_impl_.submitted_evidence_type_.Set(from._internal_submitted_evidence_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.purpose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.purpose_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_purpose()) {
    _this->_impl_.purpose_.Set(from._internal_purpose(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_support()) {
    _this->_impl_.support_ = new ::evidence_package(*from._impl_.support_);
  }
  // @@protoc_insertion_point(copy_constructor:trust_request_message)
}

inline void trust_request_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requesting_enclave_tag_){}
    , decltype(_impl_.providing_enclave_tag_){}
    , decltype(_impl_.submitted_evidence_type_){}
    , decltype(_impl_.purpose_){}
    , decltype(_impl_.support_){nullptr}
  };
  _impl_.requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.submitted_evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.submitted_evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.purpose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.purpose_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

trust_request_message::~trust_request_message() {
  // @@protoc_insertion_point(destructor:trust_request_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trust_request_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requesting_enclave_tag_.Destroy();
  _impl_.providing_enclave_tag_.Destroy();
  _impl_.submitted_evidence_type_.Destroy();
  _impl_.purpose_.Destroy();
  if (this != internal_default_instance()) delete _impl_.support_;
}

void trust_request_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void trust_request_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.submitted_evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.purpose_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.support_ != nullptr);
      _impl_.support_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_request_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string requesting_enclave_tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.requesting_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.providing_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string submitted_evidence_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_submitted_evidence_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.submitted_evidence_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string purpose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_purpose();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.purpose");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .evidence_package support = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_request_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string requesting_enclave_tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_providing_enclave_tag(), target);
  }

  // optional string submitted_evidence_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_submitted_evidence_type().data(), static_cast<int>(this->_internal_submitted_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.submitted_evidence_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_submitted_evidence_type(), target);
  }

  // optional string purpose = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_purpose().data(), static_cast<int>(this->_internal_purpose().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.purpose");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_purpose(), target);
  }

  // optional .evidence_package support = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::support(this),
        _Internal::support(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_request_message)
  return target;
}

size_t trust_request_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_request_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string requesting_enclave_tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional string submitted_evidence_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_submitted_evidence_type());
    }

    // optional string purpose = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_purpose());
    }

    // optional .evidence_package support = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.support_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_request_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    trust_request_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_request_message::GetClassData() const { return &_class_data_; }


void trust_request_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<trust_request_message*>(&to_msg);
  auto& from = static_cast<const trust_request_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trust_request_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_submitted_evidence_type(from._internal_submitted_evidence_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_purpose(from._internal_purpose());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_support()->::evidence_package::MergeFrom(
          from._internal_support());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_request_message::CopyFrom(const trust_request_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_request_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_request_message::IsInitialized() const {
  return true;
}

void trust_request_message::InternalSwap(trust_request_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.requesting_enclave_tag_, lhs_arena,
      &other->_impl_.requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.providing_enclave_tag_, lhs_arena,
      &other->_impl_.providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.submitted_evidence_type_, lhs_arena,
      &other->_impl_.submitted_evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.purpose_, lhs_arena,
      &other->_impl_.purpose_, rhs_arena
  );
  swap(_impl_.support_, other->_impl_.support_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_request_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[18]);
}

// ===================================================================

class trust_response_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_response_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(trust_response_message, _impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_artifact(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

trust_response_message::trust_response_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:trust_response_message)
}
trust_response_message::trust_response_message(const trust_response_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  trust_response_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.requesting_enclave_tag_){}
    , decltype(_impl_.providing_enclave_tag_){}
    , decltype(_impl_.artifact_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    _this->_impl_.requesting_enclave_tag_.Set(from._internal_requesting_enclave_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    _this->_impl_.providing_enclave_tag_.Set(from._internal_providing_enclave_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.artifact_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artifact_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artifact()) {
    _this->_impl_.artifact_.Set(from._internal_artifact(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:trust_response_message)
}

inline void trust_response_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.requesting_enclave_tag_){}
    , decltype(_impl_.providing_enclave_tag_){}
    , decltype(_impl_.artifact_){}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.artifact_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artifact_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

trust_response_message::~trust_response_message() {
  // @@protoc_insertion_point(destructor:trust_response_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trust_response_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
  _impl_.requesting_enclave_tag_.Destroy();
  _impl_.providing_enclave_tag_.Destroy();
  _impl_.artifact_.Destroy();
}

void trust_response_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void trust_response_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.artifact_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_response_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.requesting_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.providing_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes artifact = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_artifact();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_response_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  // optional string requesting_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_providing_enclave_tag(), target);
  }

  // optional bytes artifact = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_artifact(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_response_message)
  return target;
}

size_t trust_response_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_response_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string requesting_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional bytes artifact = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_artifact());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_response_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    trust_response_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_response_message::GetClassData() const { return &_class_data_; }


void trust_response_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<trust_response_message*>(&to_msg);
  auto& from = static_cast<const trust_response_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trust_response_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_artifact(from._internal_artifact());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_response_message::CopyFrom(const trust_response_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_response_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_response_message::IsInitialized() const {
  return true;
}

void trust_response_message::InternalSwap(trust_response_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.requesting_enclave_tag_, lhs_arena,
      &other->_impl_.requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.providing_enclave_tag_, lhs_arena,
      &other->_impl_.providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.artifact_, lhs_arena,
      &other->_impl_.artifact_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_response_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[19]);
}

// ===================================================================

class storage_info_message::_Internal {
 public:
  using HasBits = decltype(std::declval<storage_info_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(storage_info_message, _impl_._has_bits_);
  static void set_has_storage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storage_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::key_message& storage_key(const storage_info_message* msg);
  static void set_has_storage_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::key_message&
storage_info_message::_Internal::storage_key(const storage_info_message* msg) {
  return *msg->_impl_.storage_key_;
}
storage_info_message::storage_info_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:storage_info_message)
}
storage_info_message::storage_info_message(const storage_info_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  storage_info_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_type_){}
    , decltype(_impl_.storage_descriptor_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.storage_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.storage_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_type()) {
    _this->_impl_.storage_type_.Set(from._internal_storage_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storage_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_descriptor()) {
    _this->_impl_.storage_descriptor_.Set(from._internal_storage_descriptor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_storage_key()) {
    _this->_impl_.storage_key_ = new ::key_message(*from._impl_.storage_key_);
  }
  // @@protoc_insertion_point(copy_constructor:storage_info_message)
}

inline void storage_info_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_type_){}
    , decltype(_impl_.storage_descriptor_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.storage_key_){nullptr}
  };
  _impl_.storage_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storage_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

storage_info_message::~storage_info_message() {
  // @@protoc_insertion_point(destructor:storage_info_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void storage_info_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.storage_type_.Destroy();
  _impl_.storage_descriptor_.Destroy();
  _impl_.address_.Destroy();
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.storage_key_;
}

void storage_info_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void storage_info_message::Clear() {
// @@protoc_insertion_point(message_clear_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.storage_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.storage_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.storage_key_ != nullptr);
      _impl_.storage_key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* storage_info_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string storage_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_storage_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.storage_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string storage_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_storage_descriptor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.storage_descriptor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message storage_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* storage_info_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string storage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_type().data(), static_cast<int>(this->_internal_storage_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_storage_type(), target);
  }

  // optional string storage_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_descriptor().data(), static_cast<int>(this->_internal_storage_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_storage_descriptor(), target);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_address(), target);
  }

  // optional .key_message storage_key = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::storage_key(this),
        _Internal::storage_key(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.tag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage_info_message)
  return target;
}

size_t storage_info_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage_info_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string storage_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_type());
    }

    // optional string storage_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_descriptor());
    }

    // optional string address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional string tag = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message storage_key = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData storage_info_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    storage_info_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*storage_info_message::GetClassData() const { return &_class_data_; }


void storage_info_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<storage_info_message*>(&to_msg);
  auto& from = static_cast<const storage_info_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:storage_info_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_storage_type(from._internal_storage_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_storage_descriptor(from._internal_storage_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_storage_key()->::key_message::MergeFrom(
          from._internal_storage_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void storage_info_message::CopyFrom(const storage_info_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage_info_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool storage_info_message::IsInitialized() const {
  return true;
}

void storage_info_message::InternalSwap(storage_info_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storage_type_, lhs_arena,
      &other->_impl_.storage_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storage_descriptor_, lhs_arena,
      &other->_impl_.storage_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.storage_key_, other->_impl_.storage_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata storage_info_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[20]);
}

// ===================================================================

class channel_key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<channel_key_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(channel_key_message, _impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& auth_key(const channel_key_message* msg);
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
channel_key_message::_Internal::auth_key(const channel_key_message* msg) {
  return *msg->_impl_.auth_key_;
}
channel_key_message::channel_key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:channel_key_message)
}
channel_key_message::channel_key_message(const channel_key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  channel_key_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.auth_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_auth_key()) {
    _this->_impl_.auth_key_ = new ::key_message(*from._impl_.auth_key_);
  }
  // @@protoc_insertion_point(copy_constructor:channel_key_message)
}

inline void channel_key_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.auth_key_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

channel_key_message::~channel_key_message() {
  // @@protoc_insertion_point(destructor:channel_key_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void channel_key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.auth_key_;
}

void channel_key_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void channel_key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.auth_key_ != nullptr);
      _impl_.auth_key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* channel_key_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "channel_key_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message auth_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* channel_key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "channel_key_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .key_message auth_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::auth_key(this),
        _Internal::auth_key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:channel_key_message)
  return target;
}

size_t channel_key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:channel_key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message auth_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auth_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData channel_key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    channel_key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*channel_key_message::GetClassData() const { return &_class_data_; }


void channel_key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<channel_key_message*>(&to_msg);
  auto& from = static_cast<const channel_key_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:channel_key_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_auth_key()->::key_message::MergeFrom(
          from._internal_auth_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void channel_key_message::CopyFrom(const channel_key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:channel_key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool channel_key_message::IsInitialized() const {
  return true;
}

void channel_key_message::InternalSwap(channel_key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.auth_key_, other->_impl_.auth_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata channel_key_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[21]);
}

// ===================================================================

class trusted_service_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trusted_service_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(trusted_service_message, _impl_._has_bits_);
  static void set_has_trusted_service_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& trusted_service_key(const trusted_service_message* msg);
  static void set_has_trusted_service_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
trusted_service_message::_Internal::trusted_service_key(const trusted_service_message* msg) {
  return *msg->_impl_.trusted_service_key_;
}
trusted_service_message::trusted_service_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:trusted_service_message)
}
trusted_service_message::trusted_service_message(const trusted_service_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  trusted_service_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trusted_service_address_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.trusted_service_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.trusted_service_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trusted_service_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trusted_service_address()) {
    _this->_impl_.trusted_service_address_.Set(from._internal_trusted_service_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_trusted_service_key()) {
    _this->_impl_.trusted_service_key_ = new ::key_message(*from._impl_.trusted_service_key_);
  }
  // @@protoc_insertion_point(copy_constructor:trusted_service_message)
}

inline void trusted_service_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trusted_service_address_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.trusted_service_key_){nullptr}
  };
  _impl_.trusted_service_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trusted_service_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

trusted_service_message::~trusted_service_message() {
  // @@protoc_insertion_point(destructor:trusted_service_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trusted_service_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.trusted_service_address_.Destroy();
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trusted_service_key_;
}

void trusted_service_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void trusted_service_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.trusted_service_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.trusted_service_key_ != nullptr);
      _impl_.trusted_service_key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trusted_service_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trusted_service_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trusted_service_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trusted_service_message.trusted_service_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message trusted_service_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trusted_service_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trusted_service_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trusted_service_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string trusted_service_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_trusted_service_address().data(), static_cast<int>(this->_internal_trusted_service_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.trusted_service_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_trusted_service_address(), target);
  }

  // optional .key_message trusted_service_key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::trusted_service_key(this),
        _Internal::trusted_service_key(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trusted_service_message)
  return target;
}

size_t trusted_service_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trusted_service_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string trusted_service_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trusted_service_address());
    }

    // optional string tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message trusted_service_key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trusted_service_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trusted_service_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    trusted_service_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trusted_service_message::GetClassData() const { return &_class_data_; }


void trusted_service_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<trusted_service_message*>(&to_msg);
  auto& from = static_cast<const trusted_service_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trusted_service_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_trusted_service_address(from._internal_trusted_service_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_trusted_service_key()->::key_message::MergeFrom(
          from._internal_trusted_service_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trusted_service_message::CopyFrom(const trusted_service_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trusted_service_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trusted_service_message::IsInitialized() const {
  return true;
}

void trusted_service_message::InternalSwap(trusted_service_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.trusted_service_address_, lhs_arena,
      &other->_impl_.trusted_service_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.trusted_service_key_, other->_impl_.trusted_service_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trusted_service_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[22]);
}

// ===================================================================

class tagged_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_claim>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(tagged_claim, _impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::claim_message& claim(const tagged_claim* msg);
  static void set_has_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::claim_message&
tagged_claim::_Internal::claim(const tagged_claim* msg) {
  return *msg->_impl_.claim_;
}
tagged_claim::tagged_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tagged_claim)
}
tagged_claim::tagged_claim(const tagged_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  tagged_claim* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.claim_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_claim()) {
    _this->_impl_.claim_ = new ::claim_message(*from._impl_.claim_);
  }
  // @@protoc_insertion_point(copy_constructor:tagged_claim)
}

inline void tagged_claim::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.claim_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

tagged_claim::~tagged_claim() {
  // @@protoc_insertion_point(destructor:tagged_claim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.claim_;
}

void tagged_claim::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void tagged_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.claim_ != nullptr);
      _impl_.claim_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_claim.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .claim_message claim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_claim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .claim_message claim = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::claim(this),
        _Internal::claim(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claim)
  return target;
}

size_t tagged_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .claim_message claim = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.claim_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    tagged_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claim::GetClassData() const { return &_class_data_; }


void tagged_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<tagged_claim*>(&to_msg);
  auto& from = static_cast<const tagged_claim&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tagged_claim)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_claim()->::claim_message::MergeFrom(
          from._internal_claim());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claim::CopyFrom(const tagged_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claim::IsInitialized() const {
  return true;
}

void tagged_claim::InternalSwap(tagged_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.claim_, other->_impl_.claim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[23]);
}

// ===================================================================

class tagged_claims_sequence::_Internal {
 public:
};

tagged_claims_sequence::tagged_claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tagged_claims_sequence)
}
tagged_claims_sequence::tagged_claims_sequence(const tagged_claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  tagged_claims_sequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){from._impl_.claims_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tagged_claims_sequence)
}

inline void tagged_claims_sequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

tagged_claims_sequence::~tagged_claims_sequence() {
  // @@protoc_insertion_point(destructor:tagged_claims_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.claims_.~RepeatedPtrField();
}

void tagged_claims_sequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void tagged_claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claims_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tagged_claim claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claims_sequence)
  return target;
}

size_t tagged_claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->_impl_.claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    tagged_claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claims_sequence::GetClassData() const { return &_class_data_; }


void tagged_claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<tagged_claims_sequence*>(&to_msg);
  auto& from = static_cast<const tagged_claims_sequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tagged_claims_sequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.claims_.MergeFrom(from._impl_.claims_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claims_sequence::CopyFrom(const tagged_claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claims_sequence::IsInitialized() const {
  return true;
}

void tagged_claims_sequence::InternalSwap(tagged_claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.claims_.InternalSwap(&other->_impl_.claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claims_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[24]);
}

// ===================================================================

class policy_store_message::_Internal {
 public:
  using HasBits = decltype(std::declval<policy_store_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(policy_store_message, _impl_._has_bits_);
  static const ::key_message& policy_key(const policy_store_message* msg);
  static void set_has_policy_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::key_message&
policy_store_message::_Internal::policy_key(const policy_store_message* msg) {
  return *msg->_impl_.policy_key_;
}
policy_store_message::policy_store_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:policy_store_message)
}
policy_store_message::policy_store_message(const policy_store_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  policy_store_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trusted_services_){from._impl_.trusted_services_}
    , decltype(_impl_.channel_authentication_keys_){from._impl_.channel_authentication_keys_}
    , decltype(_impl_.claims_){from._impl_.claims_}
    , decltype(_impl_.storage_info_){from._impl_.storage_info_}
    , decltype(_impl_.signed_claims_){from._impl_.signed_claims_}
    , decltype(_impl_.blobs_){from._impl_.blobs_}
    , decltype(_impl_.policy_key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_policy_key()) {
    _this->_impl_.policy_key_ = new ::key_message(*from._impl_.policy_key_);
  }
  // @@protoc_insertion_point(copy_constructor:policy_store_message)
}

inline void policy_store_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trusted_services_){arena}
    , decltype(_impl_.channel_authentication_keys_){arena}
    , decltype(_impl_.claims_){arena}
    , decltype(_impl_.storage_info_){arena}
    , decltype(_impl_.signed_claims_){arena}
    , decltype(_impl_.blobs_){arena}
    , decltype(_impl_.policy_key_){nullptr}
  };
}

policy_store_message::~policy_store_message() {
  // @@protoc_insertion_point(destructor:policy_store_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void policy_store_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.trusted_services_.~RepeatedPtrField();
  _impl_.channel_authentication_keys_.~RepeatedPtrField();
  _impl_.claims_.~RepeatedPtrField();
  _impl_.storage_info_.~RepeatedPtrField();
  _impl_.signed_claims_.~RepeatedPtrField();
  _impl_.blobs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.policy_key_;
}

void policy_store_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void policy_store_message::Clear() {
// @@protoc_insertion_point(message_clear_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.trusted_services_.Clear();
  _impl_.channel_authentication_keys_.Clear();
  _impl_.claims_.Clear();
  _impl_.storage_info_.Clear();
  _impl_.signed_claims_.Clear();
  _impl_.blobs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.policy_key_ != nullptr);
    _impl_.policy_key_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* policy_store_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .key_message policy_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .trusted_service_message trusted_services = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trusted_services(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .channel_key_message channel_authentication_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channel_authentication_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_claim claims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .storage_info_message storage_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_storage_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_signed_claim signed_claims = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signed_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_blob_message blobs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* policy_store_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .key_message policy_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::policy_key(this),
        _Internal::policy_key(this).GetCachedSize(), target, stream);
  }

  // repeated .trusted_service_message trusted_services = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trusted_services_size()); i < n; i++) {
    const auto& repfield = this->_internal_trusted_services(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_channel_authentication_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_channel_authentication_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_claim claims = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .storage_info_message storage_info = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_storage_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_storage_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signed_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_signed_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_blob_message blobs = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blobs_size()); i < n; i++) {
    const auto& repfield = this->_internal_blobs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:policy_store_message)
  return target;
}

size_t policy_store_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:policy_store_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trusted_service_message trusted_services = 2;
  total_size += 1UL * this->_internal_trusted_services_size();
  for (const auto& msg : this->_impl_.trusted_services_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  total_size += 1UL * this->_internal_channel_authentication_keys_size();
  for (const auto& msg : this->_impl_.channel_authentication_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_claim claims = 4;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->_impl_.claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .storage_info_message storage_info = 5;
  total_size += 1UL * this->_internal_storage_info_size();
  for (const auto& msg : this->_impl_.storage_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  total_size += 1UL * this->_internal_signed_claims_size();
  for (const auto& msg : this->_impl_.signed_claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_blob_message blobs = 7;
  total_size += 1UL * this->_internal_blobs_size();
  for (const auto& msg : this->_impl_.blobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .key_message policy_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.policy_key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData policy_store_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    policy_store_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*policy_store_message::GetClassData() const { return &_class_data_; }


void policy_store_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<policy_store_message*>(&to_msg);
  auto& from = static_cast<const policy_store_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:policy_store_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.trusted_services_.MergeFrom(from._impl_.trusted_services_);
  _this->_impl_.channel_authentication_keys_.MergeFrom(from._impl_.channel_authentication_keys_);
  _this->_impl_.claims_.MergeFrom(from._impl_.claims_);
  _this->_impl_.storage_info_.MergeFrom(from._impl_.storage_info_);
  _this->_impl_.signed_claims_.MergeFrom(from._impl_.signed_claims_);
  _this->_impl_.blobs_.MergeFrom(from._impl_.blobs_);
  if (from._internal_has_policy_key()) {
    _this->_internal_mutable_policy_key()->::key_message::MergeFrom(
        from._internal_policy_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void policy_store_message::CopyFrom(const policy_store_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:policy_store_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool policy_store_message::IsInitialized() const {
  return true;
}

void policy_store_message::InternalSwap(policy_store_message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.trusted_services_.InternalSwap(&other->_impl_.trusted_services_);
  _impl_.channel_authentication_keys_.InternalSwap(&other->_impl_.channel_authentication_keys_);
  _impl_.claims_.InternalSwap(&other->_impl_.claims_);
  _impl_.storage_info_.InternalSwap(&other->_impl_.storage_info_);
  _impl_.signed_claims_.InternalSwap(&other->_impl_.signed_claims_);
  _impl_.blobs_.InternalSwap(&other->_impl_.blobs_);
  swap(_impl_.policy_key_, other->_impl_.policy_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata policy_store_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[25]);
}

// ===================================================================

class claims_sequence::_Internal {
 public:
};

claims_sequence::claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:claims_sequence)
}
claims_sequence::claims_sequence(const claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  claims_sequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){from._impl_.claims_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:claims_sequence)
}

inline void claims_sequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

claims_sequence::~claims_sequence() {
  // @@protoc_insertion_point(destructor:claims_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.claims_.~RepeatedPtrField();
}

void claims_sequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claims_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claims_sequence)
  return target;
}

size_t claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->_impl_.claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claims_sequence::GetClassData() const { return &_class_data_; }


void claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<claims_sequence*>(&to_msg);
  auto& from = static_cast<const claims_sequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:claims_sequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.claims_.MergeFrom(from._impl_.claims_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claims_sequence::CopyFrom(const claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claims_sequence::IsInitialized() const {
  return true;
}

void claims_sequence::InternalSwap(claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.claims_.InternalSwap(&other->_impl_.claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata claims_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[26]);
}

// ===================================================================

class signed_claim_sequence::_Internal {
 public:
};

signed_claim_sequence::signed_claim_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:signed_claim_sequence)
}
signed_claim_sequence::signed_claim_sequence(const signed_claim_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  signed_claim_sequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){from._impl_.claims_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signed_claim_sequence)
}

inline void signed_claim_sequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.claims_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

signed_claim_sequence::~signed_claim_sequence() {
  // @@protoc_insertion_point(destructor:signed_claim_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void signed_claim_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.claims_.~RepeatedPtrField();
}

void signed_claim_sequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void signed_claim_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .signed_claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_sequence)
  return target;
}

size_t signed_claim_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->_impl_.claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    signed_claim_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_sequence::GetClassData() const { return &_class_data_; }


void signed_claim_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<signed_claim_sequence*>(&to_msg);
  auto& from = static_cast<const signed_claim_sequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_sequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.claims_.MergeFrom(from._impl_.claims_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_sequence::CopyFrom(const signed_claim_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_sequence::IsInitialized() const {
  return true;
}

void signed_claim_sequence::InternalSwap(signed_claim_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.claims_.InternalSwap(&other->_impl_.claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[27]);
}

// ===================================================================

class tagged_signed_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_signed_claim>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(tagged_signed_claim, _impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::signed_claim_message& sc(const tagged_signed_claim* msg);
  static void set_has_sc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::signed_claim_message&
tagged_signed_claim::_Internal::sc(const tagged_signed_claim* msg) {
  return *msg->_impl_.sc_;
}
tagged_signed_claim::tagged_signed_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tagged_signed_claim)
}
tagged_signed_claim::tagged_signed_claim(const tagged_signed_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  tagged_signed_claim* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.sc_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sc()) {
    _this->_impl_.sc_ = new ::signed_claim_message(*from._impl_.sc_);
  }
  // @@protoc_insertion_point(copy_constructor:tagged_signed_claim)
}

inline void tagged_signed_claim::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.sc_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

tagged_signed_claim::~tagged_signed_claim() {
  // @@protoc_insertion_point(destructor:tagged_signed_claim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_signed_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sc_;
}

void tagged_signed_claim::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void tagged_signed_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sc_ != nullptr);
      _impl_.sc_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_signed_claim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_signed_claim.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .signed_claim_message sc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_signed_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_signed_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .signed_claim_message sc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sc(this),
        _Internal::sc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_signed_claim)
  return target;
}

size_t tagged_signed_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_signed_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .signed_claim_message sc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sc_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_signed_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    tagged_signed_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_signed_claim::GetClassData() const { return &_class_data_; }


void tagged_signed_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<tagged_signed_claim*>(&to_msg);
  auto& from = static_cast<const tagged_signed_claim&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tagged_signed_claim)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sc()->::signed_claim_message::MergeFrom(
          from._internal_sc());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_signed_claim::CopyFrom(const tagged_signed_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_signed_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_signed_claim::IsInitialized() const {
  return true;
}

void tagged_signed_claim::InternalSwap(tagged_signed_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.sc_, other->_impl_.sc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_signed_claim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[28]);
}

// ===================================================================

class buffer_sequence::_Internal {
 public:
};

buffer_sequence::buffer_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:buffer_sequence)
}
buffer_sequence::buffer_sequence(const buffer_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  buffer_sequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){from._impl_.block_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buffer_sequence)
}

inline void buffer_sequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

buffer_sequence::~buffer_sequence() {
  // @@protoc_insertion_point(destructor:buffer_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void buffer_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_.~RepeatedPtrField();
}

void buffer_sequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void buffer_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* buffer_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_block();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* buffer_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes block = 1;
  for (int i = 0, n = this->_internal_block_size(); i < n; i++) {
    const auto& s = this->_internal_block(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buffer_sequence)
  return target;
}

size_t buffer_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buffer_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes block = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.block_.size());
  for (int i = 0, n = _impl_.block_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.block_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData buffer_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    buffer_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*buffer_sequence::GetClassData() const { return &_class_data_; }


void buffer_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<buffer_sequence*>(&to_msg);
  auto& from = static_cast<const buffer_sequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buffer_sequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.block_.MergeFrom(from._impl_.block_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void buffer_sequence::CopyFrom(const buffer_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buffer_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool buffer_sequence::IsInitialized() const {
  return true;
}

void buffer_sequence::InternalSwap(buffer_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.block_.InternalSwap(&other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata buffer_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[29]);
}

// ===================================================================

class run_request::_Internal {
 public:
  using HasBits = decltype(std::declval<run_request>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(run_request, _impl_._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

run_request::run_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:run_request)
}
run_request::run_request(const run_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  run_request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.location_){}
    , decltype(_impl_.cert_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cert_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cert_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert()) {
    _this->_impl_.cert_.Set(from._internal_cert(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_request)
}

inline void run_request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.location_){}
    , decltype(_impl_.cert_){}
  };
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cert_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cert_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_request::~run_request() {
  // @@protoc_insertion_point(destructor:run_request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void run_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.location_.Destroy();
  _impl_.cert_.Destroy();
}

void run_request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void run_request::Clear() {
// @@protoc_insertion_point(message_clear_start:run_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cert_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "run_request.location");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes cert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cert();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "run_request.args");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string location = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.location");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_location(), target);
  }

  // optional bytes cert = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_cert(), target);
  }

  // repeated string args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.args");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_request)
  return target;
}

size_t run_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.args_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string location = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional bytes cert = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cert());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    run_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_request::GetClassData() const { return &_class_data_; }


void run_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<run_request*>(&to_msg);
  auto& from = static_cast<const run_request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:run_request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cert(from._internal_cert());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_request::CopyFrom(const run_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_request::IsInitialized() const {
  return true;
}

void run_request::InternalSwap(run_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cert_, lhs_arena,
      &other->_impl_.cert_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[30]);
}

// ===================================================================

class run_response::_Internal {
 public:
  using HasBits = decltype(std::declval<run_response>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(run_response, _impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

run_response::run_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:run_response)
}
run_response::run_response(const run_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  run_response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_response)
}

inline void run_response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_response::~run_response() {
  // @@protoc_insertion_point(destructor:run_response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void run_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void run_response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void run_response::Clear() {
// @@protoc_insertion_point(message_clear_start:run_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.status_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "run_response.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_response.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_response)
  return target;
}

size_t run_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string status = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    run_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_response::GetClassData() const { return &_class_data_; }


void run_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<run_response*>(&to_msg);
  auto& from = static_cast<const run_response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:run_response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_response::CopyFrom(const run_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_response::IsInitialized() const {
  return true;
}

void run_response::InternalSwap(run_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[31]);
}

// ===================================================================

class app_request::_Internal {
 public:
  using HasBits = decltype(std::declval<app_request>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(app_request, _impl_._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

app_request::app_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:app_request)
}
app_request::app_request(const app_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  app_request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.function_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    _this->_impl_.function_.Set(from._internal_function(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_request)
}

inline void app_request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.function_){}
  };
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_request::~app_request() {
  // @@protoc_insertion_point(destructor:app_request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void app_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.function_.Destroy();
}

void app_request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void app_request::Clear() {
// @@protoc_insertion_point(message_clear_start:app_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.function_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_request.function");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_request.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // repeated bytes args = 2;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_request)
  return target;
}

size_t app_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.args_.Get(i));
  }

  // optional string function = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_function());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    app_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_request::GetClassData() const { return &_class_data_; }


void app_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<app_request*>(&to_msg);
  auto& from = static_cast<const app_request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:app_request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_function()) {
    _this->_internal_set_function(from._internal_function());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_request::CopyFrom(const app_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_request::IsInitialized() const {
  return true;
}

void app_request::InternalSwap(app_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_, lhs_arena,
      &other->_impl_.function_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[32]);
}

// ===================================================================

class app_response::_Internal {
 public:
  using HasBits = decltype(std::declval<app_response>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(app_response, _impl_._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

app_response::app_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:app_response)
}
app_response::app_response(const app_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  app_response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.function_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    _this->_impl_.function_.Set(from._internal_function(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_response)
}

inline void app_response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.function_){}
    , decltype(_impl_.status_){}
  };
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_response::~app_response() {
  // @@protoc_insertion_point(destructor:app_response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void app_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.function_.Destroy();
  _impl_.status_.Destroy();
}

void app_response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void app_response::Clear() {
// @@protoc_insertion_point(message_clear_start:app_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.function_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_response.function");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_response.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // optional string status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  // repeated bytes args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_response)
  return target;
}

size_t app_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.args_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string function = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_function());
    }

    // optional string status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    app_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_response::GetClassData() const { return &_class_data_; }


void app_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<app_response*>(&to_msg);
  auto& from = static_cast<const app_response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:app_response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_function(from._internal_function());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_response::CopyFrom(const app_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_response::IsInitialized() const {
  return true;
}

void app_response::InternalSwap(app_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_, lhs_arena,
      &other->_impl_.function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[33]);
}

// ===================================================================

class tagged_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_blob_message>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(tagged_blob_message, _impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

tagged_blob_message::tagged_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tagged_blob_message)
}
tagged_blob_message::tagged_blob_message(const tagged_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  tagged_blob_message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.b_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_b()) {
    _this->_impl_.b_.Set(from._internal_b(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tagged_blob_message)
}

inline void tagged_blob_message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.b_){}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

tagged_blob_message::~tagged_blob_message() {
  // @@protoc_insertion_point(destructor:tagged_blob_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  _impl_.b_.Destroy();
}

void tagged_blob_message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void tagged_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.b_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_blob_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_blob_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes b = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_b();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_blob_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional bytes b = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_blob_message)
  return target;
}

size_t tagged_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional bytes b = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_b());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    tagged_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_blob_message::GetClassData() const { return &_class_data_; }


void tagged_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<tagged_blob_message*>(&to_msg);
  auto& from = static_cast<const tagged_blob_message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tagged_blob_message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_b(from._internal_b());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_blob_message::CopyFrom(const tagged_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_blob_message::IsInitialized() const {
  return true;
}

void tagged_blob_message::InternalSwap(tagged_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.b_, lhs_arena,
      &other->_impl_.b_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_blob_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[34]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::time_point*
Arena::CreateMaybeMessage< ::time_point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::time_point >(arena);
}
template<> PROTOBUF_NOINLINE ::rsa_message*
Arena::CreateMaybeMessage< ::rsa_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rsa_message >(arena);
}
template<> PROTOBUF_NOINLINE ::ecc_message*
Arena::CreateMaybeMessage< ::ecc_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ecc_message >(arena);
}
template<> PROTOBUF_NOINLINE ::key_message*
Arena::CreateMaybeMessage< ::key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::protected_blob_message*
Arena::CreateMaybeMessage< ::protected_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protected_blob_message >(arena);
}
template<> PROTOBUF_NOINLINE ::entity_message*
Arena::CreateMaybeMessage< ::entity_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::entity_message >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clause*
Arena::CreateMaybeMessage< ::vse_clause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clause >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clauses*
Arena::CreateMaybeMessage< ::vse_clauses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clauses >(arena);
}
template<> PROTOBUF_NOINLINE ::attestation*
Arena::CreateMaybeMessage< ::attestation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::attestation >(arena);
}
template<> PROTOBUF_NOINLINE ::claim_message*
Arena::CreateMaybeMessage< ::claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_message*
Arena::CreateMaybeMessage< ::signed_claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::oe_assertion*
Arena::CreateMaybeMessage< ::oe_assertion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::oe_assertion >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence*
Arena::CreateMaybeMessage< ::evidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence_package*
Arena::CreateMaybeMessage< ::evidence_package >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence_package >(arena);
}
template<> PROTOBUF_NOINLINE ::certifier_rules*
Arena::CreateMaybeMessage< ::certifier_rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::certifier_rules >(arena);
}
template<> PROTOBUF_NOINLINE ::proved_statements*
Arena::CreateMaybeMessage< ::proved_statements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proved_statements >(arena);
}
template<> PROTOBUF_NOINLINE ::proof_step*
Arena::CreateMaybeMessage< ::proof_step >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof_step >(arena);
}
template<> PROTOBUF_NOINLINE ::proof*
Arena::CreateMaybeMessage< ::proof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_request_message*
Arena::CreateMaybeMessage< ::trust_request_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_request_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_response_message*
Arena::CreateMaybeMessage< ::trust_response_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_response_message >(arena);
}
template<> PROTOBUF_NOINLINE ::storage_info_message*
Arena::CreateMaybeMessage< ::storage_info_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage_info_message >(arena);
}
template<> PROTOBUF_NOINLINE ::channel_key_message*
Arena::CreateMaybeMessage< ::channel_key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::channel_key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trusted_service_message*
Arena::CreateMaybeMessage< ::trusted_service_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trusted_service_message >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claim*
Arena::CreateMaybeMessage< ::tagged_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claims_sequence*
Arena::CreateMaybeMessage< ::tagged_claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::policy_store_message*
Arena::CreateMaybeMessage< ::policy_store_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::policy_store_message >(arena);
}
template<> PROTOBUF_NOINLINE ::claims_sequence*
Arena::CreateMaybeMessage< ::claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_sequence*
Arena::CreateMaybeMessage< ::signed_claim_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_signed_claim*
Arena::CreateMaybeMessage< ::tagged_signed_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_signed_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::buffer_sequence*
Arena::CreateMaybeMessage< ::buffer_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buffer_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::run_request*
Arena::CreateMaybeMessage< ::run_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_request >(arena);
}
template<> PROTOBUF_NOINLINE ::run_response*
Arena::CreateMaybeMessage< ::run_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_response >(arena);
}
template<> PROTOBUF_NOINLINE ::app_request*
Arena::CreateMaybeMessage< ::app_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_request >(arena);
}
template<> PROTOBUF_NOINLINE ::app_response*
Arena::CreateMaybeMessage< ::app_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_response >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_blob_message*
Arena::CreateMaybeMessage< ::tagged_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_blob_message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
