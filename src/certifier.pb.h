// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certifier.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_certifier_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_certifier_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_certifier_2eproto;
class app_request;
struct app_requestDefaultTypeInternal;
extern app_requestDefaultTypeInternal _app_request_default_instance_;
class app_response;
struct app_responseDefaultTypeInternal;
extern app_responseDefaultTypeInternal _app_response_default_instance_;
class attestation;
struct attestationDefaultTypeInternal;
extern attestationDefaultTypeInternal _attestation_default_instance_;
class buffer_sequence;
struct buffer_sequenceDefaultTypeInternal;
extern buffer_sequenceDefaultTypeInternal _buffer_sequence_default_instance_;
class certifier_rules;
struct certifier_rulesDefaultTypeInternal;
extern certifier_rulesDefaultTypeInternal _certifier_rules_default_instance_;
class channel_key_message;
struct channel_key_messageDefaultTypeInternal;
extern channel_key_messageDefaultTypeInternal _channel_key_message_default_instance_;
class claim_message;
struct claim_messageDefaultTypeInternal;
extern claim_messageDefaultTypeInternal _claim_message_default_instance_;
class claims_sequence;
struct claims_sequenceDefaultTypeInternal;
extern claims_sequenceDefaultTypeInternal _claims_sequence_default_instance_;
class ecc_message;
struct ecc_messageDefaultTypeInternal;
extern ecc_messageDefaultTypeInternal _ecc_message_default_instance_;
class entity_message;
struct entity_messageDefaultTypeInternal;
extern entity_messageDefaultTypeInternal _entity_message_default_instance_;
class evidence;
struct evidenceDefaultTypeInternal;
extern evidenceDefaultTypeInternal _evidence_default_instance_;
class evidence_package;
struct evidence_packageDefaultTypeInternal;
extern evidence_packageDefaultTypeInternal _evidence_package_default_instance_;
class key_message;
struct key_messageDefaultTypeInternal;
extern key_messageDefaultTypeInternal _key_message_default_instance_;
class oe_assertion;
struct oe_assertionDefaultTypeInternal;
extern oe_assertionDefaultTypeInternal _oe_assertion_default_instance_;
class point_message;
struct point_messageDefaultTypeInternal;
extern point_messageDefaultTypeInternal _point_message_default_instance_;
class policy_store_message;
struct policy_store_messageDefaultTypeInternal;
extern policy_store_messageDefaultTypeInternal _policy_store_message_default_instance_;
class proof;
struct proofDefaultTypeInternal;
extern proofDefaultTypeInternal _proof_default_instance_;
class proof_step;
struct proof_stepDefaultTypeInternal;
extern proof_stepDefaultTypeInternal _proof_step_default_instance_;
class protected_blob_message;
struct protected_blob_messageDefaultTypeInternal;
extern protected_blob_messageDefaultTypeInternal _protected_blob_message_default_instance_;
class proved_statements;
struct proved_statementsDefaultTypeInternal;
extern proved_statementsDefaultTypeInternal _proved_statements_default_instance_;
class rsa_message;
struct rsa_messageDefaultTypeInternal;
extern rsa_messageDefaultTypeInternal _rsa_message_default_instance_;
class run_request;
struct run_requestDefaultTypeInternal;
extern run_requestDefaultTypeInternal _run_request_default_instance_;
class run_response;
struct run_responseDefaultTypeInternal;
extern run_responseDefaultTypeInternal _run_response_default_instance_;
class signed_claim_message;
struct signed_claim_messageDefaultTypeInternal;
extern signed_claim_messageDefaultTypeInternal _signed_claim_message_default_instance_;
class signed_claim_sequence;
struct signed_claim_sequenceDefaultTypeInternal;
extern signed_claim_sequenceDefaultTypeInternal _signed_claim_sequence_default_instance_;
class storage_info_message;
struct storage_info_messageDefaultTypeInternal;
extern storage_info_messageDefaultTypeInternal _storage_info_message_default_instance_;
class tagged_blob_message;
struct tagged_blob_messageDefaultTypeInternal;
extern tagged_blob_messageDefaultTypeInternal _tagged_blob_message_default_instance_;
class tagged_claim;
struct tagged_claimDefaultTypeInternal;
extern tagged_claimDefaultTypeInternal _tagged_claim_default_instance_;
class tagged_claims_sequence;
struct tagged_claims_sequenceDefaultTypeInternal;
extern tagged_claims_sequenceDefaultTypeInternal _tagged_claims_sequence_default_instance_;
class tagged_signed_claim;
struct tagged_signed_claimDefaultTypeInternal;
extern tagged_signed_claimDefaultTypeInternal _tagged_signed_claim_default_instance_;
class time_point;
struct time_pointDefaultTypeInternal;
extern time_pointDefaultTypeInternal _time_point_default_instance_;
class trust_request_message;
struct trust_request_messageDefaultTypeInternal;
extern trust_request_messageDefaultTypeInternal _trust_request_message_default_instance_;
class trust_response_message;
struct trust_response_messageDefaultTypeInternal;
extern trust_response_messageDefaultTypeInternal _trust_response_message_default_instance_;
class trusted_service_message;
struct trusted_service_messageDefaultTypeInternal;
extern trusted_service_messageDefaultTypeInternal _trusted_service_message_default_instance_;
class vse_clause;
struct vse_clauseDefaultTypeInternal;
extern vse_clauseDefaultTypeInternal _vse_clause_default_instance_;
class vse_clauses;
struct vse_clausesDefaultTypeInternal;
extern vse_clausesDefaultTypeInternal _vse_clauses_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::app_request* Arena::CreateMaybeMessage<::app_request>(Arena*);
template<> ::app_response* Arena::CreateMaybeMessage<::app_response>(Arena*);
template<> ::attestation* Arena::CreateMaybeMessage<::attestation>(Arena*);
template<> ::buffer_sequence* Arena::CreateMaybeMessage<::buffer_sequence>(Arena*);
template<> ::certifier_rules* Arena::CreateMaybeMessage<::certifier_rules>(Arena*);
template<> ::channel_key_message* Arena::CreateMaybeMessage<::channel_key_message>(Arena*);
template<> ::claim_message* Arena::CreateMaybeMessage<::claim_message>(Arena*);
template<> ::claims_sequence* Arena::CreateMaybeMessage<::claims_sequence>(Arena*);
template<> ::ecc_message* Arena::CreateMaybeMessage<::ecc_message>(Arena*);
template<> ::entity_message* Arena::CreateMaybeMessage<::entity_message>(Arena*);
template<> ::evidence* Arena::CreateMaybeMessage<::evidence>(Arena*);
template<> ::evidence_package* Arena::CreateMaybeMessage<::evidence_package>(Arena*);
template<> ::key_message* Arena::CreateMaybeMessage<::key_message>(Arena*);
template<> ::oe_assertion* Arena::CreateMaybeMessage<::oe_assertion>(Arena*);
template<> ::point_message* Arena::CreateMaybeMessage<::point_message>(Arena*);
template<> ::policy_store_message* Arena::CreateMaybeMessage<::policy_store_message>(Arena*);
template<> ::proof* Arena::CreateMaybeMessage<::proof>(Arena*);
template<> ::proof_step* Arena::CreateMaybeMessage<::proof_step>(Arena*);
template<> ::protected_blob_message* Arena::CreateMaybeMessage<::protected_blob_message>(Arena*);
template<> ::proved_statements* Arena::CreateMaybeMessage<::proved_statements>(Arena*);
template<> ::rsa_message* Arena::CreateMaybeMessage<::rsa_message>(Arena*);
template<> ::run_request* Arena::CreateMaybeMessage<::run_request>(Arena*);
template<> ::run_response* Arena::CreateMaybeMessage<::run_response>(Arena*);
template<> ::signed_claim_message* Arena::CreateMaybeMessage<::signed_claim_message>(Arena*);
template<> ::signed_claim_sequence* Arena::CreateMaybeMessage<::signed_claim_sequence>(Arena*);
template<> ::storage_info_message* Arena::CreateMaybeMessage<::storage_info_message>(Arena*);
template<> ::tagged_blob_message* Arena::CreateMaybeMessage<::tagged_blob_message>(Arena*);
template<> ::tagged_claim* Arena::CreateMaybeMessage<::tagged_claim>(Arena*);
template<> ::tagged_claims_sequence* Arena::CreateMaybeMessage<::tagged_claims_sequence>(Arena*);
template<> ::tagged_signed_claim* Arena::CreateMaybeMessage<::tagged_signed_claim>(Arena*);
template<> ::time_point* Arena::CreateMaybeMessage<::time_point>(Arena*);
template<> ::trust_request_message* Arena::CreateMaybeMessage<::trust_request_message>(Arena*);
template<> ::trust_response_message* Arena::CreateMaybeMessage<::trust_response_message>(Arena*);
template<> ::trusted_service_message* Arena::CreateMaybeMessage<::trusted_service_message>(Arena*);
template<> ::vse_clause* Arena::CreateMaybeMessage<::vse_clause>(Arena*);
template<> ::vse_clauses* Arena::CreateMaybeMessage<::vse_clauses>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class time_point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:time_point) */ {
 public:
  inline time_point() : time_point(nullptr) {}
  ~time_point() override;
  explicit constexpr time_point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  time_point(const time_point& from);
  time_point(time_point&& from) noexcept
    : time_point() {
    *this = ::std::move(from);
  }

  inline time_point& operator=(const time_point& from) {
    CopyFrom(from);
    return *this;
  }
  inline time_point& operator=(time_point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const time_point& default_instance() {
    return *internal_default_instance();
  }
  static inline const time_point* internal_default_instance() {
    return reinterpret_cast<const time_point*>(
               &_time_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(time_point& a, time_point& b) {
    a.Swap(&b);
  }
  inline void Swap(time_point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(time_point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  time_point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<time_point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const time_point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const time_point& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(time_point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "time_point";
  }
  protected:
  explicit time_point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kDayFieldNumber = 3,
    kHourFieldNumber = 4,
    kSecondsFieldNumber = 6,
    kMinuteFieldNumber = 5,
  };
  // optional int32 year = 1;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  int32_t year() const;
  void set_year(int32_t value);
  private:
  int32_t _internal_year() const;
  void _internal_set_year(int32_t value);
  public:

  // optional int32 month = 2;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  int32_t month() const;
  void set_month(int32_t value);
  private:
  int32_t _internal_month() const;
  void _internal_set_month(int32_t value);
  public:

  // optional int32 day = 3;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  int32_t day() const;
  void set_day(int32_t value);
  private:
  int32_t _internal_day() const;
  void _internal_set_day(int32_t value);
  public:

  // optional int32 hour = 4;
  bool has_hour() const;
  private:
  bool _internal_has_hour() const;
  public:
  void clear_hour();
  int32_t hour() const;
  void set_hour(int32_t value);
  private:
  int32_t _internal_hour() const;
  void _internal_set_hour(int32_t value);
  public:

  // optional double seconds = 6;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // optional int32 minute = 5;
  bool has_minute() const;
  private:
  bool _internal_has_minute() const;
  public:
  void clear_minute();
  int32_t minute() const;
  void set_minute(int32_t value);
  private:
  int32_t _internal_minute() const;
  void _internal_set_minute(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:time_point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t year_;
  int32_t month_;
  int32_t day_;
  int32_t hour_;
  double seconds_;
  int32_t minute_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class rsa_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsa_message) */ {
 public:
  inline rsa_message() : rsa_message(nullptr) {}
  ~rsa_message() override;
  explicit constexpr rsa_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rsa_message(const rsa_message& from);
  rsa_message(rsa_message&& from) noexcept
    : rsa_message() {
    *this = ::std::move(from);
  }

  inline rsa_message& operator=(const rsa_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rsa_message& operator=(rsa_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rsa_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const rsa_message* internal_default_instance() {
    return reinterpret_cast<const rsa_message*>(
               &_rsa_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(rsa_message& a, rsa_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rsa_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rsa_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rsa_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rsa_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rsa_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const rsa_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rsa_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsa_message";
  }
  protected:
  explicit rsa_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicModulusFieldNumber = 1,
    kPublicExponentFieldNumber = 2,
    kPrivateExponentFieldNumber = 3,
    kPrivatePFieldNumber = 4,
    kPrivateQFieldNumber = 5,
    kPrivateDpFieldNumber = 6,
    kPrivateDqFieldNumber = 7,
  };
  // optional bytes public_modulus = 1;
  bool has_public_modulus() const;
  private:
  bool _internal_has_public_modulus() const;
  public:
  void clear_public_modulus();
  const std::string& public_modulus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_modulus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_modulus();
  PROTOBUF_NODISCARD std::string* release_public_modulus();
  void set_allocated_public_modulus(std::string* public_modulus);
  private:
  const std::string& _internal_public_modulus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_modulus(const std::string& value);
  std::string* _internal_mutable_public_modulus();
  public:

  // optional bytes public_exponent = 2;
  bool has_public_exponent() const;
  private:
  bool _internal_has_public_exponent() const;
  public:
  void clear_public_exponent();
  const std::string& public_exponent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_exponent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_exponent();
  PROTOBUF_NODISCARD std::string* release_public_exponent();
  void set_allocated_public_exponent(std::string* public_exponent);
  private:
  const std::string& _internal_public_exponent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_exponent(const std::string& value);
  std::string* _internal_mutable_public_exponent();
  public:

  // optional bytes private_exponent = 3;
  bool has_private_exponent() const;
  private:
  bool _internal_has_private_exponent() const;
  public:
  void clear_private_exponent();
  const std::string& private_exponent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_exponent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_exponent();
  PROTOBUF_NODISCARD std::string* release_private_exponent();
  void set_allocated_private_exponent(std::string* private_exponent);
  private:
  const std::string& _internal_private_exponent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_exponent(const std::string& value);
  std::string* _internal_mutable_private_exponent();
  public:

  // optional bytes private_p = 4;
  bool has_private_p() const;
  private:
  bool _internal_has_private_p() const;
  public:
  void clear_private_p();
  const std::string& private_p() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_p(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_p();
  PROTOBUF_NODISCARD std::string* release_private_p();
  void set_allocated_private_p(std::string* private_p);
  private:
  const std::string& _internal_private_p() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_p(const std::string& value);
  std::string* _internal_mutable_private_p();
  public:

  // optional bytes private_q = 5;
  bool has_private_q() const;
  private:
  bool _internal_has_private_q() const;
  public:
  void clear_private_q();
  const std::string& private_q() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_q(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_q();
  PROTOBUF_NODISCARD std::string* release_private_q();
  void set_allocated_private_q(std::string* private_q);
  private:
  const std::string& _internal_private_q() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_q(const std::string& value);
  std::string* _internal_mutable_private_q();
  public:

  // optional bytes private_dp = 6;
  bool has_private_dp() const;
  private:
  bool _internal_has_private_dp() const;
  public:
  void clear_private_dp();
  const std::string& private_dp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_dp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_dp();
  PROTOBUF_NODISCARD std::string* release_private_dp();
  void set_allocated_private_dp(std::string* private_dp);
  private:
  const std::string& _internal_private_dp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_dp(const std::string& value);
  std::string* _internal_mutable_private_dp();
  public:

  // optional bytes private_dq = 7;
  bool has_private_dq() const;
  private:
  bool _internal_has_private_dq() const;
  public:
  void clear_private_dq();
  const std::string& private_dq() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_dq(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_dq();
  PROTOBUF_NODISCARD std::string* release_private_dq();
  void set_allocated_private_dq(std::string* private_dq);
  private:
  const std::string& _internal_private_dq() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_dq(const std::string& value);
  std::string* _internal_mutable_private_dq();
  public:

  // @@protoc_insertion_point(class_scope:rsa_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_modulus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_q_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_dp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_dq_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class point_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:point_message) */ {
 public:
  inline point_message() : point_message(nullptr) {}
  ~point_message() override;
  explicit constexpr point_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  point_message(const point_message& from);
  point_message(point_message&& from) noexcept
    : point_message() {
    *this = ::std::move(from);
  }

  inline point_message& operator=(const point_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline point_message& operator=(point_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const point_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const point_message* internal_default_instance() {
    return reinterpret_cast<const point_message*>(
               &_point_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(point_message& a, point_message& b) {
    a.Swap(&b);
  }
  inline void Swap(point_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(point_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  point_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<point_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const point_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const point_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(point_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "point_message";
  }
  protected:
  explicit point_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional bytes x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const std::string& x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x();
  PROTOBUF_NODISCARD std::string* release_x();
  void set_allocated_x(std::string* x);
  private:
  const std::string& _internal_x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x(const std::string& value);
  std::string* _internal_mutable_x();
  public:

  // optional bytes y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const std::string& y() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_y(ArgT0&& arg0, ArgT... args);
  std::string* mutable_y();
  PROTOBUF_NODISCARD std::string* release_y();
  void set_allocated_y(std::string* y);
  private:
  const std::string& _internal_y() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_y(const std::string& value);
  std::string* _internal_mutable_y();
  public:

  // @@protoc_insertion_point(class_scope:point_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class ecc_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecc_message) */ {
 public:
  inline ecc_message() : ecc_message(nullptr) {}
  ~ecc_message() override;
  explicit constexpr ecc_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ecc_message(const ecc_message& from);
  ecc_message(ecc_message&& from) noexcept
    : ecc_message() {
    *this = ::std::move(from);
  }

  inline ecc_message& operator=(const ecc_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ecc_message& operator=(ecc_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ecc_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const ecc_message* internal_default_instance() {
    return reinterpret_cast<const ecc_message*>(
               &_ecc_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ecc_message& a, ecc_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ecc_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ecc_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ecc_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ecc_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ecc_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ecc_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ecc_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecc_message";
  }
  protected:
  explicit ecc_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurveNameFieldNumber = 1,
    kCurvePFieldNumber = 2,
    kCurveAFieldNumber = 3,
    kCurveBFieldNumber = 4,
    kOrderOfBasePointFieldNumber = 7,
    kPrivateMultiplierFieldNumber = 8,
    kBasePointFieldNumber = 5,
    kPublicPointFieldNumber = 6,
  };
  // optional string curve_name = 1;
  bool has_curve_name() const;
  private:
  bool _internal_has_curve_name() const;
  public:
  void clear_curve_name();
  const std::string& curve_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curve_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curve_name();
  PROTOBUF_NODISCARD std::string* release_curve_name();
  void set_allocated_curve_name(std::string* curve_name);
  private:
  const std::string& _internal_curve_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curve_name(const std::string& value);
  std::string* _internal_mutable_curve_name();
  public:

  // optional bytes curve_p = 2;
  bool has_curve_p() const;
  private:
  bool _internal_has_curve_p() const;
  public:
  void clear_curve_p();
  const std::string& curve_p() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curve_p(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curve_p();
  PROTOBUF_NODISCARD std::string* release_curve_p();
  void set_allocated_curve_p(std::string* curve_p);
  private:
  const std::string& _internal_curve_p() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curve_p(const std::string& value);
  std::string* _internal_mutable_curve_p();
  public:

  // optional bytes curve_a = 3;
  bool has_curve_a() const;
  private:
  bool _internal_has_curve_a() const;
  public:
  void clear_curve_a();
  const std::string& curve_a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curve_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curve_a();
  PROTOBUF_NODISCARD std::string* release_curve_a();
  void set_allocated_curve_a(std::string* curve_a);
  private:
  const std::string& _internal_curve_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curve_a(const std::string& value);
  std::string* _internal_mutable_curve_a();
  public:

  // optional bytes curve_b = 4;
  bool has_curve_b() const;
  private:
  bool _internal_has_curve_b() const;
  public:
  void clear_curve_b();
  const std::string& curve_b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curve_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curve_b();
  PROTOBUF_NODISCARD std::string* release_curve_b();
  void set_allocated_curve_b(std::string* curve_b);
  private:
  const std::string& _internal_curve_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curve_b(const std::string& value);
  std::string* _internal_mutable_curve_b();
  public:

  // optional bytes order_of_base_point = 7;
  bool has_order_of_base_point() const;
  private:
  bool _internal_has_order_of_base_point() const;
  public:
  void clear_order_of_base_point();
  const std::string& order_of_base_point() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_of_base_point(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_of_base_point();
  PROTOBUF_NODISCARD std::string* release_order_of_base_point();
  void set_allocated_order_of_base_point(std::string* order_of_base_point);
  private:
  const std::string& _internal_order_of_base_point() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_of_base_point(const std::string& value);
  std::string* _internal_mutable_order_of_base_point();
  public:

  // optional bytes private_multiplier = 8;
  bool has_private_multiplier() const;
  private:
  bool _internal_has_private_multiplier() const;
  public:
  void clear_private_multiplier();
  const std::string& private_multiplier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_multiplier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_multiplier();
  PROTOBUF_NODISCARD std::string* release_private_multiplier();
  void set_allocated_private_multiplier(std::string* private_multiplier);
  private:
  const std::string& _internal_private_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_multiplier(const std::string& value);
  std::string* _internal_mutable_private_multiplier();
  public:

  // optional .point_message base_point = 5;
  bool has_base_point() const;
  private:
  bool _internal_has_base_point() const;
  public:
  void clear_base_point();
  const ::point_message& base_point() const;
  PROTOBUF_NODISCARD ::point_message* release_base_point();
  ::point_message* mutable_base_point();
  void set_allocated_base_point(::point_message* base_point);
  private:
  const ::point_message& _internal_base_point() const;
  ::point_message* _internal_mutable_base_point();
  public:
  void unsafe_arena_set_allocated_base_point(
      ::point_message* base_point);
  ::point_message* unsafe_arena_release_base_point();

  // optional .point_message public_point = 6;
  bool has_public_point() const;
  private:
  bool _internal_has_public_point() const;
  public:
  void clear_public_point();
  const ::point_message& public_point() const;
  PROTOBUF_NODISCARD ::point_message* release_public_point();
  ::point_message* mutable_public_point();
  void set_allocated_public_point(::point_message* public_point);
  private:
  const ::point_message& _internal_public_point() const;
  ::point_message* _internal_mutable_public_point();
  public:
  void unsafe_arena_set_allocated_public_point(
      ::point_message* public_point);
  ::point_message* unsafe_arena_release_public_point();

  // @@protoc_insertion_point(class_scope:ecc_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_b_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_of_base_point_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_multiplier_;
  ::point_message* base_point_;
  ::point_message* public_point_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class key_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:key_message) */ {
 public:
  inline key_message() : key_message(nullptr) {}
  ~key_message() override;
  explicit constexpr key_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  key_message(const key_message& from);
  key_message(key_message&& from) noexcept
    : key_message() {
    *this = ::std::move(from);
  }

  inline key_message& operator=(const key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline key_message& operator=(key_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const key_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const key_message* internal_default_instance() {
    return reinterpret_cast<const key_message*>(
               &_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(key_message& a, key_message& b) {
    a.Swap(&b);
  }
  inline void Swap(key_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(key_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<key_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const key_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const key_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(key_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "key_message";
  }
  protected:
  explicit key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyNameFieldNumber = 1,
    kKeyTypeFieldNumber = 2,
    kKeyFormatFieldNumber = 3,
    kSecretKeyBitsFieldNumber = 6,
    kCertificateFieldNumber = 7,
    kOtherKeyFormatsFieldNumber = 8,
    kNotBeforeFieldNumber = 9,
    kNotAfterFieldNumber = 10,
    kRsaKeyFieldNumber = 4,
    kEccKeyFieldNumber = 5,
  };
  // optional string key_name = 1;
  bool has_key_name() const;
  private:
  bool _internal_has_key_name() const;
  public:
  void clear_key_name();
  const std::string& key_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_name();
  PROTOBUF_NODISCARD std::string* release_key_name();
  void set_allocated_key_name(std::string* key_name);
  private:
  const std::string& _internal_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_name(const std::string& value);
  std::string* _internal_mutable_key_name();
  public:

  // optional string key_type = 2;
  bool has_key_type() const;
  private:
  bool _internal_has_key_type() const;
  public:
  void clear_key_type();
  const std::string& key_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_type();
  PROTOBUF_NODISCARD std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);
  private:
  const std::string& _internal_key_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_type(const std::string& value);
  std::string* _internal_mutable_key_type();
  public:

  // optional string key_format = 3;
  bool has_key_format() const;
  private:
  bool _internal_has_key_format() const;
  public:
  void clear_key_format();
  const std::string& key_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_format();
  PROTOBUF_NODISCARD std::string* release_key_format();
  void set_allocated_key_format(std::string* key_format);
  private:
  const std::string& _internal_key_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_format(const std::string& value);
  std::string* _internal_mutable_key_format();
  public:

  // optional bytes secret_key_bits = 6;
  bool has_secret_key_bits() const;
  private:
  bool _internal_has_secret_key_bits() const;
  public:
  void clear_secret_key_bits();
  const std::string& secret_key_bits() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_key_bits(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_key_bits();
  PROTOBUF_NODISCARD std::string* release_secret_key_bits();
  void set_allocated_secret_key_bits(std::string* secret_key_bits);
  private:
  const std::string& _internal_secret_key_bits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_key_bits(const std::string& value);
  std::string* _internal_mutable_secret_key_bits();
  public:

  // optional bytes certificate = 7;
  bool has_certificate() const;
  private:
  bool _internal_has_certificate() const;
  public:
  void clear_certificate();
  const std::string& certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_certificate();
  PROTOBUF_NODISCARD std::string* release_certificate();
  void set_allocated_certificate(std::string* certificate);
  private:
  const std::string& _internal_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_certificate(const std::string& value);
  std::string* _internal_mutable_certificate();
  public:

  // optional bytes other_key_formats = 8;
  bool has_other_key_formats() const;
  private:
  bool _internal_has_other_key_formats() const;
  public:
  void clear_other_key_formats();
  const std::string& other_key_formats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_other_key_formats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_other_key_formats();
  PROTOBUF_NODISCARD std::string* release_other_key_formats();
  void set_allocated_other_key_formats(std::string* other_key_formats);
  private:
  const std::string& _internal_other_key_formats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_other_key_formats(const std::string& value);
  std::string* _internal_mutable_other_key_formats();
  public:

  // optional string not_before = 9;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const std::string& not_before() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_before(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_before();
  PROTOBUF_NODISCARD std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);
  private:
  const std::string& _internal_not_before() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_before(const std::string& value);
  std::string* _internal_mutable_not_before();
  public:

  // optional string not_after = 10;
  bool has_not_after() const;
  private:
  bool _internal_has_not_after() const;
  public:
  void clear_not_after();
  const std::string& not_after() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_after(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_after();
  PROTOBUF_NODISCARD std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);
  private:
  const std::string& _internal_not_after() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_after(const std::string& value);
  std::string* _internal_mutable_not_after();
  public:

  // optional .rsa_message rsa_key = 4;
  bool has_rsa_key() const;
  private:
  bool _internal_has_rsa_key() const;
  public:
  void clear_rsa_key();
  const ::rsa_message& rsa_key() const;
  PROTOBUF_NODISCARD ::rsa_message* release_rsa_key();
  ::rsa_message* mutable_rsa_key();
  void set_allocated_rsa_key(::rsa_message* rsa_key);
  private:
  const ::rsa_message& _internal_rsa_key() const;
  ::rsa_message* _internal_mutable_rsa_key();
  public:
  void unsafe_arena_set_allocated_rsa_key(
      ::rsa_message* rsa_key);
  ::rsa_message* unsafe_arena_release_rsa_key();

  // optional .ecc_message ecc_key = 5;
  bool has_ecc_key() const;
  private:
  bool _internal_has_ecc_key() const;
  public:
  void clear_ecc_key();
  const ::ecc_message& ecc_key() const;
  PROTOBUF_NODISCARD ::ecc_message* release_ecc_key();
  ::ecc_message* mutable_ecc_key();
  void set_allocated_ecc_key(::ecc_message* ecc_key);
  private:
  const ::ecc_message& _internal_ecc_key() const;
  ::ecc_message* _internal_mutable_ecc_key();
  public:
  void unsafe_arena_set_allocated_ecc_key(
      ::ecc_message* ecc_key);
  ::ecc_message* unsafe_arena_release_ecc_key();

  // @@protoc_insertion_point(class_scope:key_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_key_bits_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr other_key_formats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::rsa_message* rsa_key_;
  ::ecc_message* ecc_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class protected_blob_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protected_blob_message) */ {
 public:
  inline protected_blob_message() : protected_blob_message(nullptr) {}
  ~protected_blob_message() override;
  explicit constexpr protected_blob_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  protected_blob_message(const protected_blob_message& from);
  protected_blob_message(protected_blob_message&& from) noexcept
    : protected_blob_message() {
    *this = ::std::move(from);
  }

  inline protected_blob_message& operator=(const protected_blob_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline protected_blob_message& operator=(protected_blob_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const protected_blob_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const protected_blob_message* internal_default_instance() {
    return reinterpret_cast<const protected_blob_message*>(
               &_protected_blob_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(protected_blob_message& a, protected_blob_message& b) {
    a.Swap(&b);
  }
  inline void Swap(protected_blob_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(protected_blob_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  protected_blob_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<protected_blob_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const protected_blob_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const protected_blob_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(protected_blob_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protected_blob_message";
  }
  protected:
  explicit protected_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedKeyFieldNumber = 1,
    kEncryptedDataFieldNumber = 2,
  };
  // optional bytes encrypted_key = 1;
  bool has_encrypted_key() const;
  private:
  bool _internal_has_encrypted_key() const;
  public:
  void clear_encrypted_key();
  const std::string& encrypted_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_key();
  PROTOBUF_NODISCARD std::string* release_encrypted_key();
  void set_allocated_encrypted_key(std::string* encrypted_key);
  private:
  const std::string& _internal_encrypted_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_key(const std::string& value);
  std::string* _internal_mutable_encrypted_key();
  public:

  // optional bytes encrypted_data = 2;
  bool has_encrypted_data() const;
  private:
  bool _internal_has_encrypted_data() const;
  public:
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_data();
  PROTOBUF_NODISCARD std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:protected_blob_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class entity_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:entity_message) */ {
 public:
  inline entity_message() : entity_message(nullptr) {}
  ~entity_message() override;
  explicit constexpr entity_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  entity_message(const entity_message& from);
  entity_message(entity_message&& from) noexcept
    : entity_message() {
    *this = ::std::move(from);
  }

  inline entity_message& operator=(const entity_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline entity_message& operator=(entity_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const entity_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const entity_message* internal_default_instance() {
    return reinterpret_cast<const entity_message*>(
               &_entity_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(entity_message& a, entity_message& b) {
    a.Swap(&b);
  }
  inline void Swap(entity_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(entity_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  entity_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<entity_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const entity_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const entity_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(entity_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "entity_message";
  }
  protected:
  explicit entity_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityTypeFieldNumber = 1,
    kMeasurementFieldNumber = 3,
    kKeyFieldNumber = 2,
  };
  // optional string entity_type = 1;
  bool has_entity_type() const;
  private:
  bool _internal_has_entity_type() const;
  public:
  void clear_entity_type();
  const std::string& entity_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity_type();
  PROTOBUF_NODISCARD std::string* release_entity_type();
  void set_allocated_entity_type(std::string* entity_type);
  private:
  const std::string& _internal_entity_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const std::string& value);
  std::string* _internal_mutable_entity_type();
  public:

  // optional bytes measurement = 3;
  bool has_measurement() const;
  private:
  bool _internal_has_measurement() const;
  public:
  void clear_measurement();
  const std::string& measurement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_measurement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_measurement();
  PROTOBUF_NODISCARD std::string* release_measurement();
  void set_allocated_measurement(std::string* measurement);
  private:
  const std::string& _internal_measurement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_measurement(const std::string& value);
  std::string* _internal_mutable_measurement();
  public:

  // optional .key_message key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::key_message& key() const;
  PROTOBUF_NODISCARD ::key_message* release_key();
  ::key_message* mutable_key();
  void set_allocated_key(::key_message* key);
  private:
  const ::key_message& _internal_key() const;
  ::key_message* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::key_message* key);
  ::key_message* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:entity_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr measurement_;
  ::key_message* key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class vse_clause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vse_clause) */ {
 public:
  inline vse_clause() : vse_clause(nullptr) {}
  ~vse_clause() override;
  explicit constexpr vse_clause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vse_clause(const vse_clause& from);
  vse_clause(vse_clause&& from) noexcept
    : vse_clause() {
    *this = ::std::move(from);
  }

  inline vse_clause& operator=(const vse_clause& from) {
    CopyFrom(from);
    return *this;
  }
  inline vse_clause& operator=(vse_clause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const vse_clause& default_instance() {
    return *internal_default_instance();
  }
  static inline const vse_clause* internal_default_instance() {
    return reinterpret_cast<const vse_clause*>(
               &_vse_clause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(vse_clause& a, vse_clause& b) {
    a.Swap(&b);
  }
  inline void Swap(vse_clause* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vse_clause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vse_clause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vse_clause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const vse_clause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const vse_clause& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vse_clause* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vse_clause";
  }
  protected:
  explicit vse_clause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerbFieldNumber = 2,
    kSubjectFieldNumber = 1,
    kObjectFieldNumber = 3,
    kClauseFieldNumber = 4,
  };
  // optional string verb = 2;
  bool has_verb() const;
  private:
  bool _internal_has_verb() const;
  public:
  void clear_verb();
  const std::string& verb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verb();
  PROTOBUF_NODISCARD std::string* release_verb();
  void set_allocated_verb(std::string* verb);
  private:
  const std::string& _internal_verb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verb(const std::string& value);
  std::string* _internal_mutable_verb();
  public:

  // optional .entity_message subject = 1;
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::entity_message& subject() const;
  PROTOBUF_NODISCARD ::entity_message* release_subject();
  ::entity_message* mutable_subject();
  void set_allocated_subject(::entity_message* subject);
  private:
  const ::entity_message& _internal_subject() const;
  ::entity_message* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::entity_message* subject);
  ::entity_message* unsafe_arena_release_subject();

  // optional .entity_message object = 3;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::entity_message& object() const;
  PROTOBUF_NODISCARD ::entity_message* release_object();
  ::entity_message* mutable_object();
  void set_allocated_object(::entity_message* object);
  private:
  const ::entity_message& _internal_object() const;
  ::entity_message* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::entity_message* object);
  ::entity_message* unsafe_arena_release_object();

  // optional .vse_clause clause = 4;
  bool has_clause() const;
  private:
  bool _internal_has_clause() const;
  public:
  void clear_clause();
  const ::vse_clause& clause() const;
  PROTOBUF_NODISCARD ::vse_clause* release_clause();
  ::vse_clause* mutable_clause();
  void set_allocated_clause(::vse_clause* clause);
  private:
  const ::vse_clause& _internal_clause() const;
  ::vse_clause* _internal_mutable_clause();
  public:
  void unsafe_arena_set_allocated_clause(
      ::vse_clause* clause);
  ::vse_clause* unsafe_arena_release_clause();

  // @@protoc_insertion_point(class_scope:vse_clause)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verb_;
  ::entity_message* subject_;
  ::entity_message* object_;
  ::vse_clause* clause_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class vse_clauses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vse_clauses) */ {
 public:
  inline vse_clauses() : vse_clauses(nullptr) {}
  ~vse_clauses() override;
  explicit constexpr vse_clauses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vse_clauses(const vse_clauses& from);
  vse_clauses(vse_clauses&& from) noexcept
    : vse_clauses() {
    *this = ::std::move(from);
  }

  inline vse_clauses& operator=(const vse_clauses& from) {
    CopyFrom(from);
    return *this;
  }
  inline vse_clauses& operator=(vse_clauses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const vse_clauses& default_instance() {
    return *internal_default_instance();
  }
  static inline const vse_clauses* internal_default_instance() {
    return reinterpret_cast<const vse_clauses*>(
               &_vse_clauses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(vse_clauses& a, vse_clauses& b) {
    a.Swap(&b);
  }
  inline void Swap(vse_clauses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vse_clauses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vse_clauses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vse_clauses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const vse_clauses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const vse_clauses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vse_clauses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vse_clauses";
  }
  protected:
  explicit vse_clauses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClausesFieldNumber = 1,
  };
  // repeated .vse_clause clauses = 1;
  int clauses_size() const;
  private:
  int _internal_clauses_size() const;
  public:
  void clear_clauses();
  ::vse_clause* mutable_clauses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_clauses();
  private:
  const ::vse_clause& _internal_clauses(int index) const;
  ::vse_clause* _internal_add_clauses();
  public:
  const ::vse_clause& clauses(int index) const;
  ::vse_clause* add_clauses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      clauses() const;

  // @@protoc_insertion_point(class_scope:vse_clauses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > clauses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class attestation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:attestation) */ {
 public:
  inline attestation() : attestation(nullptr) {}
  ~attestation() override;
  explicit constexpr attestation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  attestation(const attestation& from);
  attestation(attestation&& from) noexcept
    : attestation() {
    *this = ::std::move(from);
  }

  inline attestation& operator=(const attestation& from) {
    CopyFrom(from);
    return *this;
  }
  inline attestation& operator=(attestation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const attestation& default_instance() {
    return *internal_default_instance();
  }
  static inline const attestation* internal_default_instance() {
    return reinterpret_cast<const attestation*>(
               &_attestation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(attestation& a, attestation& b) {
    a.Swap(&b);
  }
  inline void Swap(attestation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(attestation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  attestation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<attestation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const attestation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const attestation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(attestation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "attestation";
  }
  protected:
  explicit attestation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnclaveTypeFieldNumber = 1,
    kKeyIdFieldNumber = 2,
    kMeasurementFieldNumber = 3,
    kTimeFieldNumber = 4,
    kDescriptionFieldNumber = 6,
    kClauseFieldNumber = 5,
  };
  // optional string enclave_type = 1;
  bool has_enclave_type() const;
  private:
  bool _internal_has_enclave_type() const;
  public:
  void clear_enclave_type();
  const std::string& enclave_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enclave_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enclave_type();
  PROTOBUF_NODISCARD std::string* release_enclave_type();
  void set_allocated_enclave_type(std::string* enclave_type);
  private:
  const std::string& _internal_enclave_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enclave_type(const std::string& value);
  std::string* _internal_mutable_enclave_type();
  public:

  // optional string key_id = 2;
  bool has_key_id() const;
  private:
  bool _internal_has_key_id() const;
  public:
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // optional bytes measurement = 3;
  bool has_measurement() const;
  private:
  bool _internal_has_measurement() const;
  public:
  void clear_measurement();
  const std::string& measurement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_measurement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_measurement();
  PROTOBUF_NODISCARD std::string* release_measurement();
  void set_allocated_measurement(std::string* measurement);
  private:
  const std::string& _internal_measurement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_measurement(const std::string& value);
  std::string* _internal_mutable_measurement();
  public:

  // optional string time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // optional string description = 6;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .vse_clause clause = 5;
  bool has_clause() const;
  private:
  bool _internal_has_clause() const;
  public:
  void clear_clause();
  const ::vse_clause& clause() const;
  PROTOBUF_NODISCARD ::vse_clause* release_clause();
  ::vse_clause* mutable_clause();
  void set_allocated_clause(::vse_clause* clause);
  private:
  const ::vse_clause& _internal_clause() const;
  ::vse_clause* _internal_mutable_clause();
  public:
  void unsafe_arena_set_allocated_clause(
      ::vse_clause* clause);
  ::vse_clause* unsafe_arena_release_clause();

  // @@protoc_insertion_point(class_scope:attestation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enclave_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr measurement_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::vse_clause* clause_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class claim_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:claim_message) */ {
 public:
  inline claim_message() : claim_message(nullptr) {}
  ~claim_message() override;
  explicit constexpr claim_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  claim_message(const claim_message& from);
  claim_message(claim_message&& from) noexcept
    : claim_message() {
    *this = ::std::move(from);
  }

  inline claim_message& operator=(const claim_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline claim_message& operator=(claim_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const claim_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const claim_message* internal_default_instance() {
    return reinterpret_cast<const claim_message*>(
               &_claim_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(claim_message& a, claim_message& b) {
    a.Swap(&b);
  }
  inline void Swap(claim_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(claim_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  claim_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<claim_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const claim_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const claim_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(claim_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "claim_message";
  }
  protected:
  explicit claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimFormatFieldNumber = 1,
    kClaimDescriptorFieldNumber = 2,
    kNotBeforeFieldNumber = 3,
    kNotAfterFieldNumber = 4,
    kSerializedClaimFieldNumber = 5,
  };
  // optional string claim_format = 1;
  bool has_claim_format() const;
  private:
  bool _internal_has_claim_format() const;
  public:
  void clear_claim_format();
  const std::string& claim_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_claim_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_claim_format();
  PROTOBUF_NODISCARD std::string* release_claim_format();
  void set_allocated_claim_format(std::string* claim_format);
  private:
  const std::string& _internal_claim_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_claim_format(const std::string& value);
  std::string* _internal_mutable_claim_format();
  public:

  // optional string claim_descriptor = 2;
  bool has_claim_descriptor() const;
  private:
  bool _internal_has_claim_descriptor() const;
  public:
  void clear_claim_descriptor();
  const std::string& claim_descriptor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_claim_descriptor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_claim_descriptor();
  PROTOBUF_NODISCARD std::string* release_claim_descriptor();
  void set_allocated_claim_descriptor(std::string* claim_descriptor);
  private:
  const std::string& _internal_claim_descriptor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_claim_descriptor(const std::string& value);
  std::string* _internal_mutable_claim_descriptor();
  public:

  // optional string not_before = 3;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const std::string& not_before() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_before(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_before();
  PROTOBUF_NODISCARD std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);
  private:
  const std::string& _internal_not_before() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_before(const std::string& value);
  std::string* _internal_mutable_not_before();
  public:

  // optional string not_after = 4;
  bool has_not_after() const;
  private:
  bool _internal_has_not_after() const;
  public:
  void clear_not_after();
  const std::string& not_after() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_after(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_after();
  PROTOBUF_NODISCARD std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);
  private:
  const std::string& _internal_not_after() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_after(const std::string& value);
  std::string* _internal_mutable_not_after();
  public:

  // optional bytes serialized_claim = 5;
  bool has_serialized_claim() const;
  private:
  bool _internal_has_serialized_claim() const;
  public:
  void clear_serialized_claim();
  const std::string& serialized_claim() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_claim(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_claim();
  PROTOBUF_NODISCARD std::string* release_serialized_claim();
  void set_allocated_serialized_claim(std::string* serialized_claim);
  private:
  const std::string& _internal_serialized_claim() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_claim(const std::string& value);
  std::string* _internal_mutable_serialized_claim();
  public:

  // @@protoc_insertion_point(class_scope:claim_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claim_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claim_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_claim_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class signed_claim_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signed_claim_message) */ {
 public:
  inline signed_claim_message() : signed_claim_message(nullptr) {}
  ~signed_claim_message() override;
  explicit constexpr signed_claim_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  signed_claim_message(const signed_claim_message& from);
  signed_claim_message(signed_claim_message&& from) noexcept
    : signed_claim_message() {
    *this = ::std::move(from);
  }

  inline signed_claim_message& operator=(const signed_claim_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline signed_claim_message& operator=(signed_claim_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const signed_claim_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const signed_claim_message* internal_default_instance() {
    return reinterpret_cast<const signed_claim_message*>(
               &_signed_claim_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(signed_claim_message& a, signed_claim_message& b) {
    a.Swap(&b);
  }
  inline void Swap(signed_claim_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(signed_claim_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  signed_claim_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<signed_claim_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const signed_claim_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const signed_claim_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signed_claim_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signed_claim_message";
  }
  protected:
  explicit signed_claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedClaimMessageFieldNumber = 1,
    kSigningAlgorithmFieldNumber = 3,
    kSignatureFieldNumber = 4,
    kSigningKeyFieldNumber = 2,
  };
  // optional bytes serialized_claim_message = 1;
  bool has_serialized_claim_message() const;
  private:
  bool _internal_has_serialized_claim_message() const;
  public:
  void clear_serialized_claim_message();
  const std::string& serialized_claim_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_claim_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_claim_message();
  PROTOBUF_NODISCARD std::string* release_serialized_claim_message();
  void set_allocated_serialized_claim_message(std::string* serialized_claim_message);
  private:
  const std::string& _internal_serialized_claim_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_claim_message(const std::string& value);
  std::string* _internal_mutable_serialized_claim_message();
  public:

  // optional string signing_algorithm = 3;
  bool has_signing_algorithm() const;
  private:
  bool _internal_has_signing_algorithm() const;
  public:
  void clear_signing_algorithm();
  const std::string& signing_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signing_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signing_algorithm();
  PROTOBUF_NODISCARD std::string* release_signing_algorithm();
  void set_allocated_signing_algorithm(std::string* signing_algorithm);
  private:
  const std::string& _internal_signing_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signing_algorithm(const std::string& value);
  std::string* _internal_mutable_signing_algorithm();
  public:

  // optional bytes signature = 4;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .key_message signing_key = 2;
  bool has_signing_key() const;
  private:
  bool _internal_has_signing_key() const;
  public:
  void clear_signing_key();
  const ::key_message& signing_key() const;
  PROTOBUF_NODISCARD ::key_message* release_signing_key();
  ::key_message* mutable_signing_key();
  void set_allocated_signing_key(::key_message* signing_key);
  private:
  const ::key_message& _internal_signing_key() const;
  ::key_message* _internal_mutable_signing_key();
  public:
  void unsafe_arena_set_allocated_signing_key(
      ::key_message* signing_key);
  ::key_message* unsafe_arena_release_signing_key();

  // @@protoc_insertion_point(class_scope:signed_claim_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_claim_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signing_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::key_message* signing_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class oe_assertion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oe_assertion) */ {
 public:
  inline oe_assertion() : oe_assertion(nullptr) {}
  ~oe_assertion() override;
  explicit constexpr oe_assertion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  oe_assertion(const oe_assertion& from);
  oe_assertion(oe_assertion&& from) noexcept
    : oe_assertion() {
    *this = ::std::move(from);
  }

  inline oe_assertion& operator=(const oe_assertion& from) {
    CopyFrom(from);
    return *this;
  }
  inline oe_assertion& operator=(oe_assertion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const oe_assertion& default_instance() {
    return *internal_default_instance();
  }
  static inline const oe_assertion* internal_default_instance() {
    return reinterpret_cast<const oe_assertion*>(
               &_oe_assertion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(oe_assertion& a, oe_assertion& b) {
    a.Swap(&b);
  }
  inline void Swap(oe_assertion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(oe_assertion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  oe_assertion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<oe_assertion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const oe_assertion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const oe_assertion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oe_assertion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oe_assertion";
  }
  protected:
  explicit oe_assertion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 1,
    kOeReportFieldNumber = 2,
  };
  // optional bytes user_data = 1;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const std::string& user_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_data();
  PROTOBUF_NODISCARD std::string* release_user_data();
  void set_allocated_user_data(std::string* user_data);
  private:
  const std::string& _internal_user_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_data(const std::string& value);
  std::string* _internal_mutable_user_data();
  public:

  // optional bytes oe_report = 2;
  bool has_oe_report() const;
  private:
  bool _internal_has_oe_report() const;
  public:
  void clear_oe_report();
  const std::string& oe_report() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oe_report(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oe_report();
  PROTOBUF_NODISCARD std::string* release_oe_report();
  void set_allocated_oe_report(std::string* oe_report);
  private:
  const std::string& _internal_oe_report() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oe_report(const std::string& value);
  std::string* _internal_mutable_oe_report();
  public:

  // @@protoc_insertion_point(class_scope:oe_assertion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oe_report_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class evidence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:evidence) */ {
 public:
  inline evidence() : evidence(nullptr) {}
  ~evidence() override;
  explicit constexpr evidence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  evidence(const evidence& from);
  evidence(evidence&& from) noexcept
    : evidence() {
    *this = ::std::move(from);
  }

  inline evidence& operator=(const evidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline evidence& operator=(evidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const evidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const evidence* internal_default_instance() {
    return reinterpret_cast<const evidence*>(
               &_evidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(evidence& a, evidence& b) {
    a.Swap(&b);
  }
  inline void Swap(evidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(evidence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  evidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<evidence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const evidence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const evidence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(evidence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "evidence";
  }
  protected:
  explicit evidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEvidenceTypeFieldNumber = 1,
    kSerializedEvidenceFieldNumber = 2,
  };
  // optional string evidence_type = 1;
  bool has_evidence_type() const;
  private:
  bool _internal_has_evidence_type() const;
  public:
  void clear_evidence_type();
  const std::string& evidence_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_evidence_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_evidence_type();
  PROTOBUF_NODISCARD std::string* release_evidence_type();
  void set_allocated_evidence_type(std::string* evidence_type);
  private:
  const std::string& _internal_evidence_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_evidence_type(const std::string& value);
  std::string* _internal_mutable_evidence_type();
  public:

  // optional bytes serialized_evidence = 2;
  bool has_serialized_evidence() const;
  private:
  bool _internal_has_serialized_evidence() const;
  public:
  void clear_serialized_evidence();
  const std::string& serialized_evidence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_evidence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_evidence();
  PROTOBUF_NODISCARD std::string* release_serialized_evidence();
  void set_allocated_serialized_evidence(std::string* serialized_evidence);
  private:
  const std::string& _internal_serialized_evidence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_evidence(const std::string& value);
  std::string* _internal_mutable_serialized_evidence();
  public:

  // @@protoc_insertion_point(class_scope:evidence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr evidence_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_evidence_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class evidence_package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:evidence_package) */ {
 public:
  inline evidence_package() : evidence_package(nullptr) {}
  ~evidence_package() override;
  explicit constexpr evidence_package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  evidence_package(const evidence_package& from);
  evidence_package(evidence_package&& from) noexcept
    : evidence_package() {
    *this = ::std::move(from);
  }

  inline evidence_package& operator=(const evidence_package& from) {
    CopyFrom(from);
    return *this;
  }
  inline evidence_package& operator=(evidence_package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const evidence_package& default_instance() {
    return *internal_default_instance();
  }
  static inline const evidence_package* internal_default_instance() {
    return reinterpret_cast<const evidence_package*>(
               &_evidence_package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(evidence_package& a, evidence_package& b) {
    a.Swap(&b);
  }
  inline void Swap(evidence_package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(evidence_package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  evidence_package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<evidence_package>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const evidence_package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const evidence_package& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(evidence_package* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "evidence_package";
  }
  protected:
  explicit evidence_package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactAssertionFieldNumber = 2,
    kProverTypeFieldNumber = 1,
  };
  // repeated .evidence fact_assertion = 2;
  int fact_assertion_size() const;
  private:
  int _internal_fact_assertion_size() const;
  public:
  void clear_fact_assertion();
  ::evidence* mutable_fact_assertion(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
      mutable_fact_assertion();
  private:
  const ::evidence& _internal_fact_assertion(int index) const;
  ::evidence* _internal_add_fact_assertion();
  public:
  const ::evidence& fact_assertion(int index) const;
  ::evidence* add_fact_assertion();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
      fact_assertion() const;

  // optional string prover_type = 1;
  bool has_prover_type() const;
  private:
  bool _internal_has_prover_type() const;
  public:
  void clear_prover_type();
  const std::string& prover_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_type();
  PROTOBUF_NODISCARD std::string* release_prover_type();
  void set_allocated_prover_type(std::string* prover_type);
  private:
  const std::string& _internal_prover_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_type(const std::string& value);
  std::string* _internal_mutable_prover_type();
  public:

  // @@protoc_insertion_point(class_scope:evidence_package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence > fact_assertion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_type_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class certifier_rules final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:certifier_rules) */ {
 public:
  inline certifier_rules() : certifier_rules(nullptr) {}
  ~certifier_rules() override;
  explicit constexpr certifier_rules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  certifier_rules(const certifier_rules& from);
  certifier_rules(certifier_rules&& from) noexcept
    : certifier_rules() {
    *this = ::std::move(from);
  }

  inline certifier_rules& operator=(const certifier_rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline certifier_rules& operator=(certifier_rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const certifier_rules& default_instance() {
    return *internal_default_instance();
  }
  static inline const certifier_rules* internal_default_instance() {
    return reinterpret_cast<const certifier_rules*>(
               &_certifier_rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(certifier_rules& a, certifier_rules& b) {
    a.Swap(&b);
  }
  inline void Swap(certifier_rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(certifier_rules* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  certifier_rules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<certifier_rules>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const certifier_rules& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const certifier_rules& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(certifier_rules* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "certifier_rules";
  }
  protected:
  explicit certifier_rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
  };
  // repeated string rule = 1;
  int rule_size() const;
  private:
  int _internal_rule_size() const;
  public:
  void clear_rule();
  const std::string& rule(int index) const;
  std::string* mutable_rule(int index);
  void set_rule(int index, const std::string& value);
  void set_rule(int index, std::string&& value);
  void set_rule(int index, const char* value);
  void set_rule(int index, const char* value, size_t size);
  std::string* add_rule();
  void add_rule(const std::string& value);
  void add_rule(std::string&& value);
  void add_rule(const char* value);
  void add_rule(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rule();
  private:
  const std::string& _internal_rule(int index) const;
  std::string* _internal_add_rule();
  public:

  // @@protoc_insertion_point(class_scope:certifier_rules)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proved_statements final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proved_statements) */ {
 public:
  inline proved_statements() : proved_statements(nullptr) {}
  ~proved_statements() override;
  explicit constexpr proved_statements(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  proved_statements(const proved_statements& from);
  proved_statements(proved_statements&& from) noexcept
    : proved_statements() {
    *this = ::std::move(from);
  }

  inline proved_statements& operator=(const proved_statements& from) {
    CopyFrom(from);
    return *this;
  }
  inline proved_statements& operator=(proved_statements&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const proved_statements& default_instance() {
    return *internal_default_instance();
  }
  static inline const proved_statements* internal_default_instance() {
    return reinterpret_cast<const proved_statements*>(
               &_proved_statements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(proved_statements& a, proved_statements& b) {
    a.Swap(&b);
  }
  inline void Swap(proved_statements* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(proved_statements* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  proved_statements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<proved_statements>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const proved_statements& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const proved_statements& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proved_statements* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proved_statements";
  }
  protected:
  explicit proved_statements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvedFieldNumber = 1,
  };
  // repeated .vse_clause proved = 1;
  int proved_size() const;
  private:
  int _internal_proved_size() const;
  public:
  void clear_proved();
  ::vse_clause* mutable_proved(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_proved();
  private:
  const ::vse_clause& _internal_proved(int index) const;
  ::vse_clause* _internal_add_proved();
  public:
  const ::vse_clause& proved(int index) const;
  ::vse_clause* add_proved();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      proved() const;

  // @@protoc_insertion_point(class_scope:proved_statements)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > proved_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proof_step final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proof_step) */ {
 public:
  inline proof_step() : proof_step(nullptr) {}
  ~proof_step() override;
  explicit constexpr proof_step(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  proof_step(const proof_step& from);
  proof_step(proof_step&& from) noexcept
    : proof_step() {
    *this = ::std::move(from);
  }

  inline proof_step& operator=(const proof_step& from) {
    CopyFrom(from);
    return *this;
  }
  inline proof_step& operator=(proof_step&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const proof_step& default_instance() {
    return *internal_default_instance();
  }
  static inline const proof_step* internal_default_instance() {
    return reinterpret_cast<const proof_step*>(
               &_proof_step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(proof_step& a, proof_step& b) {
    a.Swap(&b);
  }
  inline void Swap(proof_step* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(proof_step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  proof_step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<proof_step>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const proof_step& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const proof_step& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proof_step* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proof_step";
  }
  protected:
  explicit proof_step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kConclusionFieldNumber = 3,
    kRuleAppliedFieldNumber = 4,
  };
  // optional .vse_clause s1 = 1;
  bool has_s1() const;
  private:
  bool _internal_has_s1() const;
  public:
  void clear_s1();
  const ::vse_clause& s1() const;
  PROTOBUF_NODISCARD ::vse_clause* release_s1();
  ::vse_clause* mutable_s1();
  void set_allocated_s1(::vse_clause* s1);
  private:
  const ::vse_clause& _internal_s1() const;
  ::vse_clause* _internal_mutable_s1();
  public:
  void unsafe_arena_set_allocated_s1(
      ::vse_clause* s1);
  ::vse_clause* unsafe_arena_release_s1();

  // optional .vse_clause s2 = 2;
  bool has_s2() const;
  private:
  bool _internal_has_s2() const;
  public:
  void clear_s2();
  const ::vse_clause& s2() const;
  PROTOBUF_NODISCARD ::vse_clause* release_s2();
  ::vse_clause* mutable_s2();
  void set_allocated_s2(::vse_clause* s2);
  private:
  const ::vse_clause& _internal_s2() const;
  ::vse_clause* _internal_mutable_s2();
  public:
  void unsafe_arena_set_allocated_s2(
      ::vse_clause* s2);
  ::vse_clause* unsafe_arena_release_s2();

  // optional .vse_clause conclusion = 3;
  bool has_conclusion() const;
  private:
  bool _internal_has_conclusion() const;
  public:
  void clear_conclusion();
  const ::vse_clause& conclusion() const;
  PROTOBUF_NODISCARD ::vse_clause* release_conclusion();
  ::vse_clause* mutable_conclusion();
  void set_allocated_conclusion(::vse_clause* conclusion);
  private:
  const ::vse_clause& _internal_conclusion() const;
  ::vse_clause* _internal_mutable_conclusion();
  public:
  void unsafe_arena_set_allocated_conclusion(
      ::vse_clause* conclusion);
  ::vse_clause* unsafe_arena_release_conclusion();

  // optional int32 rule_applied = 4;
  bool has_rule_applied() const;
  private:
  bool _internal_has_rule_applied() const;
  public:
  void clear_rule_applied();
  int32_t rule_applied() const;
  void set_rule_applied(int32_t value);
  private:
  int32_t _internal_rule_applied() const;
  void _internal_set_rule_applied(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proof_step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::vse_clause* s1_;
  ::vse_clause* s2_;
  ::vse_clause* conclusion_;
  int32_t rule_applied_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proof) */ {
 public:
  inline proof() : proof(nullptr) {}
  ~proof() override;
  explicit constexpr proof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  proof(const proof& from);
  proof(proof&& from) noexcept
    : proof() {
    *this = ::std::move(from);
  }

  inline proof& operator=(const proof& from) {
    CopyFrom(from);
    return *this;
  }
  inline proof& operator=(proof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const proof& default_instance() {
    return *internal_default_instance();
  }
  static inline const proof* internal_default_instance() {
    return reinterpret_cast<const proof*>(
               &_proof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(proof& a, proof& b) {
    a.Swap(&b);
  }
  inline void Swap(proof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(proof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  proof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<proof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const proof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const proof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proof";
  }
  protected:
  explicit proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlreadyProvedFieldNumber = 2,
    kStepsFieldNumber = 3,
    kToProveFieldNumber = 1,
  };
  // repeated .vse_clause already_proved = 2;
  int already_proved_size() const;
  private:
  int _internal_already_proved_size() const;
  public:
  void clear_already_proved();
  ::vse_clause* mutable_already_proved(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_already_proved();
  private:
  const ::vse_clause& _internal_already_proved(int index) const;
  ::vse_clause* _internal_add_already_proved();
  public:
  const ::vse_clause& already_proved(int index) const;
  ::vse_clause* add_already_proved();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      already_proved() const;

  // repeated .proof_step steps = 3;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::proof_step* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >*
      mutable_steps();
  private:
  const ::proof_step& _internal_steps(int index) const;
  ::proof_step* _internal_add_steps();
  public:
  const ::proof_step& steps(int index) const;
  ::proof_step* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >&
      steps() const;

  // optional .vse_clause to_prove = 1;
  bool has_to_prove() const;
  private:
  bool _internal_has_to_prove() const;
  public:
  void clear_to_prove();
  const ::vse_clause& to_prove() const;
  PROTOBUF_NODISCARD ::vse_clause* release_to_prove();
  ::vse_clause* mutable_to_prove();
  void set_allocated_to_prove(::vse_clause* to_prove);
  private:
  const ::vse_clause& _internal_to_prove() const;
  ::vse_clause* _internal_mutable_to_prove();
  public:
  void unsafe_arena_set_allocated_to_prove(
      ::vse_clause* to_prove);
  ::vse_clause* unsafe_arena_release_to_prove();

  // @@protoc_insertion_point(class_scope:proof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > already_proved_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step > steps_;
  ::vse_clause* to_prove_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trust_request_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trust_request_message) */ {
 public:
  inline trust_request_message() : trust_request_message(nullptr) {}
  ~trust_request_message() override;
  explicit constexpr trust_request_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  trust_request_message(const trust_request_message& from);
  trust_request_message(trust_request_message&& from) noexcept
    : trust_request_message() {
    *this = ::std::move(from);
  }

  inline trust_request_message& operator=(const trust_request_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trust_request_message& operator=(trust_request_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const trust_request_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const trust_request_message* internal_default_instance() {
    return reinterpret_cast<const trust_request_message*>(
               &_trust_request_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(trust_request_message& a, trust_request_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trust_request_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(trust_request_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  trust_request_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<trust_request_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const trust_request_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const trust_request_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trust_request_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trust_request_message";
  }
  protected:
  explicit trust_request_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestingEnclaveTagFieldNumber = 1,
    kProvidingEnclaveTagFieldNumber = 2,
    kSubmittedEvidenceTypeFieldNumber = 3,
    kPurposeFieldNumber = 4,
    kSupportFieldNumber = 5,
  };
  // optional string requesting_enclave_tag = 1;
  bool has_requesting_enclave_tag() const;
  private:
  bool _internal_has_requesting_enclave_tag() const;
  public:
  void clear_requesting_enclave_tag();
  const std::string& requesting_enclave_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_enclave_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_enclave_tag();
  PROTOBUF_NODISCARD std::string* release_requesting_enclave_tag();
  void set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag);
  private:
  const std::string& _internal_requesting_enclave_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_enclave_tag(const std::string& value);
  std::string* _internal_mutable_requesting_enclave_tag();
  public:

  // optional string providing_enclave_tag = 2;
  bool has_providing_enclave_tag() const;
  private:
  bool _internal_has_providing_enclave_tag() const;
  public:
  void clear_providing_enclave_tag();
  const std::string& providing_enclave_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_providing_enclave_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_providing_enclave_tag();
  PROTOBUF_NODISCARD std::string* release_providing_enclave_tag();
  void set_allocated_providing_enclave_tag(std::string* providing_enclave_tag);
  private:
  const std::string& _internal_providing_enclave_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_providing_enclave_tag(const std::string& value);
  std::string* _internal_mutable_providing_enclave_tag();
  public:

  // optional string submitted_evidence_type = 3;
  bool has_submitted_evidence_type() const;
  private:
  bool _internal_has_submitted_evidence_type() const;
  public:
  void clear_submitted_evidence_type();
  const std::string& submitted_evidence_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_submitted_evidence_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_submitted_evidence_type();
  PROTOBUF_NODISCARD std::string* release_submitted_evidence_type();
  void set_allocated_submitted_evidence_type(std::string* submitted_evidence_type);
  private:
  const std::string& _internal_submitted_evidence_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_submitted_evidence_type(const std::string& value);
  std::string* _internal_mutable_submitted_evidence_type();
  public:

  // optional string purpose = 4;
  bool has_purpose() const;
  private:
  bool _internal_has_purpose() const;
  public:
  void clear_purpose();
  const std::string& purpose() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purpose(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purpose();
  PROTOBUF_NODISCARD std::string* release_purpose();
  void set_allocated_purpose(std::string* purpose);
  private:
  const std::string& _internal_purpose() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purpose(const std::string& value);
  std::string* _internal_mutable_purpose();
  public:

  // optional .evidence_package support = 5;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  const ::evidence_package& support() const;
  PROTOBUF_NODISCARD ::evidence_package* release_support();
  ::evidence_package* mutable_support();
  void set_allocated_support(::evidence_package* support);
  private:
  const ::evidence_package& _internal_support() const;
  ::evidence_package* _internal_mutable_support();
  public:
  void unsafe_arena_set_allocated_support(
      ::evidence_package* support);
  ::evidence_package* unsafe_arena_release_support();

  // @@protoc_insertion_point(class_scope:trust_request_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr providing_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr submitted_evidence_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purpose_;
  ::evidence_package* support_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trust_response_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trust_response_message) */ {
 public:
  inline trust_response_message() : trust_response_message(nullptr) {}
  ~trust_response_message() override;
  explicit constexpr trust_response_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  trust_response_message(const trust_response_message& from);
  trust_response_message(trust_response_message&& from) noexcept
    : trust_response_message() {
    *this = ::std::move(from);
  }

  inline trust_response_message& operator=(const trust_response_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trust_response_message& operator=(trust_response_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const trust_response_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const trust_response_message* internal_default_instance() {
    return reinterpret_cast<const trust_response_message*>(
               &_trust_response_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(trust_response_message& a, trust_response_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trust_response_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(trust_response_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  trust_response_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<trust_response_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const trust_response_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const trust_response_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trust_response_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trust_response_message";
  }
  protected:
  explicit trust_response_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kRequestingEnclaveTagFieldNumber = 2,
    kProvidingEnclaveTagFieldNumber = 3,
    kArtifactFieldNumber = 4,
  };
  // optional string status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string requesting_enclave_tag = 2;
  bool has_requesting_enclave_tag() const;
  private:
  bool _internal_has_requesting_enclave_tag() const;
  public:
  void clear_requesting_enclave_tag();
  const std::string& requesting_enclave_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_enclave_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_enclave_tag();
  PROTOBUF_NODISCARD std::string* release_requesting_enclave_tag();
  void set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag);
  private:
  const std::string& _internal_requesting_enclave_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_enclave_tag(const std::string& value);
  std::string* _internal_mutable_requesting_enclave_tag();
  public:

  // optional string providing_enclave_tag = 3;
  bool has_providing_enclave_tag() const;
  private:
  bool _internal_has_providing_enclave_tag() const;
  public:
  void clear_providing_enclave_tag();
  const std::string& providing_enclave_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_providing_enclave_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_providing_enclave_tag();
  PROTOBUF_NODISCARD std::string* release_providing_enclave_tag();
  void set_allocated_providing_enclave_tag(std::string* providing_enclave_tag);
  private:
  const std::string& _internal_providing_enclave_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_providing_enclave_tag(const std::string& value);
  std::string* _internal_mutable_providing_enclave_tag();
  public:

  // optional bytes artifact = 4;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const std::string& artifact() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact();
  PROTOBUF_NODISCARD std::string* release_artifact();
  void set_allocated_artifact(std::string* artifact);
  private:
  const std::string& _internal_artifact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact(const std::string& value);
  std::string* _internal_mutable_artifact();
  public:

  // @@protoc_insertion_point(class_scope:trust_response_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr providing_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class storage_info_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:storage_info_message) */ {
 public:
  inline storage_info_message() : storage_info_message(nullptr) {}
  ~storage_info_message() override;
  explicit constexpr storage_info_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  storage_info_message(const storage_info_message& from);
  storage_info_message(storage_info_message&& from) noexcept
    : storage_info_message() {
    *this = ::std::move(from);
  }

  inline storage_info_message& operator=(const storage_info_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline storage_info_message& operator=(storage_info_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const storage_info_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const storage_info_message* internal_default_instance() {
    return reinterpret_cast<const storage_info_message*>(
               &_storage_info_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(storage_info_message& a, storage_info_message& b) {
    a.Swap(&b);
  }
  inline void Swap(storage_info_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(storage_info_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  storage_info_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<storage_info_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const storage_info_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const storage_info_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(storage_info_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "storage_info_message";
  }
  protected:
  explicit storage_info_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageTypeFieldNumber = 1,
    kStorageDescriptorFieldNumber = 2,
    kAddressFieldNumber = 3,
    kTagFieldNumber = 5,
    kStorageKeyFieldNumber = 4,
  };
  // optional string storage_type = 1;
  bool has_storage_type() const;
  private:
  bool _internal_has_storage_type() const;
  public:
  void clear_storage_type();
  const std::string& storage_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storage_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storage_type();
  PROTOBUF_NODISCARD std::string* release_storage_type();
  void set_allocated_storage_type(std::string* storage_type);
  private:
  const std::string& _internal_storage_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_type(const std::string& value);
  std::string* _internal_mutable_storage_type();
  public:

  // optional string storage_descriptor = 2;
  bool has_storage_descriptor() const;
  private:
  bool _internal_has_storage_descriptor() const;
  public:
  void clear_storage_descriptor();
  const std::string& storage_descriptor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storage_descriptor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storage_descriptor();
  PROTOBUF_NODISCARD std::string* release_storage_descriptor();
  void set_allocated_storage_descriptor(std::string* storage_descriptor);
  private:
  const std::string& _internal_storage_descriptor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_descriptor(const std::string& value);
  std::string* _internal_mutable_storage_descriptor();
  public:

  // optional string address = 3;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string tag = 5;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message storage_key = 4;
  bool has_storage_key() const;
  private:
  bool _internal_has_storage_key() const;
  public:
  void clear_storage_key();
  const ::key_message& storage_key() const;
  PROTOBUF_NODISCARD ::key_message* release_storage_key();
  ::key_message* mutable_storage_key();
  void set_allocated_storage_key(::key_message* storage_key);
  private:
  const ::key_message& _internal_storage_key() const;
  ::key_message* _internal_mutable_storage_key();
  public:
  void unsafe_arena_set_allocated_storage_key(
      ::key_message* storage_key);
  ::key_message* unsafe_arena_release_storage_key();

  // @@protoc_insertion_point(class_scope:storage_info_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* storage_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class channel_key_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:channel_key_message) */ {
 public:
  inline channel_key_message() : channel_key_message(nullptr) {}
  ~channel_key_message() override;
  explicit constexpr channel_key_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  channel_key_message(const channel_key_message& from);
  channel_key_message(channel_key_message&& from) noexcept
    : channel_key_message() {
    *this = ::std::move(from);
  }

  inline channel_key_message& operator=(const channel_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline channel_key_message& operator=(channel_key_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const channel_key_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const channel_key_message* internal_default_instance() {
    return reinterpret_cast<const channel_key_message*>(
               &_channel_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(channel_key_message& a, channel_key_message& b) {
    a.Swap(&b);
  }
  inline void Swap(channel_key_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(channel_key_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  channel_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<channel_key_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const channel_key_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const channel_key_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(channel_key_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "channel_key_message";
  }
  protected:
  explicit channel_key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kAuthKeyFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message auth_key = 2;
  bool has_auth_key() const;
  private:
  bool _internal_has_auth_key() const;
  public:
  void clear_auth_key();
  const ::key_message& auth_key() const;
  PROTOBUF_NODISCARD ::key_message* release_auth_key();
  ::key_message* mutable_auth_key();
  void set_allocated_auth_key(::key_message* auth_key);
  private:
  const ::key_message& _internal_auth_key() const;
  ::key_message* _internal_mutable_auth_key();
  public:
  void unsafe_arena_set_allocated_auth_key(
      ::key_message* auth_key);
  ::key_message* unsafe_arena_release_auth_key();

  // @@protoc_insertion_point(class_scope:channel_key_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* auth_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trusted_service_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trusted_service_message) */ {
 public:
  inline trusted_service_message() : trusted_service_message(nullptr) {}
  ~trusted_service_message() override;
  explicit constexpr trusted_service_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  trusted_service_message(const trusted_service_message& from);
  trusted_service_message(trusted_service_message&& from) noexcept
    : trusted_service_message() {
    *this = ::std::move(from);
  }

  inline trusted_service_message& operator=(const trusted_service_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trusted_service_message& operator=(trusted_service_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const trusted_service_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const trusted_service_message* internal_default_instance() {
    return reinterpret_cast<const trusted_service_message*>(
               &_trusted_service_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(trusted_service_message& a, trusted_service_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trusted_service_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(trusted_service_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  trusted_service_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<trusted_service_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const trusted_service_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const trusted_service_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trusted_service_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trusted_service_message";
  }
  protected:
  explicit trusted_service_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustedServiceAddressFieldNumber = 1,
    kTagFieldNumber = 3,
    kTrustedServiceKeyFieldNumber = 2,
  };
  // optional string trusted_service_address = 1;
  bool has_trusted_service_address() const;
  private:
  bool _internal_has_trusted_service_address() const;
  public:
  void clear_trusted_service_address();
  const std::string& trusted_service_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trusted_service_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trusted_service_address();
  PROTOBUF_NODISCARD std::string* release_trusted_service_address();
  void set_allocated_trusted_service_address(std::string* trusted_service_address);
  private:
  const std::string& _internal_trusted_service_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trusted_service_address(const std::string& value);
  std::string* _internal_mutable_trusted_service_address();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message trusted_service_key = 2;
  bool has_trusted_service_key() const;
  private:
  bool _internal_has_trusted_service_key() const;
  public:
  void clear_trusted_service_key();
  const ::key_message& trusted_service_key() const;
  PROTOBUF_NODISCARD ::key_message* release_trusted_service_key();
  ::key_message* mutable_trusted_service_key();
  void set_allocated_trusted_service_key(::key_message* trusted_service_key);
  private:
  const ::key_message& _internal_trusted_service_key() const;
  ::key_message* _internal_mutable_trusted_service_key();
  public:
  void unsafe_arena_set_allocated_trusted_service_key(
      ::key_message* trusted_service_key);
  ::key_message* unsafe_arena_release_trusted_service_key();

  // @@protoc_insertion_point(class_scope:trusted_service_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trusted_service_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* trusted_service_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_claim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_claim) */ {
 public:
  inline tagged_claim() : tagged_claim(nullptr) {}
  ~tagged_claim() override;
  explicit constexpr tagged_claim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  tagged_claim(const tagged_claim& from);
  tagged_claim(tagged_claim&& from) noexcept
    : tagged_claim() {
    *this = ::std::move(from);
  }

  inline tagged_claim& operator=(const tagged_claim& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_claim& operator=(tagged_claim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const tagged_claim& default_instance() {
    return *internal_default_instance();
  }
  static inline const tagged_claim* internal_default_instance() {
    return reinterpret_cast<const tagged_claim*>(
               &_tagged_claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(tagged_claim& a, tagged_claim& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_claim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(tagged_claim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  tagged_claim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<tagged_claim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const tagged_claim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const tagged_claim& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_claim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_claim";
  }
  protected:
  explicit tagged_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kClaimFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .claim_message claim = 2;
  bool has_claim() const;
  private:
  bool _internal_has_claim() const;
  public:
  void clear_claim();
  const ::claim_message& claim() const;
  PROTOBUF_NODISCARD ::claim_message* release_claim();
  ::claim_message* mutable_claim();
  void set_allocated_claim(::claim_message* claim);
  private:
  const ::claim_message& _internal_claim() const;
  ::claim_message* _internal_mutable_claim();
  public:
  void unsafe_arena_set_allocated_claim(
      ::claim_message* claim);
  ::claim_message* unsafe_arena_release_claim();

  // @@protoc_insertion_point(class_scope:tagged_claim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::claim_message* claim_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_claims_sequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_claims_sequence) */ {
 public:
  inline tagged_claims_sequence() : tagged_claims_sequence(nullptr) {}
  ~tagged_claims_sequence() override;
  explicit constexpr tagged_claims_sequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  tagged_claims_sequence(const tagged_claims_sequence& from);
  tagged_claims_sequence(tagged_claims_sequence&& from) noexcept
    : tagged_claims_sequence() {
    *this = ::std::move(from);
  }

  inline tagged_claims_sequence& operator=(const tagged_claims_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_claims_sequence& operator=(tagged_claims_sequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const tagged_claims_sequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const tagged_claims_sequence* internal_default_instance() {
    return reinterpret_cast<const tagged_claims_sequence*>(
               &_tagged_claims_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(tagged_claims_sequence& a, tagged_claims_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_claims_sequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(tagged_claims_sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  tagged_claims_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<tagged_claims_sequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const tagged_claims_sequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const tagged_claims_sequence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_claims_sequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_claims_sequence";
  }
  protected:
  explicit tagged_claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .tagged_claim claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::tagged_claim* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
      mutable_claims();
  private:
  const ::tagged_claim& _internal_claims(int index) const;
  ::tagged_claim* _internal_add_claims();
  public:
  const ::tagged_claim& claims(int index) const;
  ::tagged_claim* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
      claims() const;

  // @@protoc_insertion_point(class_scope:tagged_claims_sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim > claims_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class policy_store_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:policy_store_message) */ {
 public:
  inline policy_store_message() : policy_store_message(nullptr) {}
  ~policy_store_message() override;
  explicit constexpr policy_store_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  policy_store_message(const policy_store_message& from);
  policy_store_message(policy_store_message&& from) noexcept
    : policy_store_message() {
    *this = ::std::move(from);
  }

  inline policy_store_message& operator=(const policy_store_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline policy_store_message& operator=(policy_store_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const policy_store_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const policy_store_message* internal_default_instance() {
    return reinterpret_cast<const policy_store_message*>(
               &_policy_store_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(policy_store_message& a, policy_store_message& b) {
    a.Swap(&b);
  }
  inline void Swap(policy_store_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(policy_store_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  policy_store_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<policy_store_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const policy_store_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const policy_store_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(policy_store_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "policy_store_message";
  }
  protected:
  explicit policy_store_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustedServicesFieldNumber = 2,
    kChannelAuthenticationKeysFieldNumber = 3,
    kClaimsFieldNumber = 4,
    kStorageInfoFieldNumber = 5,
    kSignedClaimsFieldNumber = 6,
    kBlobsFieldNumber = 7,
    kPolicyKeyFieldNumber = 1,
  };
  // repeated .trusted_service_message trusted_services = 2;
  int trusted_services_size() const;
  private:
  int _internal_trusted_services_size() const;
  public:
  void clear_trusted_services();
  ::trusted_service_message* mutable_trusted_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >*
      mutable_trusted_services();
  private:
  const ::trusted_service_message& _internal_trusted_services(int index) const;
  ::trusted_service_message* _internal_add_trusted_services();
  public:
  const ::trusted_service_message& trusted_services(int index) const;
  ::trusted_service_message* add_trusted_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >&
      trusted_services() const;

  // repeated .channel_key_message channel_authentication_keys = 3;
  int channel_authentication_keys_size() const;
  private:
  int _internal_channel_authentication_keys_size() const;
  public:
  void clear_channel_authentication_keys();
  ::channel_key_message* mutable_channel_authentication_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >*
      mutable_channel_authentication_keys();
  private:
  const ::channel_key_message& _internal_channel_authentication_keys(int index) const;
  ::channel_key_message* _internal_add_channel_authentication_keys();
  public:
  const ::channel_key_message& channel_authentication_keys(int index) const;
  ::channel_key_message* add_channel_authentication_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >&
      channel_authentication_keys() const;

  // repeated .tagged_claim claims = 4;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::tagged_claim* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
      mutable_claims();
  private:
  const ::tagged_claim& _internal_claims(int index) const;
  ::tagged_claim* _internal_add_claims();
  public:
  const ::tagged_claim& claims(int index) const;
  ::tagged_claim* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
      claims() const;

  // repeated .storage_info_message storage_info = 5;
  int storage_info_size() const;
  private:
  int _internal_storage_info_size() const;
  public:
  void clear_storage_info();
  ::storage_info_message* mutable_storage_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >*
      mutable_storage_info();
  private:
  const ::storage_info_message& _internal_storage_info(int index) const;
  ::storage_info_message* _internal_add_storage_info();
  public:
  const ::storage_info_message& storage_info(int index) const;
  ::storage_info_message* add_storage_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >&
      storage_info() const;

  // repeated .tagged_signed_claim signed_claims = 6;
  int signed_claims_size() const;
  private:
  int _internal_signed_claims_size() const;
  public:
  void clear_signed_claims();
  ::tagged_signed_claim* mutable_signed_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >*
      mutable_signed_claims();
  private:
  const ::tagged_signed_claim& _internal_signed_claims(int index) const;
  ::tagged_signed_claim* _internal_add_signed_claims();
  public:
  const ::tagged_signed_claim& signed_claims(int index) const;
  ::tagged_signed_claim* add_signed_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >&
      signed_claims() const;

  // repeated .tagged_blob_message blobs = 7;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::tagged_blob_message* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >*
      mutable_blobs();
  private:
  const ::tagged_blob_message& _internal_blobs(int index) const;
  ::tagged_blob_message* _internal_add_blobs();
  public:
  const ::tagged_blob_message& blobs(int index) const;
  ::tagged_blob_message* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >&
      blobs() const;

  // optional .key_message policy_key = 1;
  bool has_policy_key() const;
  private:
  bool _internal_has_policy_key() const;
  public:
  void clear_policy_key();
  const ::key_message& policy_key() const;
  PROTOBUF_NODISCARD ::key_message* release_policy_key();
  ::key_message* mutable_policy_key();
  void set_allocated_policy_key(::key_message* policy_key);
  private:
  const ::key_message& _internal_policy_key() const;
  ::key_message* _internal_mutable_policy_key();
  public:
  void unsafe_arena_set_allocated_policy_key(
      ::key_message* policy_key);
  ::key_message* unsafe_arena_release_policy_key();

  // @@protoc_insertion_point(class_scope:policy_store_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message > trusted_services_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message > channel_authentication_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim > claims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message > storage_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim > signed_claims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message > blobs_;
  ::key_message* policy_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class claims_sequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:claims_sequence) */ {
 public:
  inline claims_sequence() : claims_sequence(nullptr) {}
  ~claims_sequence() override;
  explicit constexpr claims_sequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  claims_sequence(const claims_sequence& from);
  claims_sequence(claims_sequence&& from) noexcept
    : claims_sequence() {
    *this = ::std::move(from);
  }

  inline claims_sequence& operator=(const claims_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline claims_sequence& operator=(claims_sequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const claims_sequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const claims_sequence* internal_default_instance() {
    return reinterpret_cast<const claims_sequence*>(
               &_claims_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(claims_sequence& a, claims_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(claims_sequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(claims_sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  claims_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<claims_sequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const claims_sequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const claims_sequence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(claims_sequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "claims_sequence";
  }
  protected:
  explicit claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .claim_message claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::claim_message* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >*
      mutable_claims();
  private:
  const ::claim_message& _internal_claims(int index) const;
  ::claim_message* _internal_add_claims();
  public:
  const ::claim_message& claims(int index) const;
  ::claim_message* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >&
      claims() const;

  // @@protoc_insertion_point(class_scope:claims_sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message > claims_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class signed_claim_sequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signed_claim_sequence) */ {
 public:
  inline signed_claim_sequence() : signed_claim_sequence(nullptr) {}
  ~signed_claim_sequence() override;
  explicit constexpr signed_claim_sequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  signed_claim_sequence(const signed_claim_sequence& from);
  signed_claim_sequence(signed_claim_sequence&& from) noexcept
    : signed_claim_sequence() {
    *this = ::std::move(from);
  }

  inline signed_claim_sequence& operator=(const signed_claim_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline signed_claim_sequence& operator=(signed_claim_sequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const signed_claim_sequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const signed_claim_sequence* internal_default_instance() {
    return reinterpret_cast<const signed_claim_sequence*>(
               &_signed_claim_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(signed_claim_sequence& a, signed_claim_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(signed_claim_sequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(signed_claim_sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  signed_claim_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<signed_claim_sequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const signed_claim_sequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const signed_claim_sequence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signed_claim_sequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signed_claim_sequence";
  }
  protected:
  explicit signed_claim_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .signed_claim_message claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::signed_claim_message* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >*
      mutable_claims();
  private:
  const ::signed_claim_message& _internal_claims(int index) const;
  ::signed_claim_message* _internal_add_claims();
  public:
  const ::signed_claim_message& claims(int index) const;
  ::signed_claim_message* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >&
      claims() const;

  // @@protoc_insertion_point(class_scope:signed_claim_sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message > claims_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_signed_claim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_signed_claim) */ {
 public:
  inline tagged_signed_claim() : tagged_signed_claim(nullptr) {}
  ~tagged_signed_claim() override;
  explicit constexpr tagged_signed_claim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  tagged_signed_claim(const tagged_signed_claim& from);
  tagged_signed_claim(tagged_signed_claim&& from) noexcept
    : tagged_signed_claim() {
    *this = ::std::move(from);
  }

  inline tagged_signed_claim& operator=(const tagged_signed_claim& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_signed_claim& operator=(tagged_signed_claim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const tagged_signed_claim& default_instance() {
    return *internal_default_instance();
  }
  static inline const tagged_signed_claim* internal_default_instance() {
    return reinterpret_cast<const tagged_signed_claim*>(
               &_tagged_signed_claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(tagged_signed_claim& a, tagged_signed_claim& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_signed_claim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(tagged_signed_claim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  tagged_signed_claim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<tagged_signed_claim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const tagged_signed_claim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const tagged_signed_claim& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_signed_claim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_signed_claim";
  }
  protected:
  explicit tagged_signed_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kScFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .signed_claim_message sc = 2;
  bool has_sc() const;
  private:
  bool _internal_has_sc() const;
  public:
  void clear_sc();
  const ::signed_claim_message& sc() const;
  PROTOBUF_NODISCARD ::signed_claim_message* release_sc();
  ::signed_claim_message* mutable_sc();
  void set_allocated_sc(::signed_claim_message* sc);
  private:
  const ::signed_claim_message& _internal_sc() const;
  ::signed_claim_message* _internal_mutable_sc();
  public:
  void unsafe_arena_set_allocated_sc(
      ::signed_claim_message* sc);
  ::signed_claim_message* unsafe_arena_release_sc();

  // @@protoc_insertion_point(class_scope:tagged_signed_claim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::signed_claim_message* sc_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class buffer_sequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:buffer_sequence) */ {
 public:
  inline buffer_sequence() : buffer_sequence(nullptr) {}
  ~buffer_sequence() override;
  explicit constexpr buffer_sequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  buffer_sequence(const buffer_sequence& from);
  buffer_sequence(buffer_sequence&& from) noexcept
    : buffer_sequence() {
    *this = ::std::move(from);
  }

  inline buffer_sequence& operator=(const buffer_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline buffer_sequence& operator=(buffer_sequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const buffer_sequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const buffer_sequence* internal_default_instance() {
    return reinterpret_cast<const buffer_sequence*>(
               &_buffer_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(buffer_sequence& a, buffer_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(buffer_sequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(buffer_sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  buffer_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<buffer_sequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const buffer_sequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const buffer_sequence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(buffer_sequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "buffer_sequence";
  }
  protected:
  explicit buffer_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // repeated bytes block = 1;
  int block_size() const;
  private:
  int _internal_block_size() const;
  public:
  void clear_block();
  const std::string& block(int index) const;
  std::string* mutable_block(int index);
  void set_block(int index, const std::string& value);
  void set_block(int index, std::string&& value);
  void set_block(int index, const char* value);
  void set_block(int index, const void* value, size_t size);
  std::string* add_block();
  void add_block(const std::string& value);
  void add_block(std::string&& value);
  void add_block(const char* value);
  void add_block(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& block() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_block();
  private:
  const std::string& _internal_block(int index) const;
  std::string* _internal_add_block();
  public:

  // @@protoc_insertion_point(class_scope:buffer_sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class run_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:run_request) */ {
 public:
  inline run_request() : run_request(nullptr) {}
  ~run_request() override;
  explicit constexpr run_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  run_request(const run_request& from);
  run_request(run_request&& from) noexcept
    : run_request() {
    *this = ::std::move(from);
  }

  inline run_request& operator=(const run_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline run_request& operator=(run_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const run_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const run_request* internal_default_instance() {
    return reinterpret_cast<const run_request*>(
               &_run_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(run_request& a, run_request& b) {
    a.Swap(&b);
  }
  inline void Swap(run_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(run_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  run_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<run_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const run_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const run_request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(run_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "run_request";
  }
  protected:
  explicit run_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kLocationFieldNumber = 1,
    kCertFieldNumber = 2,
  };
  // repeated string args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // optional bytes cert = 2;
  bool has_cert() const;
  private:
  bool _internal_has_cert() const;
  public:
  void clear_cert();
  const std::string& cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cert();
  PROTOBUF_NODISCARD std::string* release_cert();
  void set_allocated_cert(std::string* cert);
  private:
  const std::string& _internal_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert(const std::string& value);
  std::string* _internal_mutable_cert();
  public:

  // @@protoc_insertion_point(class_scope:run_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class run_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:run_response) */ {
 public:
  inline run_response() : run_response(nullptr) {}
  ~run_response() override;
  explicit constexpr run_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  run_response(const run_response& from);
  run_response(run_response&& from) noexcept
    : run_response() {
    *this = ::std::move(from);
  }

  inline run_response& operator=(const run_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline run_response& operator=(run_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const run_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const run_response* internal_default_instance() {
    return reinterpret_cast<const run_response*>(
               &_run_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(run_response& a, run_response& b) {
    a.Swap(&b);
  }
  inline void Swap(run_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(run_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  run_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<run_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const run_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const run_response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(run_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "run_response";
  }
  protected:
  explicit run_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional string status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:run_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class app_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:app_request) */ {
 public:
  inline app_request() : app_request(nullptr) {}
  ~app_request() override;
  explicit constexpr app_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  app_request(const app_request& from);
  app_request(app_request&& from) noexcept
    : app_request() {
    *this = ::std::move(from);
  }

  inline app_request& operator=(const app_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline app_request& operator=(app_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const app_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const app_request* internal_default_instance() {
    return reinterpret_cast<const app_request*>(
               &_app_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(app_request& a, app_request& b) {
    a.Swap(&b);
  }
  inline void Swap(app_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(app_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  app_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<app_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const app_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const app_request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(app_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "app_request";
  }
  protected:
  explicit app_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionFieldNumber = 1,
  };
  // repeated bytes args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const void* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // @@protoc_insertion_point(class_scope:app_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class app_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:app_response) */ {
 public:
  inline app_response() : app_response(nullptr) {}
  ~app_response() override;
  explicit constexpr app_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  app_response(const app_response& from);
  app_response(app_response&& from) noexcept
    : app_response() {
    *this = ::std::move(from);
  }

  inline app_response& operator=(const app_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline app_response& operator=(app_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const app_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const app_response* internal_default_instance() {
    return reinterpret_cast<const app_response*>(
               &_app_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(app_response& a, app_response& b) {
    a.Swap(&b);
  }
  inline void Swap(app_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(app_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  app_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<app_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const app_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const app_response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(app_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "app_response";
  }
  protected:
  explicit app_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kFunctionFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated bytes args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const void* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:app_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_blob_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_blob_message) */ {
 public:
  inline tagged_blob_message() : tagged_blob_message(nullptr) {}
  ~tagged_blob_message() override;
  explicit constexpr tagged_blob_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  tagged_blob_message(const tagged_blob_message& from);
  tagged_blob_message(tagged_blob_message&& from) noexcept
    : tagged_blob_message() {
    *this = ::std::move(from);
  }

  inline tagged_blob_message& operator=(const tagged_blob_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_blob_message& operator=(tagged_blob_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const tagged_blob_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const tagged_blob_message* internal_default_instance() {
    return reinterpret_cast<const tagged_blob_message*>(
               &_tagged_blob_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(tagged_blob_message& a, tagged_blob_message& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_blob_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(tagged_blob_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  tagged_blob_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<tagged_blob_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const tagged_blob_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const tagged_blob_message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_blob_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_blob_message";
  }
  protected:
  explicit tagged_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kBFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional bytes b = 2;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const std::string& b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b();
  PROTOBUF_NODISCARD std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // @@protoc_insertion_point(class_scope:tagged_blob_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
  friend struct ::TableStruct_certifier_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// time_point

// optional int32 year = 1;
inline bool time_point::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool time_point::has_year() const {
  return _internal_has_year();
}
inline void time_point::clear_year() {
  year_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t time_point::_internal_year() const {
  return year_;
}
inline int32_t time_point::year() const {
  // @@protoc_insertion_point(field_get:time_point.year)
  return _internal_year();
}
inline void time_point::_internal_set_year(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  year_ = value;
}
inline void time_point::set_year(int32_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:time_point.year)
}

// optional int32 month = 2;
inline bool time_point::_internal_has_month() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool time_point::has_month() const {
  return _internal_has_month();
}
inline void time_point::clear_month() {
  month_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t time_point::_internal_month() const {
  return month_;
}
inline int32_t time_point::month() const {
  // @@protoc_insertion_point(field_get:time_point.month)
  return _internal_month();
}
inline void time_point::_internal_set_month(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  month_ = value;
}
inline void time_point::set_month(int32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:time_point.month)
}

// optional int32 day = 3;
inline bool time_point::_internal_has_day() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool time_point::has_day() const {
  return _internal_has_day();
}
inline void time_point::clear_day() {
  day_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t time_point::_internal_day() const {
  return day_;
}
inline int32_t time_point::day() const {
  // @@protoc_insertion_point(field_get:time_point.day)
  return _internal_day();
}
inline void time_point::_internal_set_day(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  day_ = value;
}
inline void time_point::set_day(int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:time_point.day)
}

// optional int32 hour = 4;
inline bool time_point::_internal_has_hour() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool time_point::has_hour() const {
  return _internal_has_hour();
}
inline void time_point::clear_hour() {
  hour_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t time_point::_internal_hour() const {
  return hour_;
}
inline int32_t time_point::hour() const {
  // @@protoc_insertion_point(field_get:time_point.hour)
  return _internal_hour();
}
inline void time_point::_internal_set_hour(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  hour_ = value;
}
inline void time_point::set_hour(int32_t value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:time_point.hour)
}

// optional int32 minute = 5;
inline bool time_point::_internal_has_minute() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool time_point::has_minute() const {
  return _internal_has_minute();
}
inline void time_point::clear_minute() {
  minute_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t time_point::_internal_minute() const {
  return minute_;
}
inline int32_t time_point::minute() const {
  // @@protoc_insertion_point(field_get:time_point.minute)
  return _internal_minute();
}
inline void time_point::_internal_set_minute(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  minute_ = value;
}
inline void time_point::set_minute(int32_t value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:time_point.minute)
}

// optional double seconds = 6;
inline bool time_point::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool time_point::has_seconds() const {
  return _internal_has_seconds();
}
inline void time_point::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double time_point::_internal_seconds() const {
  return seconds_;
}
inline double time_point::seconds() const {
  // @@protoc_insertion_point(field_get:time_point.seconds)
  return _internal_seconds();
}
inline void time_point::_internal_set_seconds(double value) {
  _has_bits_[0] |= 0x00000010u;
  seconds_ = value;
}
inline void time_point::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:time_point.seconds)
}

// -------------------------------------------------------------------

// rsa_message

// optional bytes public_modulus = 1;
inline bool rsa_message::_internal_has_public_modulus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rsa_message::has_public_modulus() const {
  return _internal_has_public_modulus();
}
inline void rsa_message::clear_public_modulus() {
  public_modulus_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& rsa_message::public_modulus() const {
  // @@protoc_insertion_point(field_get:rsa_message.public_modulus)
  return _internal_public_modulus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_public_modulus(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 public_modulus_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.public_modulus)
}
inline std::string* rsa_message::mutable_public_modulus() {
  std::string* _s = _internal_mutable_public_modulus();
  // @@protoc_insertion_point(field_mutable:rsa_message.public_modulus)
  return _s;
}
inline const std::string& rsa_message::_internal_public_modulus() const {
  return public_modulus_.Get();
}
inline void rsa_message::_internal_set_public_modulus(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_modulus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_public_modulus() {
  _has_bits_[0] |= 0x00000001u;
  return public_modulus_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_public_modulus() {
  // @@protoc_insertion_point(field_release:rsa_message.public_modulus)
  if (!_internal_has_public_modulus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = public_modulus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_modulus_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_public_modulus(std::string* public_modulus) {
  if (public_modulus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_modulus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_modulus,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_modulus_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.public_modulus)
}

// optional bytes public_exponent = 2;
inline bool rsa_message::_internal_has_public_exponent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rsa_message::has_public_exponent() const {
  return _internal_has_public_exponent();
}
inline void rsa_message::clear_public_exponent() {
  public_exponent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& rsa_message::public_exponent() const {
  // @@protoc_insertion_point(field_get:rsa_message.public_exponent)
  return _internal_public_exponent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_public_exponent(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_exponent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.public_exponent)
}
inline std::string* rsa_message::mutable_public_exponent() {
  std::string* _s = _internal_mutable_public_exponent();
  // @@protoc_insertion_point(field_mutable:rsa_message.public_exponent)
  return _s;
}
inline const std::string& rsa_message::_internal_public_exponent() const {
  return public_exponent_.Get();
}
inline void rsa_message::_internal_set_public_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_public_exponent() {
  _has_bits_[0] |= 0x00000002u;
  return public_exponent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_public_exponent() {
  // @@protoc_insertion_point(field_release:rsa_message.public_exponent)
  if (!_internal_has_public_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_exponent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_exponent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_public_exponent(std::string* public_exponent) {
  if (public_exponent != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_exponent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_exponent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_exponent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.public_exponent)
}

// optional bytes private_exponent = 3;
inline bool rsa_message::_internal_has_private_exponent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool rsa_message::has_private_exponent() const {
  return _internal_has_private_exponent();
}
inline void rsa_message::clear_private_exponent() {
  private_exponent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& rsa_message::private_exponent() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_exponent)
  return _internal_private_exponent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_private_exponent(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 private_exponent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.private_exponent)
}
inline std::string* rsa_message::mutable_private_exponent() {
  std::string* _s = _internal_mutable_private_exponent();
  // @@protoc_insertion_point(field_mutable:rsa_message.private_exponent)
  return _s;
}
inline const std::string& rsa_message::_internal_private_exponent() const {
  return private_exponent_.Get();
}
inline void rsa_message::_internal_set_private_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  private_exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_private_exponent() {
  _has_bits_[0] |= 0x00000004u;
  return private_exponent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_private_exponent() {
  // @@protoc_insertion_point(field_release:rsa_message.private_exponent)
  if (!_internal_has_private_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = private_exponent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_exponent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_private_exponent(std::string* private_exponent) {
  if (private_exponent != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  private_exponent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_exponent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_exponent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_exponent)
}

// optional bytes private_p = 4;
inline bool rsa_message::_internal_has_private_p() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool rsa_message::has_private_p() const {
  return _internal_has_private_p();
}
inline void rsa_message::clear_private_p() {
  private_p_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& rsa_message::private_p() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_p)
  return _internal_private_p();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_private_p(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 private_p_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.private_p)
}
inline std::string* rsa_message::mutable_private_p() {
  std::string* _s = _internal_mutable_private_p();
  // @@protoc_insertion_point(field_mutable:rsa_message.private_p)
  return _s;
}
inline const std::string& rsa_message::_internal_private_p() const {
  return private_p_.Get();
}
inline void rsa_message::_internal_set_private_p(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  private_p_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_private_p() {
  _has_bits_[0] |= 0x00000008u;
  return private_p_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_private_p() {
  // @@protoc_insertion_point(field_release:rsa_message.private_p)
  if (!_internal_has_private_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = private_p_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_p_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_private_p(std::string* private_p) {
  if (private_p != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  private_p_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_p,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_p_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_p)
}

// optional bytes private_q = 5;
inline bool rsa_message::_internal_has_private_q() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool rsa_message::has_private_q() const {
  return _internal_has_private_q();
}
inline void rsa_message::clear_private_q() {
  private_q_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& rsa_message::private_q() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_q)
  return _internal_private_q();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_private_q(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 private_q_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.private_q)
}
inline std::string* rsa_message::mutable_private_q() {
  std::string* _s = _internal_mutable_private_q();
  // @@protoc_insertion_point(field_mutable:rsa_message.private_q)
  return _s;
}
inline const std::string& rsa_message::_internal_private_q() const {
  return private_q_.Get();
}
inline void rsa_message::_internal_set_private_q(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  private_q_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_private_q() {
  _has_bits_[0] |= 0x00000010u;
  return private_q_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_private_q() {
  // @@protoc_insertion_point(field_release:rsa_message.private_q)
  if (!_internal_has_private_q()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = private_q_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_q_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_q_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_private_q(std::string* private_q) {
  if (private_q != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  private_q_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_q,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_q_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_q_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_q)
}

// optional bytes private_dp = 6;
inline bool rsa_message::_internal_has_private_dp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool rsa_message::has_private_dp() const {
  return _internal_has_private_dp();
}
inline void rsa_message::clear_private_dp() {
  private_dp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& rsa_message::private_dp() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_dp)
  return _internal_private_dp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_private_dp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 private_dp_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.private_dp)
}
inline std::string* rsa_message::mutable_private_dp() {
  std::string* _s = _internal_mutable_private_dp();
  // @@protoc_insertion_point(field_mutable:rsa_message.private_dp)
  return _s;
}
inline const std::string& rsa_message::_internal_private_dp() const {
  return private_dp_.Get();
}
inline void rsa_message::_internal_set_private_dp(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  private_dp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_private_dp() {
  _has_bits_[0] |= 0x00000020u;
  return private_dp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_private_dp() {
  // @@protoc_insertion_point(field_release:rsa_message.private_dp)
  if (!_internal_has_private_dp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = private_dp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_dp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_dp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_private_dp(std::string* private_dp) {
  if (private_dp != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  private_dp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_dp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_dp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_dp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_dp)
}

// optional bytes private_dq = 7;
inline bool rsa_message::_internal_has_private_dq() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool rsa_message::has_private_dq() const {
  return _internal_has_private_dq();
}
inline void rsa_message::clear_private_dq() {
  private_dq_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& rsa_message::private_dq() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_dq)
  return _internal_private_dq();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rsa_message::set_private_dq(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 private_dq_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsa_message.private_dq)
}
inline std::string* rsa_message::mutable_private_dq() {
  std::string* _s = _internal_mutable_private_dq();
  // @@protoc_insertion_point(field_mutable:rsa_message.private_dq)
  return _s;
}
inline const std::string& rsa_message::_internal_private_dq() const {
  return private_dq_.Get();
}
inline void rsa_message::_internal_set_private_dq(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  private_dq_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* rsa_message::_internal_mutable_private_dq() {
  _has_bits_[0] |= 0x00000040u;
  return private_dq_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* rsa_message::release_private_dq() {
  // @@protoc_insertion_point(field_release:rsa_message.private_dq)
  if (!_internal_has_private_dq()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = private_dq_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_dq_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_dq_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void rsa_message::set_allocated_private_dq(std::string* private_dq) {
  if (private_dq != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  private_dq_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_dq,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_dq_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_dq_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_dq)
}

// -------------------------------------------------------------------

// point_message

// optional bytes x = 1;
inline bool point_message::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool point_message::has_x() const {
  return _internal_has_x();
}
inline void point_message::clear_x() {
  x_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& point_message::x() const {
  // @@protoc_insertion_point(field_get:point_message.x)
  return _internal_x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void point_message::set_x(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 x_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:point_message.x)
}
inline std::string* point_message::mutable_x() {
  std::string* _s = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:point_message.x)
  return _s;
}
inline const std::string& point_message::_internal_x() const {
  return x_.Get();
}
inline void point_message::_internal_set_x(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* point_message::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  return x_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* point_message::release_x() {
  // @@protoc_insertion_point(field_release:point_message.x)
  if (!_internal_has_x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = x_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void point_message::set_allocated_x(std::string* x) {
  if (x != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:point_message.x)
}

// optional bytes y = 2;
inline bool point_message::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool point_message::has_y() const {
  return _internal_has_y();
}
inline void point_message::clear_y() {
  y_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& point_message::y() const {
  // @@protoc_insertion_point(field_get:point_message.y)
  return _internal_y();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void point_message::set_y(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 y_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:point_message.y)
}
inline std::string* point_message::mutable_y() {
  std::string* _s = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:point_message.y)
  return _s;
}
inline const std::string& point_message::_internal_y() const {
  return y_.Get();
}
inline void point_message::_internal_set_y(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* point_message::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  return y_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* point_message::release_y() {
  // @@protoc_insertion_point(field_release:point_message.y)
  if (!_internal_has_y()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = y_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (y_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    y_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void point_message::set_allocated_y(std::string* y) {
  if (y != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), y,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (y_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    y_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:point_message.y)
}

// -------------------------------------------------------------------

// ecc_message

// optional string curve_name = 1;
inline bool ecc_message::_internal_has_curve_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ecc_message::has_curve_name() const {
  return _internal_has_curve_name();
}
inline void ecc_message::clear_curve_name() {
  curve_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ecc_message::curve_name() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_name)
  return _internal_curve_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_curve_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 curve_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.curve_name)
}
inline std::string* ecc_message::mutable_curve_name() {
  std::string* _s = _internal_mutable_curve_name();
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_name)
  return _s;
}
inline const std::string& ecc_message::_internal_curve_name() const {
  return curve_name_.Get();
}
inline void ecc_message::_internal_set_curve_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  curve_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_curve_name() {
  _has_bits_[0] |= 0x00000001u;
  return curve_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_curve_name() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_name)
  if (!_internal_has_curve_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = curve_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_curve_name(std::string* curve_name) {
  if (curve_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  curve_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_name)
}

// optional bytes curve_p = 2;
inline bool ecc_message::_internal_has_curve_p() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ecc_message::has_curve_p() const {
  return _internal_has_curve_p();
}
inline void ecc_message::clear_curve_p() {
  curve_p_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ecc_message::curve_p() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_p)
  return _internal_curve_p();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_curve_p(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 curve_p_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.curve_p)
}
inline std::string* ecc_message::mutable_curve_p() {
  std::string* _s = _internal_mutable_curve_p();
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_p)
  return _s;
}
inline const std::string& ecc_message::_internal_curve_p() const {
  return curve_p_.Get();
}
inline void ecc_message::_internal_set_curve_p(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  curve_p_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_curve_p() {
  _has_bits_[0] |= 0x00000002u;
  return curve_p_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_curve_p() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_p)
  if (!_internal_has_curve_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = curve_p_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_p_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_curve_p(std::string* curve_p) {
  if (curve_p != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  curve_p_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_p,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_p_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_p)
}

// optional bytes curve_a = 3;
inline bool ecc_message::_internal_has_curve_a() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ecc_message::has_curve_a() const {
  return _internal_has_curve_a();
}
inline void ecc_message::clear_curve_a() {
  curve_a_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ecc_message::curve_a() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_a)
  return _internal_curve_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_curve_a(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 curve_a_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.curve_a)
}
inline std::string* ecc_message::mutable_curve_a() {
  std::string* _s = _internal_mutable_curve_a();
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_a)
  return _s;
}
inline const std::string& ecc_message::_internal_curve_a() const {
  return curve_a_.Get();
}
inline void ecc_message::_internal_set_curve_a(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  curve_a_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_curve_a() {
  _has_bits_[0] |= 0x00000004u;
  return curve_a_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_curve_a() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_a)
  if (!_internal_has_curve_a()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = curve_a_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_a_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_a_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_curve_a(std::string* curve_a) {
  if (curve_a != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  curve_a_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_a,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_a_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_a_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_a)
}

// optional bytes curve_b = 4;
inline bool ecc_message::_internal_has_curve_b() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ecc_message::has_curve_b() const {
  return _internal_has_curve_b();
}
inline void ecc_message::clear_curve_b() {
  curve_b_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ecc_message::curve_b() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_b)
  return _internal_curve_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_curve_b(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 curve_b_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.curve_b)
}
inline std::string* ecc_message::mutable_curve_b() {
  std::string* _s = _internal_mutable_curve_b();
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_b)
  return _s;
}
inline const std::string& ecc_message::_internal_curve_b() const {
  return curve_b_.Get();
}
inline void ecc_message::_internal_set_curve_b(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  curve_b_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_curve_b() {
  _has_bits_[0] |= 0x00000008u;
  return curve_b_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_curve_b() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_b)
  if (!_internal_has_curve_b()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = curve_b_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_b_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_curve_b(std::string* curve_b) {
  if (curve_b != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  curve_b_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_b,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (curve_b_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    curve_b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_b)
}

// optional .point_message base_point = 5;
inline bool ecc_message::_internal_has_base_point() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || base_point_ != nullptr);
  return value;
}
inline bool ecc_message::has_base_point() const {
  return _internal_has_base_point();
}
inline void ecc_message::clear_base_point() {
  if (base_point_ != nullptr) base_point_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::point_message& ecc_message::_internal_base_point() const {
  const ::point_message* p = base_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::point_message&>(
      ::_point_message_default_instance_);
}
inline const ::point_message& ecc_message::base_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.base_point)
  return _internal_base_point();
}
inline void ecc_message::unsafe_arena_set_allocated_base_point(
    ::point_message* base_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_point_);
  }
  base_point_ = base_point;
  if (base_point) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecc_message.base_point)
}
inline ::point_message* ecc_message::release_base_point() {
  _has_bits_[0] &= ~0x00000040u;
  ::point_message* temp = base_point_;
  base_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::point_message* ecc_message::unsafe_arena_release_base_point() {
  // @@protoc_insertion_point(field_release:ecc_message.base_point)
  _has_bits_[0] &= ~0x00000040u;
  ::point_message* temp = base_point_;
  base_point_ = nullptr;
  return temp;
}
inline ::point_message* ecc_message::_internal_mutable_base_point() {
  _has_bits_[0] |= 0x00000040u;
  if (base_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::point_message>(GetArenaForAllocation());
    base_point_ = p;
  }
  return base_point_;
}
inline ::point_message* ecc_message::mutable_base_point() {
  ::point_message* _msg = _internal_mutable_base_point();
  // @@protoc_insertion_point(field_mutable:ecc_message.base_point)
  return _msg;
}
inline void ecc_message::set_allocated_base_point(::point_message* base_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete base_point_;
  }
  if (base_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::point_message>::GetOwningArena(base_point);
    if (message_arena != submessage_arena) {
      base_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  base_point_ = base_point;
  // @@protoc_insertion_point(field_set_allocated:ecc_message.base_point)
}

// optional .point_message public_point = 6;
inline bool ecc_message::_internal_has_public_point() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || public_point_ != nullptr);
  return value;
}
inline bool ecc_message::has_public_point() const {
  return _internal_has_public_point();
}
inline void ecc_message::clear_public_point() {
  if (public_point_ != nullptr) public_point_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::point_message& ecc_message::_internal_public_point() const {
  const ::point_message* p = public_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::point_message&>(
      ::_point_message_default_instance_);
}
inline const ::point_message& ecc_message::public_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.public_point)
  return _internal_public_point();
}
inline void ecc_message::unsafe_arena_set_allocated_public_point(
    ::point_message* public_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_point_);
  }
  public_point_ = public_point;
  if (public_point) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecc_message.public_point)
}
inline ::point_message* ecc_message::release_public_point() {
  _has_bits_[0] &= ~0x00000080u;
  ::point_message* temp = public_point_;
  public_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::point_message* ecc_message::unsafe_arena_release_public_point() {
  // @@protoc_insertion_point(field_release:ecc_message.public_point)
  _has_bits_[0] &= ~0x00000080u;
  ::point_message* temp = public_point_;
  public_point_ = nullptr;
  return temp;
}
inline ::point_message* ecc_message::_internal_mutable_public_point() {
  _has_bits_[0] |= 0x00000080u;
  if (public_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::point_message>(GetArenaForAllocation());
    public_point_ = p;
  }
  return public_point_;
}
inline ::point_message* ecc_message::mutable_public_point() {
  ::point_message* _msg = _internal_mutable_public_point();
  // @@protoc_insertion_point(field_mutable:ecc_message.public_point)
  return _msg;
}
inline void ecc_message::set_allocated_public_point(::point_message* public_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete public_point_;
  }
  if (public_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::point_message>::GetOwningArena(public_point);
    if (message_arena != submessage_arena) {
      public_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  public_point_ = public_point;
  // @@protoc_insertion_point(field_set_allocated:ecc_message.public_point)
}

// optional bytes order_of_base_point = 7;
inline bool ecc_message::_internal_has_order_of_base_point() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ecc_message::has_order_of_base_point() const {
  return _internal_has_order_of_base_point();
}
inline void ecc_message::clear_order_of_base_point() {
  order_of_base_point_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ecc_message::order_of_base_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.order_of_base_point)
  return _internal_order_of_base_point();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_order_of_base_point(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 order_of_base_point_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.order_of_base_point)
}
inline std::string* ecc_message::mutable_order_of_base_point() {
  std::string* _s = _internal_mutable_order_of_base_point();
  // @@protoc_insertion_point(field_mutable:ecc_message.order_of_base_point)
  return _s;
}
inline const std::string& ecc_message::_internal_order_of_base_point() const {
  return order_of_base_point_.Get();
}
inline void ecc_message::_internal_set_order_of_base_point(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  order_of_base_point_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_order_of_base_point() {
  _has_bits_[0] |= 0x00000010u;
  return order_of_base_point_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_order_of_base_point() {
  // @@protoc_insertion_point(field_release:ecc_message.order_of_base_point)
  if (!_internal_has_order_of_base_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = order_of_base_point_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_of_base_point_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_of_base_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_order_of_base_point(std::string* order_of_base_point) {
  if (order_of_base_point != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  order_of_base_point_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_of_base_point,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_of_base_point_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_of_base_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.order_of_base_point)
}

// optional bytes private_multiplier = 8;
inline bool ecc_message::_internal_has_private_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ecc_message::has_private_multiplier() const {
  return _internal_has_private_multiplier();
}
inline void ecc_message::clear_private_multiplier() {
  private_multiplier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ecc_message::private_multiplier() const {
  // @@protoc_insertion_point(field_get:ecc_message.private_multiplier)
  return _internal_private_multiplier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ecc_message::set_private_multiplier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 private_multiplier_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecc_message.private_multiplier)
}
inline std::string* ecc_message::mutable_private_multiplier() {
  std::string* _s = _internal_mutable_private_multiplier();
  // @@protoc_insertion_point(field_mutable:ecc_message.private_multiplier)
  return _s;
}
inline const std::string& ecc_message::_internal_private_multiplier() const {
  return private_multiplier_.Get();
}
inline void ecc_message::_internal_set_private_multiplier(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  private_multiplier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ecc_message::_internal_mutable_private_multiplier() {
  _has_bits_[0] |= 0x00000020u;
  return private_multiplier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ecc_message::release_private_multiplier() {
  // @@protoc_insertion_point(field_release:ecc_message.private_multiplier)
  if (!_internal_has_private_multiplier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = private_multiplier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_multiplier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ecc_message::set_allocated_private_multiplier(std::string* private_multiplier) {
  if (private_multiplier != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  private_multiplier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_multiplier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_multiplier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecc_message.private_multiplier)
}

// -------------------------------------------------------------------

// key_message

// optional string key_name = 1;
inline bool key_message::_internal_has_key_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool key_message::has_key_name() const {
  return _internal_has_key_name();
}
inline void key_message::clear_key_name() {
  key_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& key_message::key_name() const {
  // @@protoc_insertion_point(field_get:key_message.key_name)
  return _internal_key_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_key_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.key_name)
}
inline std::string* key_message::mutable_key_name() {
  std::string* _s = _internal_mutable_key_name();
  // @@protoc_insertion_point(field_mutable:key_message.key_name)
  return _s;
}
inline const std::string& key_message::_internal_key_name() const {
  return key_name_.Get();
}
inline void key_message::_internal_set_key_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_key_name() {
  _has_bits_[0] |= 0x00000001u;
  return key_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_key_name() {
  // @@protoc_insertion_point(field_release:key_message.key_name)
  if (!_internal_has_key_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_key_name(std::string* key_name) {
  if (key_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.key_name)
}

// optional string key_type = 2;
inline bool key_message::_internal_has_key_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool key_message::has_key_type() const {
  return _internal_has_key_type();
}
inline void key_message::clear_key_type() {
  key_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& key_message::key_type() const {
  // @@protoc_insertion_point(field_get:key_message.key_type)
  return _internal_key_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_key_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 key_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.key_type)
}
inline std::string* key_message::mutable_key_type() {
  std::string* _s = _internal_mutable_key_type();
  // @@protoc_insertion_point(field_mutable:key_message.key_type)
  return _s;
}
inline const std::string& key_message::_internal_key_type() const {
  return key_type_.Get();
}
inline void key_message::_internal_set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_key_type() {
  _has_bits_[0] |= 0x00000002u;
  return key_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:key_message.key_type)
  if (!_internal_has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = key_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.key_type)
}

// optional string key_format = 3;
inline bool key_message::_internal_has_key_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool key_message::has_key_format() const {
  return _internal_has_key_format();
}
inline void key_message::clear_key_format() {
  key_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& key_message::key_format() const {
  // @@protoc_insertion_point(field_get:key_message.key_format)
  return _internal_key_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_key_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 key_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.key_format)
}
inline std::string* key_message::mutable_key_format() {
  std::string* _s = _internal_mutable_key_format();
  // @@protoc_insertion_point(field_mutable:key_message.key_format)
  return _s;
}
inline const std::string& key_message::_internal_key_format() const {
  return key_format_.Get();
}
inline void key_message::_internal_set_key_format(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  key_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_key_format() {
  _has_bits_[0] |= 0x00000004u;
  return key_format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_key_format() {
  // @@protoc_insertion_point(field_release:key_message.key_format)
  if (!_internal_has_key_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = key_format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_key_format(std::string* key_format) {
  if (key_format != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.key_format)
}

// optional .rsa_message rsa_key = 4;
inline bool key_message::_internal_has_rsa_key() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || rsa_key_ != nullptr);
  return value;
}
inline bool key_message::has_rsa_key() const {
  return _internal_has_rsa_key();
}
inline void key_message::clear_rsa_key() {
  if (rsa_key_ != nullptr) rsa_key_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::rsa_message& key_message::_internal_rsa_key() const {
  const ::rsa_message* p = rsa_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsa_message&>(
      ::_rsa_message_default_instance_);
}
inline const ::rsa_message& key_message::rsa_key() const {
  // @@protoc_insertion_point(field_get:key_message.rsa_key)
  return _internal_rsa_key();
}
inline void key_message::unsafe_arena_set_allocated_rsa_key(
    ::rsa_message* rsa_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rsa_key_);
  }
  rsa_key_ = rsa_key;
  if (rsa_key) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.rsa_key)
}
inline ::rsa_message* key_message::release_rsa_key() {
  _has_bits_[0] &= ~0x00000100u;
  ::rsa_message* temp = rsa_key_;
  rsa_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsa_message* key_message::unsafe_arena_release_rsa_key() {
  // @@protoc_insertion_point(field_release:key_message.rsa_key)
  _has_bits_[0] &= ~0x00000100u;
  ::rsa_message* temp = rsa_key_;
  rsa_key_ = nullptr;
  return temp;
}
inline ::rsa_message* key_message::_internal_mutable_rsa_key() {
  _has_bits_[0] |= 0x00000100u;
  if (rsa_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsa_message>(GetArenaForAllocation());
    rsa_key_ = p;
  }
  return rsa_key_;
}
inline ::rsa_message* key_message::mutable_rsa_key() {
  ::rsa_message* _msg = _internal_mutable_rsa_key();
  // @@protoc_insertion_point(field_mutable:key_message.rsa_key)
  return _msg;
}
inline void key_message::set_allocated_rsa_key(::rsa_message* rsa_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rsa_key_;
  }
  if (rsa_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rsa_message>::GetOwningArena(rsa_key);
    if (message_arena != submessage_arena) {
      rsa_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsa_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  rsa_key_ = rsa_key;
  // @@protoc_insertion_point(field_set_allocated:key_message.rsa_key)
}

// optional .ecc_message ecc_key = 5;
inline bool key_message::_internal_has_ecc_key() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || ecc_key_ != nullptr);
  return value;
}
inline bool key_message::has_ecc_key() const {
  return _internal_has_ecc_key();
}
inline void key_message::clear_ecc_key() {
  if (ecc_key_ != nullptr) ecc_key_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::ecc_message& key_message::_internal_ecc_key() const {
  const ::ecc_message* p = ecc_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecc_message&>(
      ::_ecc_message_default_instance_);
}
inline const ::ecc_message& key_message::ecc_key() const {
  // @@protoc_insertion_point(field_get:key_message.ecc_key)
  return _internal_ecc_key();
}
inline void key_message::unsafe_arena_set_allocated_ecc_key(
    ::ecc_message* ecc_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ecc_key_);
  }
  ecc_key_ = ecc_key;
  if (ecc_key) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.ecc_key)
}
inline ::ecc_message* key_message::release_ecc_key() {
  _has_bits_[0] &= ~0x00000200u;
  ::ecc_message* temp = ecc_key_;
  ecc_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecc_message* key_message::unsafe_arena_release_ecc_key() {
  // @@protoc_insertion_point(field_release:key_message.ecc_key)
  _has_bits_[0] &= ~0x00000200u;
  ::ecc_message* temp = ecc_key_;
  ecc_key_ = nullptr;
  return temp;
}
inline ::ecc_message* key_message::_internal_mutable_ecc_key() {
  _has_bits_[0] |= 0x00000200u;
  if (ecc_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecc_message>(GetArenaForAllocation());
    ecc_key_ = p;
  }
  return ecc_key_;
}
inline ::ecc_message* key_message::mutable_ecc_key() {
  ::ecc_message* _msg = _internal_mutable_ecc_key();
  // @@protoc_insertion_point(field_mutable:key_message.ecc_key)
  return _msg;
}
inline void key_message::set_allocated_ecc_key(::ecc_message* ecc_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ecc_key_;
  }
  if (ecc_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecc_message>::GetOwningArena(ecc_key);
    if (message_arena != submessage_arena) {
      ecc_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecc_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ecc_key_ = ecc_key;
  // @@protoc_insertion_point(field_set_allocated:key_message.ecc_key)
}

// optional bytes secret_key_bits = 6;
inline bool key_message::_internal_has_secret_key_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool key_message::has_secret_key_bits() const {
  return _internal_has_secret_key_bits();
}
inline void key_message::clear_secret_key_bits() {
  secret_key_bits_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& key_message::secret_key_bits() const {
  // @@protoc_insertion_point(field_get:key_message.secret_key_bits)
  return _internal_secret_key_bits();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_secret_key_bits(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 secret_key_bits_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.secret_key_bits)
}
inline std::string* key_message::mutable_secret_key_bits() {
  std::string* _s = _internal_mutable_secret_key_bits();
  // @@protoc_insertion_point(field_mutable:key_message.secret_key_bits)
  return _s;
}
inline const std::string& key_message::_internal_secret_key_bits() const {
  return secret_key_bits_.Get();
}
inline void key_message::_internal_set_secret_key_bits(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  secret_key_bits_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_secret_key_bits() {
  _has_bits_[0] |= 0x00000008u;
  return secret_key_bits_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_secret_key_bits() {
  // @@protoc_insertion_point(field_release:key_message.secret_key_bits)
  if (!_internal_has_secret_key_bits()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = secret_key_bits_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_key_bits_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_key_bits_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_secret_key_bits(std::string* secret_key_bits) {
  if (secret_key_bits != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  secret_key_bits_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_key_bits,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_key_bits_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_key_bits_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.secret_key_bits)
}

// optional bytes certificate = 7;
inline bool key_message::_internal_has_certificate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool key_message::has_certificate() const {
  return _internal_has_certificate();
}
inline void key_message::clear_certificate() {
  certificate_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& key_message::certificate() const {
  // @@protoc_insertion_point(field_get:key_message.certificate)
  return _internal_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_certificate(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 certificate_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.certificate)
}
inline std::string* key_message::mutable_certificate() {
  std::string* _s = _internal_mutable_certificate();
  // @@protoc_insertion_point(field_mutable:key_message.certificate)
  return _s;
}
inline const std::string& key_message::_internal_certificate() const {
  return certificate_.Get();
}
inline void key_message::_internal_set_certificate(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  certificate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_certificate() {
  _has_bits_[0] |= 0x00000010u;
  return certificate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_certificate() {
  // @@protoc_insertion_point(field_release:key_message.certificate)
  if (!_internal_has_certificate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = certificate_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (certificate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    certificate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_certificate(std::string* certificate) {
  if (certificate != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  certificate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (certificate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    certificate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.certificate)
}

// optional bytes other_key_formats = 8;
inline bool key_message::_internal_has_other_key_formats() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool key_message::has_other_key_formats() const {
  return _internal_has_other_key_formats();
}
inline void key_message::clear_other_key_formats() {
  other_key_formats_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& key_message::other_key_formats() const {
  // @@protoc_insertion_point(field_get:key_message.other_key_formats)
  return _internal_other_key_formats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_other_key_formats(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 other_key_formats_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.other_key_formats)
}
inline std::string* key_message::mutable_other_key_formats() {
  std::string* _s = _internal_mutable_other_key_formats();
  // @@protoc_insertion_point(field_mutable:key_message.other_key_formats)
  return _s;
}
inline const std::string& key_message::_internal_other_key_formats() const {
  return other_key_formats_.Get();
}
inline void key_message::_internal_set_other_key_formats(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  other_key_formats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_other_key_formats() {
  _has_bits_[0] |= 0x00000020u;
  return other_key_formats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_other_key_formats() {
  // @@protoc_insertion_point(field_release:key_message.other_key_formats)
  if (!_internal_has_other_key_formats()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = other_key_formats_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (other_key_formats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    other_key_formats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_other_key_formats(std::string* other_key_formats) {
  if (other_key_formats != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  other_key_formats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), other_key_formats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (other_key_formats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    other_key_formats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.other_key_formats)
}

// optional string not_before = 9;
inline bool key_message::_internal_has_not_before() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool key_message::has_not_before() const {
  return _internal_has_not_before();
}
inline void key_message::clear_not_before() {
  not_before_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& key_message::not_before() const {
  // @@protoc_insertion_point(field_get:key_message.not_before)
  return _internal_not_before();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_not_before(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.not_before)
}
inline std::string* key_message::mutable_not_before() {
  std::string* _s = _internal_mutable_not_before();
  // @@protoc_insertion_point(field_mutable:key_message.not_before)
  return _s;
}
inline const std::string& key_message::_internal_not_before() const {
  return not_before_.Get();
}
inline void key_message::_internal_set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_not_before() {
  _has_bits_[0] |= 0x00000040u;
  return not_before_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_not_before() {
  // @@protoc_insertion_point(field_release:key_message.not_before)
  if (!_internal_has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = not_before_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_before_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  not_before_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_before_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.not_before)
}

// optional string not_after = 10;
inline bool key_message::_internal_has_not_after() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool key_message::has_not_after() const {
  return _internal_has_not_after();
}
inline void key_message::clear_not_after() {
  not_after_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& key_message::not_after() const {
  // @@protoc_insertion_point(field_get:key_message.not_after)
  return _internal_not_after();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void key_message::set_not_after(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:key_message.not_after)
}
inline std::string* key_message::mutable_not_after() {
  std::string* _s = _internal_mutable_not_after();
  // @@protoc_insertion_point(field_mutable:key_message.not_after)
  return _s;
}
inline const std::string& key_message::_internal_not_after() const {
  return not_after_.Get();
}
inline void key_message::_internal_set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* key_message::_internal_mutable_not_after() {
  _has_bits_[0] |= 0x00000080u;
  return not_after_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* key_message::release_not_after() {
  // @@protoc_insertion_point(field_release:key_message.not_after)
  if (!_internal_has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = not_after_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_after_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void key_message::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  not_after_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_after_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:key_message.not_after)
}

// -------------------------------------------------------------------

// protected_blob_message

// optional bytes encrypted_key = 1;
inline bool protected_blob_message::_internal_has_encrypted_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool protected_blob_message::has_encrypted_key() const {
  return _internal_has_encrypted_key();
}
inline void protected_blob_message::clear_encrypted_key() {
  encrypted_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& protected_blob_message::encrypted_key() const {
  // @@protoc_insertion_point(field_get:protected_blob_message.encrypted_key)
  return _internal_encrypted_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void protected_blob_message::set_encrypted_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encrypted_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protected_blob_message.encrypted_key)
}
inline std::string* protected_blob_message::mutable_encrypted_key() {
  std::string* _s = _internal_mutable_encrypted_key();
  // @@protoc_insertion_point(field_mutable:protected_blob_message.encrypted_key)
  return _s;
}
inline const std::string& protected_blob_message::_internal_encrypted_key() const {
  return encrypted_key_.Get();
}
inline void protected_blob_message::_internal_set_encrypted_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encrypted_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* protected_blob_message::_internal_mutable_encrypted_key() {
  _has_bits_[0] |= 0x00000001u;
  return encrypted_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* protected_blob_message::release_encrypted_key() {
  // @@protoc_insertion_point(field_release:protected_blob_message.encrypted_key)
  if (!_internal_has_encrypted_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encrypted_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void protected_blob_message::set_allocated_encrypted_key(std::string* encrypted_key) {
  if (encrypted_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encrypted_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protected_blob_message.encrypted_key)
}

// optional bytes encrypted_data = 2;
inline bool protected_blob_message::_internal_has_encrypted_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool protected_blob_message::has_encrypted_data() const {
  return _internal_has_encrypted_data();
}
inline void protected_blob_message::clear_encrypted_data() {
  encrypted_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& protected_blob_message::encrypted_data() const {
  // @@protoc_insertion_point(field_get:protected_blob_message.encrypted_data)
  return _internal_encrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void protected_blob_message::set_encrypted_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 encrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protected_blob_message.encrypted_data)
}
inline std::string* protected_blob_message::mutable_encrypted_data() {
  std::string* _s = _internal_mutable_encrypted_data();
  // @@protoc_insertion_point(field_mutable:protected_blob_message.encrypted_data)
  return _s;
}
inline const std::string& protected_blob_message::_internal_encrypted_data() const {
  return encrypted_data_.Get();
}
inline void protected_blob_message::_internal_set_encrypted_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* protected_blob_message::_internal_mutable_encrypted_data() {
  _has_bits_[0] |= 0x00000002u;
  return encrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* protected_blob_message::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:protected_blob_message.encrypted_data)
  if (!_internal_has_encrypted_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = encrypted_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void protected_blob_message::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protected_blob_message.encrypted_data)
}

// -------------------------------------------------------------------

// entity_message

// optional string entity_type = 1;
inline bool entity_message::_internal_has_entity_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool entity_message::has_entity_type() const {
  return _internal_has_entity_type();
}
inline void entity_message::clear_entity_type() {
  entity_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& entity_message::entity_type() const {
  // @@protoc_insertion_point(field_get:entity_message.entity_type)
  return _internal_entity_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void entity_message::set_entity_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 entity_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:entity_message.entity_type)
}
inline std::string* entity_message::mutable_entity_type() {
  std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:entity_message.entity_type)
  return _s;
}
inline const std::string& entity_message::_internal_entity_type() const {
  return entity_type_.Get();
}
inline void entity_message::_internal_set_entity_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  entity_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* entity_message::_internal_mutable_entity_type() {
  _has_bits_[0] |= 0x00000001u;
  return entity_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* entity_message::release_entity_type() {
  // @@protoc_insertion_point(field_release:entity_message.entity_type)
  if (!_internal_has_entity_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = entity_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entity_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    entity_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void entity_message::set_allocated_entity_type(std::string* entity_type) {
  if (entity_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entity_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entity_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    entity_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:entity_message.entity_type)
}

// optional .key_message key = 2;
inline bool entity_message::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool entity_message::has_key() const {
  return _internal_has_key();
}
inline void entity_message::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& entity_message::_internal_key() const {
  const ::key_message* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& entity_message::key() const {
  // @@protoc_insertion_point(field_get:entity_message.key)
  return _internal_key();
}
inline void entity_message::unsafe_arena_set_allocated_key(
    ::key_message* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:entity_message.key)
}
inline ::key_message* entity_message::release_key() {
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* entity_message::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:entity_message.key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::key_message* entity_message::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000004u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::key_message* entity_message::mutable_key() {
  ::key_message* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:entity_message.key)
  return _msg;
}
inline void entity_message::set_allocated_key(::key_message* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:entity_message.key)
}

// optional bytes measurement = 3;
inline bool entity_message::_internal_has_measurement() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool entity_message::has_measurement() const {
  return _internal_has_measurement();
}
inline void entity_message::clear_measurement() {
  measurement_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& entity_message::measurement() const {
  // @@protoc_insertion_point(field_get:entity_message.measurement)
  return _internal_measurement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void entity_message::set_measurement(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 measurement_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:entity_message.measurement)
}
inline std::string* entity_message::mutable_measurement() {
  std::string* _s = _internal_mutable_measurement();
  // @@protoc_insertion_point(field_mutable:entity_message.measurement)
  return _s;
}
inline const std::string& entity_message::_internal_measurement() const {
  return measurement_.Get();
}
inline void entity_message::_internal_set_measurement(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* entity_message::_internal_mutable_measurement() {
  _has_bits_[0] |= 0x00000002u;
  return measurement_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* entity_message::release_measurement() {
  // @@protoc_insertion_point(field_release:entity_message.measurement)
  if (!_internal_has_measurement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = measurement_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void entity_message::set_allocated_measurement(std::string* measurement) {
  if (measurement != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  measurement_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), measurement,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:entity_message.measurement)
}

// -------------------------------------------------------------------

// vse_clause

// optional .entity_message subject = 1;
inline bool vse_clause::_internal_has_subject() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || subject_ != nullptr);
  return value;
}
inline bool vse_clause::has_subject() const {
  return _internal_has_subject();
}
inline void vse_clause::clear_subject() {
  if (subject_ != nullptr) subject_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::entity_message& vse_clause::_internal_subject() const {
  const ::entity_message* p = subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::entity_message&>(
      ::_entity_message_default_instance_);
}
inline const ::entity_message& vse_clause::subject() const {
  // @@protoc_insertion_point(field_get:vse_clause.subject)
  return _internal_subject();
}
inline void vse_clause::unsafe_arena_set_allocated_subject(
    ::entity_message* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subject_);
  }
  subject_ = subject;
  if (subject) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vse_clause.subject)
}
inline ::entity_message* vse_clause::release_subject() {
  _has_bits_[0] &= ~0x00000002u;
  ::entity_message* temp = subject_;
  subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::entity_message* vse_clause::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:vse_clause.subject)
  _has_bits_[0] &= ~0x00000002u;
  ::entity_message* temp = subject_;
  subject_ = nullptr;
  return temp;
}
inline ::entity_message* vse_clause::_internal_mutable_subject() {
  _has_bits_[0] |= 0x00000002u;
  if (subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::entity_message>(GetArenaForAllocation());
    subject_ = p;
  }
  return subject_;
}
inline ::entity_message* vse_clause::mutable_subject() {
  ::entity_message* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:vse_clause.subject)
  return _msg;
}
inline void vse_clause::set_allocated_subject(::entity_message* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subject_;
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::entity_message>::GetOwningArena(subject);
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.subject)
}

// optional string verb = 2;
inline bool vse_clause::_internal_has_verb() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool vse_clause::has_verb() const {
  return _internal_has_verb();
}
inline void vse_clause::clear_verb() {
  verb_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& vse_clause::verb() const {
  // @@protoc_insertion_point(field_get:vse_clause.verb)
  return _internal_verb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void vse_clause::set_verb(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 verb_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vse_clause.verb)
}
inline std::string* vse_clause::mutable_verb() {
  std::string* _s = _internal_mutable_verb();
  // @@protoc_insertion_point(field_mutable:vse_clause.verb)
  return _s;
}
inline const std::string& vse_clause::_internal_verb() const {
  return verb_.Get();
}
inline void vse_clause::_internal_set_verb(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  verb_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* vse_clause::_internal_mutable_verb() {
  _has_bits_[0] |= 0x00000001u;
  return verb_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* vse_clause::release_verb() {
  // @@protoc_insertion_point(field_release:vse_clause.verb)
  if (!_internal_has_verb()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = verb_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (verb_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    verb_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void vse_clause::set_allocated_verb(std::string* verb) {
  if (verb != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  verb_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verb,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (verb_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    verb_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vse_clause.verb)
}

// optional .entity_message object = 3;
inline bool vse_clause::_internal_has_object() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || object_ != nullptr);
  return value;
}
inline bool vse_clause::has_object() const {
  return _internal_has_object();
}
inline void vse_clause::clear_object() {
  if (object_ != nullptr) object_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::entity_message& vse_clause::_internal_object() const {
  const ::entity_message* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::entity_message&>(
      ::_entity_message_default_instance_);
}
inline const ::entity_message& vse_clause::object() const {
  // @@protoc_insertion_point(field_get:vse_clause.object)
  return _internal_object();
}
inline void vse_clause::unsafe_arena_set_allocated_object(
    ::entity_message* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vse_clause.object)
}
inline ::entity_message* vse_clause::release_object() {
  _has_bits_[0] &= ~0x00000004u;
  ::entity_message* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::entity_message* vse_clause::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:vse_clause.object)
  _has_bits_[0] &= ~0x00000004u;
  ::entity_message* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::entity_message* vse_clause::_internal_mutable_object() {
  _has_bits_[0] |= 0x00000004u;
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::entity_message>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::entity_message* vse_clause::mutable_object() {
  ::entity_message* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:vse_clause.object)
  return _msg;
}
inline void vse_clause::set_allocated_object(::entity_message* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::entity_message>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.object)
}

// optional .vse_clause clause = 4;
inline bool vse_clause::_internal_has_clause() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || clause_ != nullptr);
  return value;
}
inline bool vse_clause::has_clause() const {
  return _internal_has_clause();
}
inline void vse_clause::clear_clause() {
  if (clause_ != nullptr) clause_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::vse_clause& vse_clause::_internal_clause() const {
  const ::vse_clause* p = clause_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& vse_clause::clause() const {
  // @@protoc_insertion_point(field_get:vse_clause.clause)
  return _internal_clause();
}
inline void vse_clause::unsafe_arena_set_allocated_clause(
    ::vse_clause* clause) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clause_);
  }
  clause_ = clause;
  if (clause) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vse_clause.clause)
}
inline ::vse_clause* vse_clause::release_clause() {
  _has_bits_[0] &= ~0x00000008u;
  ::vse_clause* temp = clause_;
  clause_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* vse_clause::unsafe_arena_release_clause() {
  // @@protoc_insertion_point(field_release:vse_clause.clause)
  _has_bits_[0] &= ~0x00000008u;
  ::vse_clause* temp = clause_;
  clause_ = nullptr;
  return temp;
}
inline ::vse_clause* vse_clause::_internal_mutable_clause() {
  _has_bits_[0] |= 0x00000008u;
  if (clause_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    clause_ = p;
  }
  return clause_;
}
inline ::vse_clause* vse_clause::mutable_clause() {
  ::vse_clause* _msg = _internal_mutable_clause();
  // @@protoc_insertion_point(field_mutable:vse_clause.clause)
  return _msg;
}
inline void vse_clause::set_allocated_clause(::vse_clause* clause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clause_;
  }
  if (clause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(clause);
    if (message_arena != submessage_arena) {
      clause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clause, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clause_ = clause;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.clause)
}

// -------------------------------------------------------------------

// vse_clauses

// repeated .vse_clause clauses = 1;
inline int vse_clauses::_internal_clauses_size() const {
  return clauses_.size();
}
inline int vse_clauses::clauses_size() const {
  return _internal_clauses_size();
}
inline void vse_clauses::clear_clauses() {
  clauses_.Clear();
}
inline ::vse_clause* vse_clauses::mutable_clauses(int index) {
  // @@protoc_insertion_point(field_mutable:vse_clauses.clauses)
  return clauses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
vse_clauses::mutable_clauses() {
  // @@protoc_insertion_point(field_mutable_list:vse_clauses.clauses)
  return &clauses_;
}
inline const ::vse_clause& vse_clauses::_internal_clauses(int index) const {
  return clauses_.Get(index);
}
inline const ::vse_clause& vse_clauses::clauses(int index) const {
  // @@protoc_insertion_point(field_get:vse_clauses.clauses)
  return _internal_clauses(index);
}
inline ::vse_clause* vse_clauses::_internal_add_clauses() {
  return clauses_.Add();
}
inline ::vse_clause* vse_clauses::add_clauses() {
  ::vse_clause* _add = _internal_add_clauses();
  // @@protoc_insertion_point(field_add:vse_clauses.clauses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
vse_clauses::clauses() const {
  // @@protoc_insertion_point(field_list:vse_clauses.clauses)
  return clauses_;
}

// -------------------------------------------------------------------

// attestation

// optional string enclave_type = 1;
inline bool attestation::_internal_has_enclave_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool attestation::has_enclave_type() const {
  return _internal_has_enclave_type();
}
inline void attestation::clear_enclave_type() {
  enclave_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& attestation::enclave_type() const {
  // @@protoc_insertion_point(field_get:attestation.enclave_type)
  return _internal_enclave_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void attestation::set_enclave_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 enclave_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:attestation.enclave_type)
}
inline std::string* attestation::mutable_enclave_type() {
  std::string* _s = _internal_mutable_enclave_type();
  // @@protoc_insertion_point(field_mutable:attestation.enclave_type)
  return _s;
}
inline const std::string& attestation::_internal_enclave_type() const {
  return enclave_type_.Get();
}
inline void attestation::_internal_set_enclave_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* attestation::_internal_mutable_enclave_type() {
  _has_bits_[0] |= 0x00000001u;
  return enclave_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* attestation::release_enclave_type() {
  // @@protoc_insertion_point(field_release:attestation.enclave_type)
  if (!_internal_has_enclave_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = enclave_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (enclave_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    enclave_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void attestation::set_allocated_enclave_type(std::string* enclave_type) {
  if (enclave_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enclave_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enclave_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (enclave_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    enclave_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:attestation.enclave_type)
}

// optional string key_id = 2;
inline bool attestation::_internal_has_key_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool attestation::has_key_id() const {
  return _internal_has_key_id();
}
inline void attestation::clear_key_id() {
  key_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& attestation::key_id() const {
  // @@protoc_insertion_point(field_get:attestation.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void attestation::set_key_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:attestation.key_id)
}
inline std::string* attestation::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:attestation.key_id)
  return _s;
}
inline const std::string& attestation::_internal_key_id() const {
  return key_id_.Get();
}
inline void attestation::_internal_set_key_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* attestation::_internal_mutable_key_id() {
  _has_bits_[0] |= 0x00000002u;
  return key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* attestation::release_key_id() {
  // @@protoc_insertion_point(field_release:attestation.key_id)
  if (!_internal_has_key_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = key_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void attestation::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:attestation.key_id)
}

// optional bytes measurement = 3;
inline bool attestation::_internal_has_measurement() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool attestation::has_measurement() const {
  return _internal_has_measurement();
}
inline void attestation::clear_measurement() {
  measurement_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& attestation::measurement() const {
  // @@protoc_insertion_point(field_get:attestation.measurement)
  return _internal_measurement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void attestation::set_measurement(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 measurement_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:attestation.measurement)
}
inline std::string* attestation::mutable_measurement() {
  std::string* _s = _internal_mutable_measurement();
  // @@protoc_insertion_point(field_mutable:attestation.measurement)
  return _s;
}
inline const std::string& attestation::_internal_measurement() const {
  return measurement_.Get();
}
inline void attestation::_internal_set_measurement(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* attestation::_internal_mutable_measurement() {
  _has_bits_[0] |= 0x00000004u;
  return measurement_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* attestation::release_measurement() {
  // @@protoc_insertion_point(field_release:attestation.measurement)
  if (!_internal_has_measurement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = measurement_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void attestation::set_allocated_measurement(std::string* measurement) {
  if (measurement != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  measurement_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), measurement,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:attestation.measurement)
}

// optional string time = 4;
inline bool attestation::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool attestation::has_time() const {
  return _internal_has_time();
}
inline void attestation::clear_time() {
  time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& attestation::time() const {
  // @@protoc_insertion_point(field_get:attestation.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void attestation::set_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:attestation.time)
}
inline std::string* attestation::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:attestation.time)
  return _s;
}
inline const std::string& attestation::_internal_time() const {
  return time_.Get();
}
inline void attestation::_internal_set_time(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* attestation::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000008u;
  return time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* attestation::release_time() {
  // @@protoc_insertion_point(field_release:attestation.time)
  if (!_internal_has_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void attestation::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:attestation.time)
}

// optional .vse_clause clause = 5;
inline bool attestation::_internal_has_clause() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || clause_ != nullptr);
  return value;
}
inline bool attestation::has_clause() const {
  return _internal_has_clause();
}
inline void attestation::clear_clause() {
  if (clause_ != nullptr) clause_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::vse_clause& attestation::_internal_clause() const {
  const ::vse_clause* p = clause_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& attestation::clause() const {
  // @@protoc_insertion_point(field_get:attestation.clause)
  return _internal_clause();
}
inline void attestation::unsafe_arena_set_allocated_clause(
    ::vse_clause* clause) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clause_);
  }
  clause_ = clause;
  if (clause) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:attestation.clause)
}
inline ::vse_clause* attestation::release_clause() {
  _has_bits_[0] &= ~0x00000020u;
  ::vse_clause* temp = clause_;
  clause_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* attestation::unsafe_arena_release_clause() {
  // @@protoc_insertion_point(field_release:attestation.clause)
  _has_bits_[0] &= ~0x00000020u;
  ::vse_clause* temp = clause_;
  clause_ = nullptr;
  return temp;
}
inline ::vse_clause* attestation::_internal_mutable_clause() {
  _has_bits_[0] |= 0x00000020u;
  if (clause_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    clause_ = p;
  }
  return clause_;
}
inline ::vse_clause* attestation::mutable_clause() {
  ::vse_clause* _msg = _internal_mutable_clause();
  // @@protoc_insertion_point(field_mutable:attestation.clause)
  return _msg;
}
inline void attestation::set_allocated_clause(::vse_clause* clause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clause_;
  }
  if (clause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(clause);
    if (message_arena != submessage_arena) {
      clause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clause, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  clause_ = clause;
  // @@protoc_insertion_point(field_set_allocated:attestation.clause)
}

// optional string description = 6;
inline bool attestation::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool attestation::has_description() const {
  return _internal_has_description();
}
inline void attestation::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& attestation::description() const {
  // @@protoc_insertion_point(field_get:attestation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void attestation::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:attestation.description)
}
inline std::string* attestation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:attestation.description)
  return _s;
}
inline const std::string& attestation::_internal_description() const {
  return description_.Get();
}
inline void attestation::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* attestation::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000010u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* attestation::release_description() {
  // @@protoc_insertion_point(field_release:attestation.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void attestation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:attestation.description)
}

// -------------------------------------------------------------------

// claim_message

// optional string claim_format = 1;
inline bool claim_message::_internal_has_claim_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool claim_message::has_claim_format() const {
  return _internal_has_claim_format();
}
inline void claim_message::clear_claim_format() {
  claim_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& claim_message::claim_format() const {
  // @@protoc_insertion_point(field_get:claim_message.claim_format)
  return _internal_claim_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void claim_message::set_claim_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 claim_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:claim_message.claim_format)
}
inline std::string* claim_message::mutable_claim_format() {
  std::string* _s = _internal_mutable_claim_format();
  // @@protoc_insertion_point(field_mutable:claim_message.claim_format)
  return _s;
}
inline const std::string& claim_message::_internal_claim_format() const {
  return claim_format_.Get();
}
inline void claim_message::_internal_set_claim_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  claim_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* claim_message::_internal_mutable_claim_format() {
  _has_bits_[0] |= 0x00000001u;
  return claim_format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* claim_message::release_claim_format() {
  // @@protoc_insertion_point(field_release:claim_message.claim_format)
  if (!_internal_has_claim_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = claim_format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (claim_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    claim_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void claim_message::set_allocated_claim_format(std::string* claim_format) {
  if (claim_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  claim_format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), claim_format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (claim_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    claim_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:claim_message.claim_format)
}

// optional string claim_descriptor = 2;
inline bool claim_message::_internal_has_claim_descriptor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool claim_message::has_claim_descriptor() const {
  return _internal_has_claim_descriptor();
}
inline void claim_message::clear_claim_descriptor() {
  claim_descriptor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& claim_message::claim_descriptor() const {
  // @@protoc_insertion_point(field_get:claim_message.claim_descriptor)
  return _internal_claim_descriptor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void claim_message::set_claim_descriptor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 claim_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:claim_message.claim_descriptor)
}
inline std::string* claim_message::mutable_claim_descriptor() {
  std::string* _s = _internal_mutable_claim_descriptor();
  // @@protoc_insertion_point(field_mutable:claim_message.claim_descriptor)
  return _s;
}
inline const std::string& claim_message::_internal_claim_descriptor() const {
  return claim_descriptor_.Get();
}
inline void claim_message::_internal_set_claim_descriptor(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  claim_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* claim_message::_internal_mutable_claim_descriptor() {
  _has_bits_[0] |= 0x00000002u;
  return claim_descriptor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* claim_message::release_claim_descriptor() {
  // @@protoc_insertion_point(field_release:claim_message.claim_descriptor)
  if (!_internal_has_claim_descriptor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = claim_descriptor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (claim_descriptor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    claim_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void claim_message::set_allocated_claim_descriptor(std::string* claim_descriptor) {
  if (claim_descriptor != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  claim_descriptor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), claim_descriptor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (claim_descriptor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    claim_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:claim_message.claim_descriptor)
}

// optional string not_before = 3;
inline bool claim_message::_internal_has_not_before() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool claim_message::has_not_before() const {
  return _internal_has_not_before();
}
inline void claim_message::clear_not_before() {
  not_before_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& claim_message::not_before() const {
  // @@protoc_insertion_point(field_get:claim_message.not_before)
  return _internal_not_before();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void claim_message::set_not_before(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:claim_message.not_before)
}
inline std::string* claim_message::mutable_not_before() {
  std::string* _s = _internal_mutable_not_before();
  // @@protoc_insertion_point(field_mutable:claim_message.not_before)
  return _s;
}
inline const std::string& claim_message::_internal_not_before() const {
  return not_before_.Get();
}
inline void claim_message::_internal_set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* claim_message::_internal_mutable_not_before() {
  _has_bits_[0] |= 0x00000004u;
  return not_before_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* claim_message::release_not_before() {
  // @@protoc_insertion_point(field_release:claim_message.not_before)
  if (!_internal_has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = not_before_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_before_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void claim_message::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  not_before_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_before_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_before_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:claim_message.not_before)
}

// optional string not_after = 4;
inline bool claim_message::_internal_has_not_after() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool claim_message::has_not_after() const {
  return _internal_has_not_after();
}
inline void claim_message::clear_not_after() {
  not_after_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& claim_message::not_after() const {
  // @@protoc_insertion_point(field_get:claim_message.not_after)
  return _internal_not_after();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void claim_message::set_not_after(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:claim_message.not_after)
}
inline std::string* claim_message::mutable_not_after() {
  std::string* _s = _internal_mutable_not_after();
  // @@protoc_insertion_point(field_mutable:claim_message.not_after)
  return _s;
}
inline const std::string& claim_message::_internal_not_after() const {
  return not_after_.Get();
}
inline void claim_message::_internal_set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* claim_message::_internal_mutable_not_after() {
  _has_bits_[0] |= 0x00000008u;
  return not_after_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* claim_message::release_not_after() {
  // @@protoc_insertion_point(field_release:claim_message.not_after)
  if (!_internal_has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = not_after_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_after_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void claim_message::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  not_after_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (not_after_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    not_after_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:claim_message.not_after)
}

// optional bytes serialized_claim = 5;
inline bool claim_message::_internal_has_serialized_claim() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool claim_message::has_serialized_claim() const {
  return _internal_has_serialized_claim();
}
inline void claim_message::clear_serialized_claim() {
  serialized_claim_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& claim_message::serialized_claim() const {
  // @@protoc_insertion_point(field_get:claim_message.serialized_claim)
  return _internal_serialized_claim();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void claim_message::set_serialized_claim(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 serialized_claim_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:claim_message.serialized_claim)
}
inline std::string* claim_message::mutable_serialized_claim() {
  std::string* _s = _internal_mutable_serialized_claim();
  // @@protoc_insertion_point(field_mutable:claim_message.serialized_claim)
  return _s;
}
inline const std::string& claim_message::_internal_serialized_claim() const {
  return serialized_claim_.Get();
}
inline void claim_message::_internal_set_serialized_claim(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  serialized_claim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* claim_message::_internal_mutable_serialized_claim() {
  _has_bits_[0] |= 0x00000010u;
  return serialized_claim_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* claim_message::release_serialized_claim() {
  // @@protoc_insertion_point(field_release:claim_message.serialized_claim)
  if (!_internal_has_serialized_claim()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = serialized_claim_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_claim_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_claim_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void claim_message::set_allocated_serialized_claim(std::string* serialized_claim) {
  if (serialized_claim != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  serialized_claim_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_claim,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_claim_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_claim_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:claim_message.serialized_claim)
}

// -------------------------------------------------------------------

// signed_claim_message

// optional bytes serialized_claim_message = 1;
inline bool signed_claim_message::_internal_has_serialized_claim_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool signed_claim_message::has_serialized_claim_message() const {
  return _internal_has_serialized_claim_message();
}
inline void signed_claim_message::clear_serialized_claim_message() {
  serialized_claim_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& signed_claim_message::serialized_claim_message() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.serialized_claim_message)
  return _internal_serialized_claim_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void signed_claim_message::set_serialized_claim_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serialized_claim_message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:signed_claim_message.serialized_claim_message)
}
inline std::string* signed_claim_message::mutable_serialized_claim_message() {
  std::string* _s = _internal_mutable_serialized_claim_message();
  // @@protoc_insertion_point(field_mutable:signed_claim_message.serialized_claim_message)
  return _s;
}
inline const std::string& signed_claim_message::_internal_serialized_claim_message() const {
  return serialized_claim_message_.Get();
}
inline void signed_claim_message::_internal_set_serialized_claim_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serialized_claim_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* signed_claim_message::_internal_mutable_serialized_claim_message() {
  _has_bits_[0] |= 0x00000001u;
  return serialized_claim_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* signed_claim_message::release_serialized_claim_message() {
  // @@protoc_insertion_point(field_release:signed_claim_message.serialized_claim_message)
  if (!_internal_has_serialized_claim_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = serialized_claim_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_claim_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_claim_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void signed_claim_message::set_allocated_serialized_claim_message(std::string* serialized_claim_message) {
  if (serialized_claim_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serialized_claim_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_claim_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_claim_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_claim_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.serialized_claim_message)
}

// optional .key_message signing_key = 2;
inline bool signed_claim_message::_internal_has_signing_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || signing_key_ != nullptr);
  return value;
}
inline bool signed_claim_message::has_signing_key() const {
  return _internal_has_signing_key();
}
inline void signed_claim_message::clear_signing_key() {
  if (signing_key_ != nullptr) signing_key_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::key_message& signed_claim_message::_internal_signing_key() const {
  const ::key_message* p = signing_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& signed_claim_message::signing_key() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signing_key)
  return _internal_signing_key();
}
inline void signed_claim_message::unsafe_arena_set_allocated_signing_key(
    ::key_message* signing_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signing_key_);
  }
  signing_key_ = signing_key;
  if (signing_key) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signed_claim_message.signing_key)
}
inline ::key_message* signed_claim_message::release_signing_key() {
  _has_bits_[0] &= ~0x00000008u;
  ::key_message* temp = signing_key_;
  signing_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* signed_claim_message::unsafe_arena_release_signing_key() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signing_key)
  _has_bits_[0] &= ~0x00000008u;
  ::key_message* temp = signing_key_;
  signing_key_ = nullptr;
  return temp;
}
inline ::key_message* signed_claim_message::_internal_mutable_signing_key() {
  _has_bits_[0] |= 0x00000008u;
  if (signing_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    signing_key_ = p;
  }
  return signing_key_;
}
inline ::key_message* signed_claim_message::mutable_signing_key() {
  ::key_message* _msg = _internal_mutable_signing_key();
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signing_key)
  return _msg;
}
inline void signed_claim_message::set_allocated_signing_key(::key_message* signing_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signing_key_;
  }
  if (signing_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(signing_key);
    if (message_arena != submessage_arena) {
      signing_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signing_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signing_key_ = signing_key;
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signing_key)
}

// optional string signing_algorithm = 3;
inline bool signed_claim_message::_internal_has_signing_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool signed_claim_message::has_signing_algorithm() const {
  return _internal_has_signing_algorithm();
}
inline void signed_claim_message::clear_signing_algorithm() {
  signing_algorithm_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& signed_claim_message::signing_algorithm() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signing_algorithm)
  return _internal_signing_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void signed_claim_message::set_signing_algorithm(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 signing_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:signed_claim_message.signing_algorithm)
}
inline std::string* signed_claim_message::mutable_signing_algorithm() {
  std::string* _s = _internal_mutable_signing_algorithm();
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signing_algorithm)
  return _s;
}
inline const std::string& signed_claim_message::_internal_signing_algorithm() const {
  return signing_algorithm_.Get();
}
inline void signed_claim_message::_internal_set_signing_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signing_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* signed_claim_message::_internal_mutable_signing_algorithm() {
  _has_bits_[0] |= 0x00000002u;
  return signing_algorithm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* signed_claim_message::release_signing_algorithm() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signing_algorithm)
  if (!_internal_has_signing_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = signing_algorithm_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signing_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signing_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void signed_claim_message::set_allocated_signing_algorithm(std::string* signing_algorithm) {
  if (signing_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signing_algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signing_algorithm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signing_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signing_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signing_algorithm)
}

// optional bytes signature = 4;
inline bool signed_claim_message::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool signed_claim_message::has_signature() const {
  return _internal_has_signature();
}
inline void signed_claim_message::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& signed_claim_message::signature() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void signed_claim_message::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:signed_claim_message.signature)
}
inline std::string* signed_claim_message::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signature)
  return _s;
}
inline const std::string& signed_claim_message::_internal_signature() const {
  return signature_.Get();
}
inline void signed_claim_message::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* signed_claim_message::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* signed_claim_message::release_signature() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void signed_claim_message::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signature)
}

// -------------------------------------------------------------------

// oe_assertion

// optional bytes user_data = 1;
inline bool oe_assertion::_internal_has_user_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool oe_assertion::has_user_data() const {
  return _internal_has_user_data();
}
inline void oe_assertion::clear_user_data() {
  user_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& oe_assertion::user_data() const {
  // @@protoc_insertion_point(field_get:oe_assertion.user_data)
  return _internal_user_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void oe_assertion::set_user_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oe_assertion.user_data)
}
inline std::string* oe_assertion::mutable_user_data() {
  std::string* _s = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:oe_assertion.user_data)
  return _s;
}
inline const std::string& oe_assertion::_internal_user_data() const {
  return user_data_.Get();
}
inline void oe_assertion::_internal_set_user_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* oe_assertion::_internal_mutable_user_data() {
  _has_bits_[0] |= 0x00000001u;
  return user_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* oe_assertion::release_user_data() {
  // @@protoc_insertion_point(field_release:oe_assertion.user_data)
  if (!_internal_has_user_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void oe_assertion::set_allocated_user_data(std::string* user_data) {
  if (user_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oe_assertion.user_data)
}

// optional bytes oe_report = 2;
inline bool oe_assertion::_internal_has_oe_report() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool oe_assertion::has_oe_report() const {
  return _internal_has_oe_report();
}
inline void oe_assertion::clear_oe_report() {
  oe_report_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& oe_assertion::oe_report() const {
  // @@protoc_insertion_point(field_get:oe_assertion.oe_report)
  return _internal_oe_report();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void oe_assertion::set_oe_report(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 oe_report_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oe_assertion.oe_report)
}
inline std::string* oe_assertion::mutable_oe_report() {
  std::string* _s = _internal_mutable_oe_report();
  // @@protoc_insertion_point(field_mutable:oe_assertion.oe_report)
  return _s;
}
inline const std::string& oe_assertion::_internal_oe_report() const {
  return oe_report_.Get();
}
inline void oe_assertion::_internal_set_oe_report(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  oe_report_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* oe_assertion::_internal_mutable_oe_report() {
  _has_bits_[0] |= 0x00000002u;
  return oe_report_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* oe_assertion::release_oe_report() {
  // @@protoc_insertion_point(field_release:oe_assertion.oe_report)
  if (!_internal_has_oe_report()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = oe_report_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (oe_report_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    oe_report_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void oe_assertion::set_allocated_oe_report(std::string* oe_report) {
  if (oe_report != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  oe_report_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oe_report,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (oe_report_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    oe_report_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oe_assertion.oe_report)
}

// -------------------------------------------------------------------

// evidence

// optional string evidence_type = 1;
inline bool evidence::_internal_has_evidence_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool evidence::has_evidence_type() const {
  return _internal_has_evidence_type();
}
inline void evidence::clear_evidence_type() {
  evidence_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& evidence::evidence_type() const {
  // @@protoc_insertion_point(field_get:evidence.evidence_type)
  return _internal_evidence_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void evidence::set_evidence_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:evidence.evidence_type)
}
inline std::string* evidence::mutable_evidence_type() {
  std::string* _s = _internal_mutable_evidence_type();
  // @@protoc_insertion_point(field_mutable:evidence.evidence_type)
  return _s;
}
inline const std::string& evidence::_internal_evidence_type() const {
  return evidence_type_.Get();
}
inline void evidence::_internal_set_evidence_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* evidence::_internal_mutable_evidence_type() {
  _has_bits_[0] |= 0x00000001u;
  return evidence_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* evidence::release_evidence_type() {
  // @@protoc_insertion_point(field_release:evidence.evidence_type)
  if (!_internal_has_evidence_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = evidence_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (evidence_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void evidence::set_allocated_evidence_type(std::string* evidence_type) {
  if (evidence_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  evidence_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), evidence_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (evidence_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:evidence.evidence_type)
}

// optional bytes serialized_evidence = 2;
inline bool evidence::_internal_has_serialized_evidence() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool evidence::has_serialized_evidence() const {
  return _internal_has_serialized_evidence();
}
inline void evidence::clear_serialized_evidence() {
  serialized_evidence_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& evidence::serialized_evidence() const {
  // @@protoc_insertion_point(field_get:evidence.serialized_evidence)
  return _internal_serialized_evidence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void evidence::set_serialized_evidence(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 serialized_evidence_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:evidence.serialized_evidence)
}
inline std::string* evidence::mutable_serialized_evidence() {
  std::string* _s = _internal_mutable_serialized_evidence();
  // @@protoc_insertion_point(field_mutable:evidence.serialized_evidence)
  return _s;
}
inline const std::string& evidence::_internal_serialized_evidence() const {
  return serialized_evidence_.Get();
}
inline void evidence::_internal_set_serialized_evidence(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_evidence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* evidence::_internal_mutable_serialized_evidence() {
  _has_bits_[0] |= 0x00000002u;
  return serialized_evidence_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* evidence::release_serialized_evidence() {
  // @@protoc_insertion_point(field_release:evidence.serialized_evidence)
  if (!_internal_has_serialized_evidence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = serialized_evidence_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_evidence_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_evidence_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void evidence::set_allocated_serialized_evidence(std::string* serialized_evidence) {
  if (serialized_evidence != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_evidence_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_evidence,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_evidence_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialized_evidence_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:evidence.serialized_evidence)
}

// -------------------------------------------------------------------

// evidence_package

// optional string prover_type = 1;
inline bool evidence_package::_internal_has_prover_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool evidence_package::has_prover_type() const {
  return _internal_has_prover_type();
}
inline void evidence_package::clear_prover_type() {
  prover_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& evidence_package::prover_type() const {
  // @@protoc_insertion_point(field_get:evidence_package.prover_type)
  return _internal_prover_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void evidence_package::set_prover_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 prover_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:evidence_package.prover_type)
}
inline std::string* evidence_package::mutable_prover_type() {
  std::string* _s = _internal_mutable_prover_type();
  // @@protoc_insertion_point(field_mutable:evidence_package.prover_type)
  return _s;
}
inline const std::string& evidence_package::_internal_prover_type() const {
  return prover_type_.Get();
}
inline void evidence_package::_internal_set_prover_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prover_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* evidence_package::_internal_mutable_prover_type() {
  _has_bits_[0] |= 0x00000001u;
  return prover_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* evidence_package::release_prover_type() {
  // @@protoc_insertion_point(field_release:evidence_package.prover_type)
  if (!_internal_has_prover_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = prover_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prover_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prover_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void evidence_package::set_allocated_prover_type(std::string* prover_type) {
  if (prover_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prover_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prover_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prover_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:evidence_package.prover_type)
}

// repeated .evidence fact_assertion = 2;
inline int evidence_package::_internal_fact_assertion_size() const {
  return fact_assertion_.size();
}
inline int evidence_package::fact_assertion_size() const {
  return _internal_fact_assertion_size();
}
inline void evidence_package::clear_fact_assertion() {
  fact_assertion_.Clear();
}
inline ::evidence* evidence_package::mutable_fact_assertion(int index) {
  // @@protoc_insertion_point(field_mutable:evidence_package.fact_assertion)
  return fact_assertion_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
evidence_package::mutable_fact_assertion() {
  // @@protoc_insertion_point(field_mutable_list:evidence_package.fact_assertion)
  return &fact_assertion_;
}
inline const ::evidence& evidence_package::_internal_fact_assertion(int index) const {
  return fact_assertion_.Get(index);
}
inline const ::evidence& evidence_package::fact_assertion(int index) const {
  // @@protoc_insertion_point(field_get:evidence_package.fact_assertion)
  return _internal_fact_assertion(index);
}
inline ::evidence* evidence_package::_internal_add_fact_assertion() {
  return fact_assertion_.Add();
}
inline ::evidence* evidence_package::add_fact_assertion() {
  ::evidence* _add = _internal_add_fact_assertion();
  // @@protoc_insertion_point(field_add:evidence_package.fact_assertion)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
evidence_package::fact_assertion() const {
  // @@protoc_insertion_point(field_list:evidence_package.fact_assertion)
  return fact_assertion_;
}

// -------------------------------------------------------------------

// certifier_rules

// repeated string rule = 1;
inline int certifier_rules::_internal_rule_size() const {
  return rule_.size();
}
inline int certifier_rules::rule_size() const {
  return _internal_rule_size();
}
inline void certifier_rules::clear_rule() {
  rule_.Clear();
}
inline std::string* certifier_rules::add_rule() {
  std::string* _s = _internal_add_rule();
  // @@protoc_insertion_point(field_add_mutable:certifier_rules.rule)
  return _s;
}
inline const std::string& certifier_rules::_internal_rule(int index) const {
  return rule_.Get(index);
}
inline const std::string& certifier_rules::rule(int index) const {
  // @@protoc_insertion_point(field_get:certifier_rules.rule)
  return _internal_rule(index);
}
inline std::string* certifier_rules::mutable_rule(int index) {
  // @@protoc_insertion_point(field_mutable:certifier_rules.rule)
  return rule_.Mutable(index);
}
inline void certifier_rules::set_rule(int index, const std::string& value) {
  rule_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:certifier_rules.rule)
}
inline void certifier_rules::set_rule(int index, std::string&& value) {
  rule_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:certifier_rules.rule)
}
inline void certifier_rules::set_rule(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rule_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:certifier_rules.rule)
}
inline void certifier_rules::set_rule(int index, const char* value, size_t size) {
  rule_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:certifier_rules.rule)
}
inline std::string* certifier_rules::_internal_add_rule() {
  return rule_.Add();
}
inline void certifier_rules::add_rule(const std::string& value) {
  rule_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:certifier_rules.rule)
}
inline void certifier_rules::add_rule(std::string&& value) {
  rule_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:certifier_rules.rule)
}
inline void certifier_rules::add_rule(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rule_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:certifier_rules.rule)
}
inline void certifier_rules::add_rule(const char* value, size_t size) {
  rule_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:certifier_rules.rule)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
certifier_rules::rule() const {
  // @@protoc_insertion_point(field_list:certifier_rules.rule)
  return rule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
certifier_rules::mutable_rule() {
  // @@protoc_insertion_point(field_mutable_list:certifier_rules.rule)
  return &rule_;
}

// -------------------------------------------------------------------

// proved_statements

// repeated .vse_clause proved = 1;
inline int proved_statements::_internal_proved_size() const {
  return proved_.size();
}
inline int proved_statements::proved_size() const {
  return _internal_proved_size();
}
inline void proved_statements::clear_proved() {
  proved_.Clear();
}
inline ::vse_clause* proved_statements::mutable_proved(int index) {
  // @@protoc_insertion_point(field_mutable:proved_statements.proved)
  return proved_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
proved_statements::mutable_proved() {
  // @@protoc_insertion_point(field_mutable_list:proved_statements.proved)
  return &proved_;
}
inline const ::vse_clause& proved_statements::_internal_proved(int index) const {
  return proved_.Get(index);
}
inline const ::vse_clause& proved_statements::proved(int index) const {
  // @@protoc_insertion_point(field_get:proved_statements.proved)
  return _internal_proved(index);
}
inline ::vse_clause* proved_statements::_internal_add_proved() {
  return proved_.Add();
}
inline ::vse_clause* proved_statements::add_proved() {
  ::vse_clause* _add = _internal_add_proved();
  // @@protoc_insertion_point(field_add:proved_statements.proved)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
proved_statements::proved() const {
  // @@protoc_insertion_point(field_list:proved_statements.proved)
  return proved_;
}

// -------------------------------------------------------------------

// proof_step

// optional .vse_clause s1 = 1;
inline bool proof_step::_internal_has_s1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || s1_ != nullptr);
  return value;
}
inline bool proof_step::has_s1() const {
  return _internal_has_s1();
}
inline void proof_step::clear_s1() {
  if (s1_ != nullptr) s1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::vse_clause& proof_step::_internal_s1() const {
  const ::vse_clause* p = s1_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::s1() const {
  // @@protoc_insertion_point(field_get:proof_step.s1)
  return _internal_s1();
}
inline void proof_step::unsafe_arena_set_allocated_s1(
    ::vse_clause* s1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s1_);
  }
  s1_ = s1;
  if (s1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proof_step.s1)
}
inline ::vse_clause* proof_step::release_s1() {
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = s1_;
  s1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* proof_step::unsafe_arena_release_s1() {
  // @@protoc_insertion_point(field_release:proof_step.s1)
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = s1_;
  s1_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_s1() {
  _has_bits_[0] |= 0x00000001u;
  if (s1_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    s1_ = p;
  }
  return s1_;
}
inline ::vse_clause* proof_step::mutable_s1() {
  ::vse_clause* _msg = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:proof_step.s1)
  return _msg;
}
inline void proof_step::set_allocated_s1(::vse_clause* s1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete s1_;
  }
  if (s1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(s1);
    if (message_arena != submessage_arena) {
      s1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s1_ = s1;
  // @@protoc_insertion_point(field_set_allocated:proof_step.s1)
}

// optional .vse_clause s2 = 2;
inline bool proof_step::_internal_has_s2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || s2_ != nullptr);
  return value;
}
inline bool proof_step::has_s2() const {
  return _internal_has_s2();
}
inline void proof_step::clear_s2() {
  if (s2_ != nullptr) s2_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::vse_clause& proof_step::_internal_s2() const {
  const ::vse_clause* p = s2_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::s2() const {
  // @@protoc_insertion_point(field_get:proof_step.s2)
  return _internal_s2();
}
inline void proof_step::unsafe_arena_set_allocated_s2(
    ::vse_clause* s2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s2_);
  }
  s2_ = s2;
  if (s2) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proof_step.s2)
}
inline ::vse_clause* proof_step::release_s2() {
  _has_bits_[0] &= ~0x00000002u;
  ::vse_clause* temp = s2_;
  s2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* proof_step::unsafe_arena_release_s2() {
  // @@protoc_insertion_point(field_release:proof_step.s2)
  _has_bits_[0] &= ~0x00000002u;
  ::vse_clause* temp = s2_;
  s2_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_s2() {
  _has_bits_[0] |= 0x00000002u;
  if (s2_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    s2_ = p;
  }
  return s2_;
}
inline ::vse_clause* proof_step::mutable_s2() {
  ::vse_clause* _msg = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:proof_step.s2)
  return _msg;
}
inline void proof_step::set_allocated_s2(::vse_clause* s2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete s2_;
  }
  if (s2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(s2);
    if (message_arena != submessage_arena) {
      s2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s2_ = s2;
  // @@protoc_insertion_point(field_set_allocated:proof_step.s2)
}

// optional .vse_clause conclusion = 3;
inline bool proof_step::_internal_has_conclusion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || conclusion_ != nullptr);
  return value;
}
inline bool proof_step::has_conclusion() const {
  return _internal_has_conclusion();
}
inline void proof_step::clear_conclusion() {
  if (conclusion_ != nullptr) conclusion_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::vse_clause& proof_step::_internal_conclusion() const {
  const ::vse_clause* p = conclusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::conclusion() const {
  // @@protoc_insertion_point(field_get:proof_step.conclusion)
  return _internal_conclusion();
}
inline void proof_step::unsafe_arena_set_allocated_conclusion(
    ::vse_clause* conclusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conclusion_);
  }
  conclusion_ = conclusion;
  if (conclusion) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proof_step.conclusion)
}
inline ::vse_clause* proof_step::release_conclusion() {
  _has_bits_[0] &= ~0x00000004u;
  ::vse_clause* temp = conclusion_;
  conclusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* proof_step::unsafe_arena_release_conclusion() {
  // @@protoc_insertion_point(field_release:proof_step.conclusion)
  _has_bits_[0] &= ~0x00000004u;
  ::vse_clause* temp = conclusion_;
  conclusion_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_conclusion() {
  _has_bits_[0] |= 0x00000004u;
  if (conclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    conclusion_ = p;
  }
  return conclusion_;
}
inline ::vse_clause* proof_step::mutable_conclusion() {
  ::vse_clause* _msg = _internal_mutable_conclusion();
  // @@protoc_insertion_point(field_mutable:proof_step.conclusion)
  return _msg;
}
inline void proof_step::set_allocated_conclusion(::vse_clause* conclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete conclusion_;
  }
  if (conclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(conclusion);
    if (message_arena != submessage_arena) {
      conclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conclusion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  conclusion_ = conclusion;
  // @@protoc_insertion_point(field_set_allocated:proof_step.conclusion)
}

// optional int32 rule_applied = 4;
inline bool proof_step::_internal_has_rule_applied() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool proof_step::has_rule_applied() const {
  return _internal_has_rule_applied();
}
inline void proof_step::clear_rule_applied() {
  rule_applied_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t proof_step::_internal_rule_applied() const {
  return rule_applied_;
}
inline int32_t proof_step::rule_applied() const {
  // @@protoc_insertion_point(field_get:proof_step.rule_applied)
  return _internal_rule_applied();
}
inline void proof_step::_internal_set_rule_applied(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  rule_applied_ = value;
}
inline void proof_step::set_rule_applied(int32_t value) {
  _internal_set_rule_applied(value);
  // @@protoc_insertion_point(field_set:proof_step.rule_applied)
}

// -------------------------------------------------------------------

// proof

// optional .vse_clause to_prove = 1;
inline bool proof::_internal_has_to_prove() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || to_prove_ != nullptr);
  return value;
}
inline bool proof::has_to_prove() const {
  return _internal_has_to_prove();
}
inline void proof::clear_to_prove() {
  if (to_prove_ != nullptr) to_prove_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::vse_clause& proof::_internal_to_prove() const {
  const ::vse_clause* p = to_prove_;
  return p != nullptr ? *p : reinterpret_cast<const ::vse_clause&>(
      ::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof::to_prove() const {
  // @@protoc_insertion_point(field_get:proof.to_prove)
  return _internal_to_prove();
}
inline void proof::unsafe_arena_set_allocated_to_prove(
    ::vse_clause* to_prove) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_prove_);
  }
  to_prove_ = to_prove;
  if (to_prove) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proof.to_prove)
}
inline ::vse_clause* proof::release_to_prove() {
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = to_prove_;
  to_prove_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vse_clause* proof::unsafe_arena_release_to_prove() {
  // @@protoc_insertion_point(field_release:proof.to_prove)
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = to_prove_;
  to_prove_ = nullptr;
  return temp;
}
inline ::vse_clause* proof::_internal_mutable_to_prove() {
  _has_bits_[0] |= 0x00000001u;
  if (to_prove_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaForAllocation());
    to_prove_ = p;
  }
  return to_prove_;
}
inline ::vse_clause* proof::mutable_to_prove() {
  ::vse_clause* _msg = _internal_mutable_to_prove();
  // @@protoc_insertion_point(field_mutable:proof.to_prove)
  return _msg;
}
inline void proof::set_allocated_to_prove(::vse_clause* to_prove) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete to_prove_;
  }
  if (to_prove) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vse_clause>::GetOwningArena(to_prove);
    if (message_arena != submessage_arena) {
      to_prove = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_prove, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  to_prove_ = to_prove;
  // @@protoc_insertion_point(field_set_allocated:proof.to_prove)
}

// repeated .vse_clause already_proved = 2;
inline int proof::_internal_already_proved_size() const {
  return already_proved_.size();
}
inline int proof::already_proved_size() const {
  return _internal_already_proved_size();
}
inline void proof::clear_already_proved() {
  already_proved_.Clear();
}
inline ::vse_clause* proof::mutable_already_proved(int index) {
  // @@protoc_insertion_point(field_mutable:proof.already_proved)
  return already_proved_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
proof::mutable_already_proved() {
  // @@protoc_insertion_point(field_mutable_list:proof.already_proved)
  return &already_proved_;
}
inline const ::vse_clause& proof::_internal_already_proved(int index) const {
  return already_proved_.Get(index);
}
inline const ::vse_clause& proof::already_proved(int index) const {
  // @@protoc_insertion_point(field_get:proof.already_proved)
  return _internal_already_proved(index);
}
inline ::vse_clause* proof::_internal_add_already_proved() {
  return already_proved_.Add();
}
inline ::vse_clause* proof::add_already_proved() {
  ::vse_clause* _add = _internal_add_already_proved();
  // @@protoc_insertion_point(field_add:proof.already_proved)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
proof::already_proved() const {
  // @@protoc_insertion_point(field_list:proof.already_proved)
  return already_proved_;
}

// repeated .proof_step steps = 3;
inline int proof::_internal_steps_size() const {
  return steps_.size();
}
inline int proof::steps_size() const {
  return _internal_steps_size();
}
inline void proof::clear_steps() {
  steps_.Clear();
}
inline ::proof_step* proof::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:proof.steps)
  return steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >*
proof::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:proof.steps)
  return &steps_;
}
inline const ::proof_step& proof::_internal_steps(int index) const {
  return steps_.Get(index);
}
inline const ::proof_step& proof::steps(int index) const {
  // @@protoc_insertion_point(field_get:proof.steps)
  return _internal_steps(index);
}
inline ::proof_step* proof::_internal_add_steps() {
  return steps_.Add();
}
inline ::proof_step* proof::add_steps() {
  ::proof_step* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:proof.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >&
proof::steps() const {
  // @@protoc_insertion_point(field_list:proof.steps)
  return steps_;
}

// -------------------------------------------------------------------

// trust_request_message

// optional string requesting_enclave_tag = 1;
inline bool trust_request_message::_internal_has_requesting_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trust_request_message::has_requesting_enclave_tag() const {
  return _internal_has_requesting_enclave_tag();
}
inline void trust_request_message::clear_requesting_enclave_tag() {
  requesting_enclave_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trust_request_message::requesting_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_request_message.requesting_enclave_tag)
  return _internal_requesting_enclave_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_request_message::set_requesting_enclave_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_request_message.requesting_enclave_tag)
}
inline std::string* trust_request_message::mutable_requesting_enclave_tag() {
  std::string* _s = _internal_mutable_requesting_enclave_tag();
  // @@protoc_insertion_point(field_mutable:trust_request_message.requesting_enclave_tag)
  return _s;
}
inline const std::string& trust_request_message::_internal_requesting_enclave_tag() const {
  return requesting_enclave_tag_.Get();
}
inline void trust_request_message::_internal_set_requesting_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_request_message::_internal_mutable_requesting_enclave_tag() {
  _has_bits_[0] |= 0x00000001u;
  return requesting_enclave_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_request_message::release_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_request_message.requesting_enclave_tag)
  if (!_internal_has_requesting_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = requesting_enclave_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_request_message::set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag) {
  if (requesting_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  requesting_enclave_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_enclave_tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.requesting_enclave_tag)
}

// optional string providing_enclave_tag = 2;
inline bool trust_request_message::_internal_has_providing_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trust_request_message::has_providing_enclave_tag() const {
  return _internal_has_providing_enclave_tag();
}
inline void trust_request_message::clear_providing_enclave_tag() {
  providing_enclave_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trust_request_message::providing_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_request_message.providing_enclave_tag)
  return _internal_providing_enclave_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_request_message::set_providing_enclave_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_request_message.providing_enclave_tag)
}
inline std::string* trust_request_message::mutable_providing_enclave_tag() {
  std::string* _s = _internal_mutable_providing_enclave_tag();
  // @@protoc_insertion_point(field_mutable:trust_request_message.providing_enclave_tag)
  return _s;
}
inline const std::string& trust_request_message::_internal_providing_enclave_tag() const {
  return providing_enclave_tag_.Get();
}
inline void trust_request_message::_internal_set_providing_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_request_message::_internal_mutable_providing_enclave_tag() {
  _has_bits_[0] |= 0x00000002u;
  return providing_enclave_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_request_message::release_providing_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_request_message.providing_enclave_tag)
  if (!_internal_has_providing_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = providing_enclave_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (providing_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_request_message::set_allocated_providing_enclave_tag(std::string* providing_enclave_tag) {
  if (providing_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  providing_enclave_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), providing_enclave_tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (providing_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.providing_enclave_tag)
}

// optional string submitted_evidence_type = 3;
inline bool trust_request_message::_internal_has_submitted_evidence_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool trust_request_message::has_submitted_evidence_type() const {
  return _internal_has_submitted_evidence_type();
}
inline void trust_request_message::clear_submitted_evidence_type() {
  submitted_evidence_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& trust_request_message::submitted_evidence_type() const {
  // @@protoc_insertion_point(field_get:trust_request_message.submitted_evidence_type)
  return _internal_submitted_evidence_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_request_message::set_submitted_evidence_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 submitted_evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_request_message.submitted_evidence_type)
}
inline std::string* trust_request_message::mutable_submitted_evidence_type() {
  std::string* _s = _internal_mutable_submitted_evidence_type();
  // @@protoc_insertion_point(field_mutable:trust_request_message.submitted_evidence_type)
  return _s;
}
inline const std::string& trust_request_message::_internal_submitted_evidence_type() const {
  return submitted_evidence_type_.Get();
}
inline void trust_request_message::_internal_set_submitted_evidence_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  submitted_evidence_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_request_message::_internal_mutable_submitted_evidence_type() {
  _has_bits_[0] |= 0x00000004u;
  return submitted_evidence_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_request_message::release_submitted_evidence_type() {
  // @@protoc_insertion_point(field_release:trust_request_message.submitted_evidence_type)
  if (!_internal_has_submitted_evidence_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = submitted_evidence_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (submitted_evidence_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    submitted_evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_request_message::set_allocated_submitted_evidence_type(std::string* submitted_evidence_type) {
  if (submitted_evidence_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  submitted_evidence_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), submitted_evidence_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (submitted_evidence_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    submitted_evidence_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.submitted_evidence_type)
}

// optional string purpose = 4;
inline bool trust_request_message::_internal_has_purpose() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool trust_request_message::has_purpose() const {
  return _internal_has_purpose();
}
inline void trust_request_message::clear_purpose() {
  purpose_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& trust_request_message::purpose() const {
  // @@protoc_insertion_point(field_get:trust_request_message.purpose)
  return _internal_purpose();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_request_message::set_purpose(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 purpose_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_request_message.purpose)
}
inline std::string* trust_request_message::mutable_purpose() {
  std::string* _s = _internal_mutable_purpose();
  // @@protoc_insertion_point(field_mutable:trust_request_message.purpose)
  return _s;
}
inline const std::string& trust_request_message::_internal_purpose() const {
  return purpose_.Get();
}
inline void trust_request_message::_internal_set_purpose(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  purpose_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_request_message::_internal_mutable_purpose() {
  _has_bits_[0] |= 0x00000008u;
  return purpose_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_request_message::release_purpose() {
  // @@protoc_insertion_point(field_release:trust_request_message.purpose)
  if (!_internal_has_purpose()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = purpose_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (purpose_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_request_message::set_allocated_purpose(std::string* purpose) {
  if (purpose != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  purpose_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), purpose,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (purpose_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.purpose)
}

// optional .evidence_package support = 5;
inline bool trust_request_message::_internal_has_support() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || support_ != nullptr);
  return value;
}
inline bool trust_request_message::has_support() const {
  return _internal_has_support();
}
inline void trust_request_message::clear_support() {
  if (support_ != nullptr) support_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::evidence_package& trust_request_message::_internal_support() const {
  const ::evidence_package* p = support_;
  return p != nullptr ? *p : reinterpret_cast<const ::evidence_package&>(
      ::_evidence_package_default_instance_);
}
inline const ::evidence_package& trust_request_message::support() const {
  // @@protoc_insertion_point(field_get:trust_request_message.support)
  return _internal_support();
}
inline void trust_request_message::unsafe_arena_set_allocated_support(
    ::evidence_package* support) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(support_);
  }
  support_ = support;
  if (support) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trust_request_message.support)
}
inline ::evidence_package* trust_request_message::release_support() {
  _has_bits_[0] &= ~0x00000010u;
  ::evidence_package* temp = support_;
  support_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::evidence_package* trust_request_message::unsafe_arena_release_support() {
  // @@protoc_insertion_point(field_release:trust_request_message.support)
  _has_bits_[0] &= ~0x00000010u;
  ::evidence_package* temp = support_;
  support_ = nullptr;
  return temp;
}
inline ::evidence_package* trust_request_message::_internal_mutable_support() {
  _has_bits_[0] |= 0x00000010u;
  if (support_ == nullptr) {
    auto* p = CreateMaybeMessage<::evidence_package>(GetArenaForAllocation());
    support_ = p;
  }
  return support_;
}
inline ::evidence_package* trust_request_message::mutable_support() {
  ::evidence_package* _msg = _internal_mutable_support();
  // @@protoc_insertion_point(field_mutable:trust_request_message.support)
  return _msg;
}
inline void trust_request_message::set_allocated_support(::evidence_package* support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete support_;
  }
  if (support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::evidence_package>::GetOwningArena(support);
    if (message_arena != submessage_arena) {
      support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, support, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  support_ = support;
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.support)
}

// -------------------------------------------------------------------

// trust_response_message

// optional string status = 1;
inline bool trust_response_message::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trust_response_message::has_status() const {
  return _internal_has_status();
}
inline void trust_response_message::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trust_response_message::status() const {
  // @@protoc_insertion_point(field_get:trust_response_message.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_response_message::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_response_message.status)
}
inline std::string* trust_response_message::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:trust_response_message.status)
  return _s;
}
inline const std::string& trust_response_message::_internal_status() const {
  return status_.Get();
}
inline void trust_response_message::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_response_message::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_response_message::release_status() {
  // @@protoc_insertion_point(field_release:trust_response_message.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_response_message::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.status)
}

// optional string requesting_enclave_tag = 2;
inline bool trust_response_message::_internal_has_requesting_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trust_response_message::has_requesting_enclave_tag() const {
  return _internal_has_requesting_enclave_tag();
}
inline void trust_response_message::clear_requesting_enclave_tag() {
  requesting_enclave_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trust_response_message::requesting_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_response_message.requesting_enclave_tag)
  return _internal_requesting_enclave_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_response_message::set_requesting_enclave_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_response_message.requesting_enclave_tag)
}
inline std::string* trust_response_message::mutable_requesting_enclave_tag() {
  std::string* _s = _internal_mutable_requesting_enclave_tag();
  // @@protoc_insertion_point(field_mutable:trust_response_message.requesting_enclave_tag)
  return _s;
}
inline const std::string& trust_response_message::_internal_requesting_enclave_tag() const {
  return requesting_enclave_tag_.Get();
}
inline void trust_response_message::_internal_set_requesting_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  requesting_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_response_message::_internal_mutable_requesting_enclave_tag() {
  _has_bits_[0] |= 0x00000002u;
  return requesting_enclave_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_response_message::release_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_response_message.requesting_enclave_tag)
  if (!_internal_has_requesting_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = requesting_enclave_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_response_message::set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag) {
  if (requesting_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  requesting_enclave_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_enclave_tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.requesting_enclave_tag)
}

// optional string providing_enclave_tag = 3;
inline bool trust_response_message::_internal_has_providing_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool trust_response_message::has_providing_enclave_tag() const {
  return _internal_has_providing_enclave_tag();
}
inline void trust_response_message::clear_providing_enclave_tag() {
  providing_enclave_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& trust_response_message::providing_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_response_message.providing_enclave_tag)
  return _internal_providing_enclave_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_response_message::set_providing_enclave_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_response_message.providing_enclave_tag)
}
inline std::string* trust_response_message::mutable_providing_enclave_tag() {
  std::string* _s = _internal_mutable_providing_enclave_tag();
  // @@protoc_insertion_point(field_mutable:trust_response_message.providing_enclave_tag)
  return _s;
}
inline const std::string& trust_response_message::_internal_providing_enclave_tag() const {
  return providing_enclave_tag_.Get();
}
inline void trust_response_message::_internal_set_providing_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  providing_enclave_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_response_message::_internal_mutable_providing_enclave_tag() {
  _has_bits_[0] |= 0x00000004u;
  return providing_enclave_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_response_message::release_providing_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_response_message.providing_enclave_tag)
  if (!_internal_has_providing_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = providing_enclave_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (providing_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_response_message::set_allocated_providing_enclave_tag(std::string* providing_enclave_tag) {
  if (providing_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  providing_enclave_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), providing_enclave_tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (providing_enclave_tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    providing_enclave_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.providing_enclave_tag)
}

// optional bytes artifact = 4;
inline bool trust_response_message::_internal_has_artifact() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool trust_response_message::has_artifact() const {
  return _internal_has_artifact();
}
inline void trust_response_message::clear_artifact() {
  artifact_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& trust_response_message::artifact() const {
  // @@protoc_insertion_point(field_get:trust_response_message.artifact)
  return _internal_artifact();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trust_response_message::set_artifact(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 artifact_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trust_response_message.artifact)
}
inline std::string* trust_response_message::mutable_artifact() {
  std::string* _s = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:trust_response_message.artifact)
  return _s;
}
inline const std::string& trust_response_message::_internal_artifact() const {
  return artifact_.Get();
}
inline void trust_response_message::_internal_set_artifact(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  artifact_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trust_response_message::_internal_mutable_artifact() {
  _has_bits_[0] |= 0x00000008u;
  return artifact_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trust_response_message::release_artifact() {
  // @@protoc_insertion_point(field_release:trust_response_message.artifact)
  if (!_internal_has_artifact()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = artifact_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trust_response_message::set_allocated_artifact(std::string* artifact) {
  if (artifact != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  artifact_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.artifact)
}

// -------------------------------------------------------------------

// storage_info_message

// optional string storage_type = 1;
inline bool storage_info_message::_internal_has_storage_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool storage_info_message::has_storage_type() const {
  return _internal_has_storage_type();
}
inline void storage_info_message::clear_storage_type() {
  storage_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& storage_info_message::storage_type() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_type)
  return _internal_storage_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void storage_info_message::set_storage_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 storage_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:storage_info_message.storage_type)
}
inline std::string* storage_info_message::mutable_storage_type() {
  std::string* _s = _internal_mutable_storage_type();
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_type)
  return _s;
}
inline const std::string& storage_info_message::_internal_storage_type() const {
  return storage_type_.Get();
}
inline void storage_info_message::_internal_set_storage_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  storage_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* storage_info_message::_internal_mutable_storage_type() {
  _has_bits_[0] |= 0x00000001u;
  return storage_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* storage_info_message::release_storage_type() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_type)
  if (!_internal_has_storage_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = storage_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    storage_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void storage_info_message::set_allocated_storage_type(std::string* storage_type) {
  if (storage_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  storage_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storage_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    storage_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_type)
}

// optional string storage_descriptor = 2;
inline bool storage_info_message::_internal_has_storage_descriptor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool storage_info_message::has_storage_descriptor() const {
  return _internal_has_storage_descriptor();
}
inline void storage_info_message::clear_storage_descriptor() {
  storage_descriptor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& storage_info_message::storage_descriptor() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_descriptor)
  return _internal_storage_descriptor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void storage_info_message::set_storage_descriptor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 storage_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:storage_info_message.storage_descriptor)
}
inline std::string* storage_info_message::mutable_storage_descriptor() {
  std::string* _s = _internal_mutable_storage_descriptor();
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_descriptor)
  return _s;
}
inline const std::string& storage_info_message::_internal_storage_descriptor() const {
  return storage_descriptor_.Get();
}
inline void storage_info_message::_internal_set_storage_descriptor(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  storage_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* storage_info_message::_internal_mutable_storage_descriptor() {
  _has_bits_[0] |= 0x00000002u;
  return storage_descriptor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* storage_info_message::release_storage_descriptor() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_descriptor)
  if (!_internal_has_storage_descriptor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = storage_descriptor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_descriptor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    storage_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void storage_info_message::set_allocated_storage_descriptor(std::string* storage_descriptor) {
  if (storage_descriptor != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  storage_descriptor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storage_descriptor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_descriptor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    storage_descriptor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_descriptor)
}

// optional string address = 3;
inline bool storage_info_message::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool storage_info_message::has_address() const {
  return _internal_has_address();
}
inline void storage_info_message::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& storage_info_message::address() const {
  // @@protoc_insertion_point(field_get:storage_info_message.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void storage_info_message::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:storage_info_message.address)
}
inline std::string* storage_info_message::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:storage_info_message.address)
  return _s;
}
inline const std::string& storage_info_message::_internal_address() const {
  return address_.Get();
}
inline void storage_info_message::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* storage_info_message::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* storage_info_message::release_address() {
  // @@protoc_insertion_point(field_release:storage_info_message.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void storage_info_message::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.address)
}

// optional .key_message storage_key = 4;
inline bool storage_info_message::_internal_has_storage_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || storage_key_ != nullptr);
  return value;
}
inline bool storage_info_message::has_storage_key() const {
  return _internal_has_storage_key();
}
inline void storage_info_message::clear_storage_key() {
  if (storage_key_ != nullptr) storage_key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::key_message& storage_info_message::_internal_storage_key() const {
  const ::key_message* p = storage_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& storage_info_message::storage_key() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_key)
  return _internal_storage_key();
}
inline void storage_info_message::unsafe_arena_set_allocated_storage_key(
    ::key_message* storage_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage_key_);
  }
  storage_key_ = storage_key;
  if (storage_key) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage_info_message.storage_key)
}
inline ::key_message* storage_info_message::release_storage_key() {
  _has_bits_[0] &= ~0x00000010u;
  ::key_message* temp = storage_key_;
  storage_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* storage_info_message::unsafe_arena_release_storage_key() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_key)
  _has_bits_[0] &= ~0x00000010u;
  ::key_message* temp = storage_key_;
  storage_key_ = nullptr;
  return temp;
}
inline ::key_message* storage_info_message::_internal_mutable_storage_key() {
  _has_bits_[0] |= 0x00000010u;
  if (storage_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    storage_key_ = p;
  }
  return storage_key_;
}
inline ::key_message* storage_info_message::mutable_storage_key() {
  ::key_message* _msg = _internal_mutable_storage_key();
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_key)
  return _msg;
}
inline void storage_info_message::set_allocated_storage_key(::key_message* storage_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete storage_key_;
  }
  if (storage_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(storage_key);
    if (message_arena != submessage_arena) {
      storage_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  storage_key_ = storage_key;
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_key)
}

// optional string tag = 5;
inline bool storage_info_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool storage_info_message::has_tag() const {
  return _internal_has_tag();
}
inline void storage_info_message::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& storage_info_message::tag() const {
  // @@protoc_insertion_point(field_get:storage_info_message.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void storage_info_message::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:storage_info_message.tag)
}
inline std::string* storage_info_message::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:storage_info_message.tag)
  return _s;
}
inline const std::string& storage_info_message::_internal_tag() const {
  return tag_.Get();
}
inline void storage_info_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* storage_info_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000008u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* storage_info_message::release_tag() {
  // @@protoc_insertion_point(field_release:storage_info_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void storage_info_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.tag)
}

// -------------------------------------------------------------------

// channel_key_message

// optional string tag = 1;
inline bool channel_key_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool channel_key_message::has_tag() const {
  return _internal_has_tag();
}
inline void channel_key_message::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& channel_key_message::tag() const {
  // @@protoc_insertion_point(field_get:channel_key_message.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void channel_key_message::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:channel_key_message.tag)
}
inline std::string* channel_key_message::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:channel_key_message.tag)
  return _s;
}
inline const std::string& channel_key_message::_internal_tag() const {
  return tag_.Get();
}
inline void channel_key_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* channel_key_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* channel_key_message::release_tag() {
  // @@protoc_insertion_point(field_release:channel_key_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void channel_key_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:channel_key_message.tag)
}

// optional .key_message auth_key = 2;
inline bool channel_key_message::_internal_has_auth_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || auth_key_ != nullptr);
  return value;
}
inline bool channel_key_message::has_auth_key() const {
  return _internal_has_auth_key();
}
inline void channel_key_message::clear_auth_key() {
  if (auth_key_ != nullptr) auth_key_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::key_message& channel_key_message::_internal_auth_key() const {
  const ::key_message* p = auth_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& channel_key_message::auth_key() const {
  // @@protoc_insertion_point(field_get:channel_key_message.auth_key)
  return _internal_auth_key();
}
inline void channel_key_message::unsafe_arena_set_allocated_auth_key(
    ::key_message* auth_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_key_);
  }
  auth_key_ = auth_key;
  if (auth_key) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:channel_key_message.auth_key)
}
inline ::key_message* channel_key_message::release_auth_key() {
  _has_bits_[0] &= ~0x00000002u;
  ::key_message* temp = auth_key_;
  auth_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* channel_key_message::unsafe_arena_release_auth_key() {
  // @@protoc_insertion_point(field_release:channel_key_message.auth_key)
  _has_bits_[0] &= ~0x00000002u;
  ::key_message* temp = auth_key_;
  auth_key_ = nullptr;
  return temp;
}
inline ::key_message* channel_key_message::_internal_mutable_auth_key() {
  _has_bits_[0] |= 0x00000002u;
  if (auth_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    auth_key_ = p;
  }
  return auth_key_;
}
inline ::key_message* channel_key_message::mutable_auth_key() {
  ::key_message* _msg = _internal_mutable_auth_key();
  // @@protoc_insertion_point(field_mutable:channel_key_message.auth_key)
  return _msg;
}
inline void channel_key_message::set_allocated_auth_key(::key_message* auth_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_key_;
  }
  if (auth_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(auth_key);
    if (message_arena != submessage_arena) {
      auth_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  auth_key_ = auth_key;
  // @@protoc_insertion_point(field_set_allocated:channel_key_message.auth_key)
}

// -------------------------------------------------------------------

// trusted_service_message

// optional string trusted_service_address = 1;
inline bool trusted_service_message::_internal_has_trusted_service_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trusted_service_message::has_trusted_service_address() const {
  return _internal_has_trusted_service_address();
}
inline void trusted_service_message::clear_trusted_service_address() {
  trusted_service_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trusted_service_message::trusted_service_address() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.trusted_service_address)
  return _internal_trusted_service_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trusted_service_message::set_trusted_service_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 trusted_service_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trusted_service_message.trusted_service_address)
}
inline std::string* trusted_service_message::mutable_trusted_service_address() {
  std::string* _s = _internal_mutable_trusted_service_address();
  // @@protoc_insertion_point(field_mutable:trusted_service_message.trusted_service_address)
  return _s;
}
inline const std::string& trusted_service_message::_internal_trusted_service_address() const {
  return trusted_service_address_.Get();
}
inline void trusted_service_message::_internal_set_trusted_service_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trusted_service_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trusted_service_message::_internal_mutable_trusted_service_address() {
  _has_bits_[0] |= 0x00000001u;
  return trusted_service_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trusted_service_message::release_trusted_service_address() {
  // @@protoc_insertion_point(field_release:trusted_service_message.trusted_service_address)
  if (!_internal_has_trusted_service_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = trusted_service_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trusted_service_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trusted_service_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trusted_service_message::set_allocated_trusted_service_address(std::string* trusted_service_address) {
  if (trusted_service_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trusted_service_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trusted_service_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trusted_service_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trusted_service_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.trusted_service_address)
}

// optional .key_message trusted_service_key = 2;
inline bool trusted_service_message::_internal_has_trusted_service_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || trusted_service_key_ != nullptr);
  return value;
}
inline bool trusted_service_message::has_trusted_service_key() const {
  return _internal_has_trusted_service_key();
}
inline void trusted_service_message::clear_trusted_service_key() {
  if (trusted_service_key_ != nullptr) trusted_service_key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& trusted_service_message::_internal_trusted_service_key() const {
  const ::key_message* p = trusted_service_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& trusted_service_message::trusted_service_key() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.trusted_service_key)
  return _internal_trusted_service_key();
}
inline void trusted_service_message::unsafe_arena_set_allocated_trusted_service_key(
    ::key_message* trusted_service_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trusted_service_key_);
  }
  trusted_service_key_ = trusted_service_key;
  if (trusted_service_key) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_service_message.trusted_service_key)
}
inline ::key_message* trusted_service_message::release_trusted_service_key() {
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = trusted_service_key_;
  trusted_service_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* trusted_service_message::unsafe_arena_release_trusted_service_key() {
  // @@protoc_insertion_point(field_release:trusted_service_message.trusted_service_key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = trusted_service_key_;
  trusted_service_key_ = nullptr;
  return temp;
}
inline ::key_message* trusted_service_message::_internal_mutable_trusted_service_key() {
  _has_bits_[0] |= 0x00000004u;
  if (trusted_service_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    trusted_service_key_ = p;
  }
  return trusted_service_key_;
}
inline ::key_message* trusted_service_message::mutable_trusted_service_key() {
  ::key_message* _msg = _internal_mutable_trusted_service_key();
  // @@protoc_insertion_point(field_mutable:trusted_service_message.trusted_service_key)
  return _msg;
}
inline void trusted_service_message::set_allocated_trusted_service_key(::key_message* trusted_service_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trusted_service_key_;
  }
  if (trusted_service_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(trusted_service_key);
    if (message_arena != submessage_arena) {
      trusted_service_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trusted_service_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  trusted_service_key_ = trusted_service_key;
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.trusted_service_key)
}

// optional string tag = 3;
inline bool trusted_service_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trusted_service_message::has_tag() const {
  return _internal_has_tag();
}
inline void trusted_service_message::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trusted_service_message::tag() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void trusted_service_message::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trusted_service_message.tag)
}
inline std::string* trusted_service_message::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:trusted_service_message.tag)
  return _s;
}
inline const std::string& trusted_service_message::_internal_tag() const {
  return tag_.Get();
}
inline void trusted_service_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* trusted_service_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* trusted_service_message::release_tag() {
  // @@protoc_insertion_point(field_release:trusted_service_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void trusted_service_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.tag)
}

// -------------------------------------------------------------------

// tagged_claim

// optional string tag = 1;
inline bool tagged_claim::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_claim::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_claim::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_claim::tag() const {
  // @@protoc_insertion_point(field_get:tagged_claim.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void tagged_claim::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tagged_claim.tag)
}
inline std::string* tagged_claim::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:tagged_claim.tag)
  return _s;
}
inline const std::string& tagged_claim::_internal_tag() const {
  return tag_.Get();
}
inline void tagged_claim::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* tagged_claim::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* tagged_claim::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_claim.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void tagged_claim::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tagged_claim.tag)
}

// optional .claim_message claim = 2;
inline bool tagged_claim::_internal_has_claim() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || claim_ != nullptr);
  return value;
}
inline bool tagged_claim::has_claim() const {
  return _internal_has_claim();
}
inline void tagged_claim::clear_claim() {
  if (claim_ != nullptr) claim_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::claim_message& tagged_claim::_internal_claim() const {
  const ::claim_message* p = claim_;
  return p != nullptr ? *p : reinterpret_cast<const ::claim_message&>(
      ::_claim_message_default_instance_);
}
inline const ::claim_message& tagged_claim::claim() const {
  // @@protoc_insertion_point(field_get:tagged_claim.claim)
  return _internal_claim();
}
inline void tagged_claim::unsafe_arena_set_allocated_claim(
    ::claim_message* claim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claim_);
  }
  claim_ = claim;
  if (claim) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tagged_claim.claim)
}
inline ::claim_message* tagged_claim::release_claim() {
  _has_bits_[0] &= ~0x00000002u;
  ::claim_message* temp = claim_;
  claim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::claim_message* tagged_claim::unsafe_arena_release_claim() {
  // @@protoc_insertion_point(field_release:tagged_claim.claim)
  _has_bits_[0] &= ~0x00000002u;
  ::claim_message* temp = claim_;
  claim_ = nullptr;
  return temp;
}
inline ::claim_message* tagged_claim::_internal_mutable_claim() {
  _has_bits_[0] |= 0x00000002u;
  if (claim_ == nullptr) {
    auto* p = CreateMaybeMessage<::claim_message>(GetArenaForAllocation());
    claim_ = p;
  }
  return claim_;
}
inline ::claim_message* tagged_claim::mutable_claim() {
  ::claim_message* _msg = _internal_mutable_claim();
  // @@protoc_insertion_point(field_mutable:tagged_claim.claim)
  return _msg;
}
inline void tagged_claim::set_allocated_claim(::claim_message* claim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete claim_;
  }
  if (claim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::claim_message>::GetOwningArena(claim);
    if (message_arena != submessage_arena) {
      claim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claim, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  claim_ = claim;
  // @@protoc_insertion_point(field_set_allocated:tagged_claim.claim)
}

// -------------------------------------------------------------------

// tagged_claims_sequence

// repeated .tagged_claim claims = 1;
inline int tagged_claims_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int tagged_claims_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void tagged_claims_sequence::clear_claims() {
  claims_.Clear();
}
inline ::tagged_claim* tagged_claims_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:tagged_claims_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
tagged_claims_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:tagged_claims_sequence.claims)
  return &claims_;
}
inline const ::tagged_claim& tagged_claims_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::tagged_claim& tagged_claims_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:tagged_claims_sequence.claims)
  return _internal_claims(index);
}
inline ::tagged_claim* tagged_claims_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::tagged_claim* tagged_claims_sequence::add_claims() {
  ::tagged_claim* _add = _internal_add_claims();
  // @@protoc_insertion_point(field_add:tagged_claims_sequence.claims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
tagged_claims_sequence::claims() const {
  // @@protoc_insertion_point(field_list:tagged_claims_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// policy_store_message

// optional .key_message policy_key = 1;
inline bool policy_store_message::_internal_has_policy_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || policy_key_ != nullptr);
  return value;
}
inline bool policy_store_message::has_policy_key() const {
  return _internal_has_policy_key();
}
inline void policy_store_message::clear_policy_key() {
  if (policy_key_ != nullptr) policy_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::key_message& policy_store_message::_internal_policy_key() const {
  const ::key_message* p = policy_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::key_message&>(
      ::_key_message_default_instance_);
}
inline const ::key_message& policy_store_message::policy_key() const {
  // @@protoc_insertion_point(field_get:policy_store_message.policy_key)
  return _internal_policy_key();
}
inline void policy_store_message::unsafe_arena_set_allocated_policy_key(
    ::key_message* policy_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policy_key_);
  }
  policy_key_ = policy_key;
  if (policy_key) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:policy_store_message.policy_key)
}
inline ::key_message* policy_store_message::release_policy_key() {
  _has_bits_[0] &= ~0x00000001u;
  ::key_message* temp = policy_key_;
  policy_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::key_message* policy_store_message::unsafe_arena_release_policy_key() {
  // @@protoc_insertion_point(field_release:policy_store_message.policy_key)
  _has_bits_[0] &= ~0x00000001u;
  ::key_message* temp = policy_key_;
  policy_key_ = nullptr;
  return temp;
}
inline ::key_message* policy_store_message::_internal_mutable_policy_key() {
  _has_bits_[0] |= 0x00000001u;
  if (policy_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaForAllocation());
    policy_key_ = p;
  }
  return policy_key_;
}
inline ::key_message* policy_store_message::mutable_policy_key() {
  ::key_message* _msg = _internal_mutable_policy_key();
  // @@protoc_insertion_point(field_mutable:policy_store_message.policy_key)
  return _msg;
}
inline void policy_store_message::set_allocated_policy_key(::key_message* policy_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete policy_key_;
  }
  if (policy_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::key_message>::GetOwningArena(policy_key);
    if (message_arena != submessage_arena) {
      policy_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  policy_key_ = policy_key;
  // @@protoc_insertion_point(field_set_allocated:policy_store_message.policy_key)
}

// repeated .trusted_service_message trusted_services = 2;
inline int policy_store_message::_internal_trusted_services_size() const {
  return trusted_services_.size();
}
inline int policy_store_message::trusted_services_size() const {
  return _internal_trusted_services_size();
}
inline void policy_store_message::clear_trusted_services() {
  trusted_services_.Clear();
}
inline ::trusted_service_message* policy_store_message::mutable_trusted_services(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.trusted_services)
  return trusted_services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >*
policy_store_message::mutable_trusted_services() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.trusted_services)
  return &trusted_services_;
}
inline const ::trusted_service_message& policy_store_message::_internal_trusted_services(int index) const {
  return trusted_services_.Get(index);
}
inline const ::trusted_service_message& policy_store_message::trusted_services(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.trusted_services)
  return _internal_trusted_services(index);
}
inline ::trusted_service_message* policy_store_message::_internal_add_trusted_services() {
  return trusted_services_.Add();
}
inline ::trusted_service_message* policy_store_message::add_trusted_services() {
  ::trusted_service_message* _add = _internal_add_trusted_services();
  // @@protoc_insertion_point(field_add:policy_store_message.trusted_services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >&
policy_store_message::trusted_services() const {
  // @@protoc_insertion_point(field_list:policy_store_message.trusted_services)
  return trusted_services_;
}

// repeated .channel_key_message channel_authentication_keys = 3;
inline int policy_store_message::_internal_channel_authentication_keys_size() const {
  return channel_authentication_keys_.size();
}
inline int policy_store_message::channel_authentication_keys_size() const {
  return _internal_channel_authentication_keys_size();
}
inline void policy_store_message::clear_channel_authentication_keys() {
  channel_authentication_keys_.Clear();
}
inline ::channel_key_message* policy_store_message::mutable_channel_authentication_keys(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.channel_authentication_keys)
  return channel_authentication_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >*
policy_store_message::mutable_channel_authentication_keys() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.channel_authentication_keys)
  return &channel_authentication_keys_;
}
inline const ::channel_key_message& policy_store_message::_internal_channel_authentication_keys(int index) const {
  return channel_authentication_keys_.Get(index);
}
inline const ::channel_key_message& policy_store_message::channel_authentication_keys(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.channel_authentication_keys)
  return _internal_channel_authentication_keys(index);
}
inline ::channel_key_message* policy_store_message::_internal_add_channel_authentication_keys() {
  return channel_authentication_keys_.Add();
}
inline ::channel_key_message* policy_store_message::add_channel_authentication_keys() {
  ::channel_key_message* _add = _internal_add_channel_authentication_keys();
  // @@protoc_insertion_point(field_add:policy_store_message.channel_authentication_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >&
policy_store_message::channel_authentication_keys() const {
  // @@protoc_insertion_point(field_list:policy_store_message.channel_authentication_keys)
  return channel_authentication_keys_;
}

// repeated .tagged_claim claims = 4;
inline int policy_store_message::_internal_claims_size() const {
  return claims_.size();
}
inline int policy_store_message::claims_size() const {
  return _internal_claims_size();
}
inline void policy_store_message::clear_claims() {
  claims_.Clear();
}
inline ::tagged_claim* policy_store_message::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
policy_store_message::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.claims)
  return &claims_;
}
inline const ::tagged_claim& policy_store_message::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::tagged_claim& policy_store_message::claims(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.claims)
  return _internal_claims(index);
}
inline ::tagged_claim* policy_store_message::_internal_add_claims() {
  return claims_.Add();
}
inline ::tagged_claim* policy_store_message::add_claims() {
  ::tagged_claim* _add = _internal_add_claims();
  // @@protoc_insertion_point(field_add:policy_store_message.claims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
policy_store_message::claims() const {
  // @@protoc_insertion_point(field_list:policy_store_message.claims)
  return claims_;
}

// repeated .storage_info_message storage_info = 5;
inline int policy_store_message::_internal_storage_info_size() const {
  return storage_info_.size();
}
inline int policy_store_message::storage_info_size() const {
  return _internal_storage_info_size();
}
inline void policy_store_message::clear_storage_info() {
  storage_info_.Clear();
}
inline ::storage_info_message* policy_store_message::mutable_storage_info(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.storage_info)
  return storage_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >*
policy_store_message::mutable_storage_info() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.storage_info)
  return &storage_info_;
}
inline const ::storage_info_message& policy_store_message::_internal_storage_info(int index) const {
  return storage_info_.Get(index);
}
inline const ::storage_info_message& policy_store_message::storage_info(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.storage_info)
  return _internal_storage_info(index);
}
inline ::storage_info_message* policy_store_message::_internal_add_storage_info() {
  return storage_info_.Add();
}
inline ::storage_info_message* policy_store_message::add_storage_info() {
  ::storage_info_message* _add = _internal_add_storage_info();
  // @@protoc_insertion_point(field_add:policy_store_message.storage_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >&
policy_store_message::storage_info() const {
  // @@protoc_insertion_point(field_list:policy_store_message.storage_info)
  return storage_info_;
}

// repeated .tagged_signed_claim signed_claims = 6;
inline int policy_store_message::_internal_signed_claims_size() const {
  return signed_claims_.size();
}
inline int policy_store_message::signed_claims_size() const {
  return _internal_signed_claims_size();
}
inline void policy_store_message::clear_signed_claims() {
  signed_claims_.Clear();
}
inline ::tagged_signed_claim* policy_store_message::mutable_signed_claims(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.signed_claims)
  return signed_claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >*
policy_store_message::mutable_signed_claims() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.signed_claims)
  return &signed_claims_;
}
inline const ::tagged_signed_claim& policy_store_message::_internal_signed_claims(int index) const {
  return signed_claims_.Get(index);
}
inline const ::tagged_signed_claim& policy_store_message::signed_claims(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.signed_claims)
  return _internal_signed_claims(index);
}
inline ::tagged_signed_claim* policy_store_message::_internal_add_signed_claims() {
  return signed_claims_.Add();
}
inline ::tagged_signed_claim* policy_store_message::add_signed_claims() {
  ::tagged_signed_claim* _add = _internal_add_signed_claims();
  // @@protoc_insertion_point(field_add:policy_store_message.signed_claims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >&
policy_store_message::signed_claims() const {
  // @@protoc_insertion_point(field_list:policy_store_message.signed_claims)
  return signed_claims_;
}

// repeated .tagged_blob_message blobs = 7;
inline int policy_store_message::_internal_blobs_size() const {
  return blobs_.size();
}
inline int policy_store_message::blobs_size() const {
  return _internal_blobs_size();
}
inline void policy_store_message::clear_blobs() {
  blobs_.Clear();
}
inline ::tagged_blob_message* policy_store_message::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.blobs)
  return blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >*
policy_store_message::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.blobs)
  return &blobs_;
}
inline const ::tagged_blob_message& policy_store_message::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const ::tagged_blob_message& policy_store_message::blobs(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.blobs)
  return _internal_blobs(index);
}
inline ::tagged_blob_message* policy_store_message::_internal_add_blobs() {
  return blobs_.Add();
}
inline ::tagged_blob_message* policy_store_message::add_blobs() {
  ::tagged_blob_message* _add = _internal_add_blobs();
  // @@protoc_insertion_point(field_add:policy_store_message.blobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >&
policy_store_message::blobs() const {
  // @@protoc_insertion_point(field_list:policy_store_message.blobs)
  return blobs_;
}

// -------------------------------------------------------------------

// claims_sequence

// repeated .claim_message claims = 1;
inline int claims_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int claims_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void claims_sequence::clear_claims() {
  claims_.Clear();
}
inline ::claim_message* claims_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:claims_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >*
claims_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:claims_sequence.claims)
  return &claims_;
}
inline const ::claim_message& claims_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::claim_message& claims_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:claims_sequence.claims)
  return _internal_claims(index);
}
inline ::claim_message* claims_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::claim_message* claims_sequence::add_claims() {
  ::claim_message* _add = _internal_add_claims();
  // @@protoc_insertion_point(field_add:claims_sequence.claims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >&
claims_sequence::claims() const {
  // @@protoc_insertion_point(field_list:claims_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// signed_claim_sequence

// repeated .signed_claim_message claims = 1;
inline int signed_claim_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int signed_claim_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void signed_claim_sequence::clear_claims() {
  claims_.Clear();
}
inline ::signed_claim_message* signed_claim_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:signed_claim_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >*
signed_claim_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:signed_claim_sequence.claims)
  return &claims_;
}
inline const ::signed_claim_message& signed_claim_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::signed_claim_message& signed_claim_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:signed_claim_sequence.claims)
  return _internal_claims(index);
}
inline ::signed_claim_message* signed_claim_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::signed_claim_message* signed_claim_sequence::add_claims() {
  ::signed_claim_message* _add = _internal_add_claims();
  // @@protoc_insertion_point(field_add:signed_claim_sequence.claims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >&
signed_claim_sequence::claims() const {
  // @@protoc_insertion_point(field_list:signed_claim_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// tagged_signed_claim

// optional string tag = 1;
inline bool tagged_signed_claim::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_signed_claim::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_signed_claim::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_signed_claim::tag() const {
  // @@protoc_insertion_point(field_get:tagged_signed_claim.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void tagged_signed_claim::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tagged_signed_claim.tag)
}
inline std::string* tagged_signed_claim::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:tagged_signed_claim.tag)
  return _s;
}
inline const std::string& tagged_signed_claim::_internal_tag() const {
  return tag_.Get();
}
inline void tagged_signed_claim::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* tagged_signed_claim::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* tagged_signed_claim::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_signed_claim.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void tagged_signed_claim::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tagged_signed_claim.tag)
}

// optional .signed_claim_message sc = 2;
inline bool tagged_signed_claim::_internal_has_sc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || sc_ != nullptr);
  return value;
}
inline bool tagged_signed_claim::has_sc() const {
  return _internal_has_sc();
}
inline void tagged_signed_claim::clear_sc() {
  if (sc_ != nullptr) sc_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::signed_claim_message& tagged_signed_claim::_internal_sc() const {
  const ::signed_claim_message* p = sc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signed_claim_message&>(
      ::_signed_claim_message_default_instance_);
}
inline const ::signed_claim_message& tagged_signed_claim::sc() const {
  // @@protoc_insertion_point(field_get:tagged_signed_claim.sc)
  return _internal_sc();
}
inline void tagged_signed_claim::unsafe_arena_set_allocated_sc(
    ::signed_claim_message* sc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sc_);
  }
  sc_ = sc;
  if (sc) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tagged_signed_claim.sc)
}
inline ::signed_claim_message* tagged_signed_claim::release_sc() {
  _has_bits_[0] &= ~0x00000002u;
  ::signed_claim_message* temp = sc_;
  sc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::signed_claim_message* tagged_signed_claim::unsafe_arena_release_sc() {
  // @@protoc_insertion_point(field_release:tagged_signed_claim.sc)
  _has_bits_[0] &= ~0x00000002u;
  ::signed_claim_message* temp = sc_;
  sc_ = nullptr;
  return temp;
}
inline ::signed_claim_message* tagged_signed_claim::_internal_mutable_sc() {
  _has_bits_[0] |= 0x00000002u;
  if (sc_ == nullptr) {
    auto* p = CreateMaybeMessage<::signed_claim_message>(GetArenaForAllocation());
    sc_ = p;
  }
  return sc_;
}
inline ::signed_claim_message* tagged_signed_claim::mutable_sc() {
  ::signed_claim_message* _msg = _internal_mutable_sc();
  // @@protoc_insertion_point(field_mutable:tagged_signed_claim.sc)
  return _msg;
}
inline void tagged_signed_claim::set_allocated_sc(::signed_claim_message* sc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sc_;
  }
  if (sc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::signed_claim_message>::GetOwningArena(sc);
    if (message_arena != submessage_arena) {
      sc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sc_ = sc;
  // @@protoc_insertion_point(field_set_allocated:tagged_signed_claim.sc)
}

// -------------------------------------------------------------------

// buffer_sequence

// repeated bytes block = 1;
inline int buffer_sequence::_internal_block_size() const {
  return block_.size();
}
inline int buffer_sequence::block_size() const {
  return _internal_block_size();
}
inline void buffer_sequence::clear_block() {
  block_.Clear();
}
inline std::string* buffer_sequence::add_block() {
  std::string* _s = _internal_add_block();
  // @@protoc_insertion_point(field_add_mutable:buffer_sequence.block)
  return _s;
}
inline const std::string& buffer_sequence::_internal_block(int index) const {
  return block_.Get(index);
}
inline const std::string& buffer_sequence::block(int index) const {
  // @@protoc_insertion_point(field_get:buffer_sequence.block)
  return _internal_block(index);
}
inline std::string* buffer_sequence::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:buffer_sequence.block)
  return block_.Mutable(index);
}
inline void buffer_sequence::set_block(int index, const std::string& value) {
  block_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buffer_sequence.block)
}
inline void buffer_sequence::set_block(int index, std::string&& value) {
  block_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buffer_sequence.block)
}
inline void buffer_sequence::set_block(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffer_sequence.block)
}
inline void buffer_sequence::set_block(int index, const void* value, size_t size) {
  block_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffer_sequence.block)
}
inline std::string* buffer_sequence::_internal_add_block() {
  return block_.Add();
}
inline void buffer_sequence::add_block(const std::string& value) {
  block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffer_sequence.block)
}
inline void buffer_sequence::add_block(std::string&& value) {
  block_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffer_sequence.block)
}
inline void buffer_sequence::add_block(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffer_sequence.block)
}
inline void buffer_sequence::add_block(const void* value, size_t size) {
  block_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffer_sequence.block)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
buffer_sequence::block() const {
  // @@protoc_insertion_point(field_list:buffer_sequence.block)
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
buffer_sequence::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:buffer_sequence.block)
  return &block_;
}

// -------------------------------------------------------------------

// run_request

// optional string location = 1;
inline bool run_request::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool run_request::has_location() const {
  return _internal_has_location();
}
inline void run_request::clear_location() {
  location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& run_request::location() const {
  // @@protoc_insertion_point(field_get:run_request.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void run_request::set_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:run_request.location)
}
inline std::string* run_request::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:run_request.location)
  return _s;
}
inline const std::string& run_request::_internal_location() const {
  return location_.Get();
}
inline void run_request::_internal_set_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* run_request::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* run_request::release_location() {
  // @@protoc_insertion_point(field_release:run_request.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void run_request::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:run_request.location)
}

// optional bytes cert = 2;
inline bool run_request::_internal_has_cert() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool run_request::has_cert() const {
  return _internal_has_cert();
}
inline void run_request::clear_cert() {
  cert_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& run_request::cert() const {
  // @@protoc_insertion_point(field_get:run_request.cert)
  return _internal_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void run_request::set_cert(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 cert_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:run_request.cert)
}
inline std::string* run_request::mutable_cert() {
  std::string* _s = _internal_mutable_cert();
  // @@protoc_insertion_point(field_mutable:run_request.cert)
  return _s;
}
inline const std::string& run_request::_internal_cert() const {
  return cert_.Get();
}
inline void run_request::_internal_set_cert(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* run_request::_internal_mutable_cert() {
  _has_bits_[0] |= 0x00000002u;
  return cert_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* run_request::release_cert() {
  // @@protoc_insertion_point(field_release:run_request.cert)
  if (!_internal_has_cert()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = cert_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cert_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void run_request::set_allocated_cert(std::string* cert) {
  if (cert != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cert_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cert,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cert_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:run_request.cert)
}

// repeated string args = 3;
inline int run_request::_internal_args_size() const {
  return args_.size();
}
inline int run_request::args_size() const {
  return _internal_args_size();
}
inline void run_request::clear_args() {
  args_.Clear();
}
inline std::string* run_request::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:run_request.args)
  return _s;
}
inline const std::string& run_request::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& run_request::args(int index) const {
  // @@protoc_insertion_point(field_get:run_request.args)
  return _internal_args(index);
}
inline std::string* run_request::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:run_request.args)
  return args_.Mutable(index);
}
inline void run_request::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:run_request.args)
}
inline void run_request::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:run_request.args)
}
inline void run_request::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:run_request.args)
}
inline void run_request::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:run_request.args)
}
inline std::string* run_request::_internal_add_args() {
  return args_.Add();
}
inline void run_request::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:run_request.args)
}
inline void run_request::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:run_request.args)
}
inline void run_request::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:run_request.args)
}
inline void run_request::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:run_request.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
run_request::args() const {
  // @@protoc_insertion_point(field_list:run_request.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
run_request::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:run_request.args)
  return &args_;
}

// -------------------------------------------------------------------

// run_response

// optional string status = 1;
inline bool run_response::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool run_response::has_status() const {
  return _internal_has_status();
}
inline void run_response::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& run_response::status() const {
  // @@protoc_insertion_point(field_get:run_response.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void run_response::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:run_response.status)
}
inline std::string* run_response::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:run_response.status)
  return _s;
}
inline const std::string& run_response::_internal_status() const {
  return status_.Get();
}
inline void run_response::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* run_response::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* run_response::release_status() {
  // @@protoc_insertion_point(field_release:run_response.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void run_response::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:run_response.status)
}

// -------------------------------------------------------------------

// app_request

// optional string function = 1;
inline bool app_request::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool app_request::has_function() const {
  return _internal_has_function();
}
inline void app_request::clear_function() {
  function_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& app_request::function() const {
  // @@protoc_insertion_point(field_get:app_request.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void app_request::set_function(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:app_request.function)
}
inline std::string* app_request::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:app_request.function)
  return _s;
}
inline const std::string& app_request::_internal_function() const {
  return function_.Get();
}
inline void app_request::_internal_set_function(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* app_request::_internal_mutable_function() {
  _has_bits_[0] |= 0x00000001u;
  return function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* app_request::release_function() {
  // @@protoc_insertion_point(field_release:app_request.function)
  if (!_internal_has_function()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = function_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void app_request::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:app_request.function)
}

// repeated bytes args = 2;
inline int app_request::_internal_args_size() const {
  return args_.size();
}
inline int app_request::args_size() const {
  return _internal_args_size();
}
inline void app_request::clear_args() {
  args_.Clear();
}
inline std::string* app_request::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:app_request.args)
  return _s;
}
inline const std::string& app_request::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& app_request::args(int index) const {
  // @@protoc_insertion_point(field_get:app_request.args)
  return _internal_args(index);
}
inline std::string* app_request::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:app_request.args)
  return args_.Mutable(index);
}
inline void app_request::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:app_request.args)
}
inline void app_request::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:app_request.args)
}
inline void app_request::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:app_request.args)
}
inline void app_request::set_args(int index, const void* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:app_request.args)
}
inline std::string* app_request::_internal_add_args() {
  return args_.Add();
}
inline void app_request::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:app_request.args)
}
inline void app_request::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:app_request.args)
}
inline void app_request::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:app_request.args)
}
inline void app_request::add_args(const void* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:app_request.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
app_request::args() const {
  // @@protoc_insertion_point(field_list:app_request.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
app_request::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:app_request.args)
  return &args_;
}

// -------------------------------------------------------------------

// app_response

// optional string function = 1;
inline bool app_response::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool app_response::has_function() const {
  return _internal_has_function();
}
inline void app_response::clear_function() {
  function_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& app_response::function() const {
  // @@protoc_insertion_point(field_get:app_response.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void app_response::set_function(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:app_response.function)
}
inline std::string* app_response::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:app_response.function)
  return _s;
}
inline const std::string& app_response::_internal_function() const {
  return function_.Get();
}
inline void app_response::_internal_set_function(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* app_response::_internal_mutable_function() {
  _has_bits_[0] |= 0x00000001u;
  return function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* app_response::release_function() {
  // @@protoc_insertion_point(field_release:app_response.function)
  if (!_internal_has_function()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = function_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void app_response::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:app_response.function)
}

// optional string status = 2;
inline bool app_response::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool app_response::has_status() const {
  return _internal_has_status();
}
inline void app_response::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& app_response::status() const {
  // @@protoc_insertion_point(field_get:app_response.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void app_response::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:app_response.status)
}
inline std::string* app_response::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:app_response.status)
  return _s;
}
inline const std::string& app_response::_internal_status() const {
  return status_.Get();
}
inline void app_response::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* app_response::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* app_response::release_status() {
  // @@protoc_insertion_point(field_release:app_response.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void app_response::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:app_response.status)
}

// repeated bytes args = 3;
inline int app_response::_internal_args_size() const {
  return args_.size();
}
inline int app_response::args_size() const {
  return _internal_args_size();
}
inline void app_response::clear_args() {
  args_.Clear();
}
inline std::string* app_response::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:app_response.args)
  return _s;
}
inline const std::string& app_response::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& app_response::args(int index) const {
  // @@protoc_insertion_point(field_get:app_response.args)
  return _internal_args(index);
}
inline std::string* app_response::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:app_response.args)
  return args_.Mutable(index);
}
inline void app_response::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:app_response.args)
}
inline void app_response::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:app_response.args)
}
inline void app_response::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:app_response.args)
}
inline void app_response::set_args(int index, const void* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:app_response.args)
}
inline std::string* app_response::_internal_add_args() {
  return args_.Add();
}
inline void app_response::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:app_response.args)
}
inline void app_response::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:app_response.args)
}
inline void app_response::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:app_response.args)
}
inline void app_response::add_args(const void* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:app_response.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
app_response::args() const {
  // @@protoc_insertion_point(field_list:app_response.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
app_response::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:app_response.args)
  return &args_;
}

// -------------------------------------------------------------------

// tagged_blob_message

// optional string tag = 1;
inline bool tagged_blob_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_blob_message::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_blob_message::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_blob_message::tag() const {
  // @@protoc_insertion_point(field_get:tagged_blob_message.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void tagged_blob_message::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tagged_blob_message.tag)
}
inline std::string* tagged_blob_message::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:tagged_blob_message.tag)
  return _s;
}
inline const std::string& tagged_blob_message::_internal_tag() const {
  return tag_.Get();
}
inline void tagged_blob_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* tagged_blob_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* tagged_blob_message::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_blob_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void tagged_blob_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tagged_blob_message.tag)
}

// optional bytes b = 2;
inline bool tagged_blob_message::_internal_has_b() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool tagged_blob_message::has_b() const {
  return _internal_has_b();
}
inline void tagged_blob_message::clear_b() {
  b_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& tagged_blob_message::b() const {
  // @@protoc_insertion_point(field_get:tagged_blob_message.b)
  return _internal_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void tagged_blob_message::set_b(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 b_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tagged_blob_message.b)
}
inline std::string* tagged_blob_message::mutable_b() {
  std::string* _s = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:tagged_blob_message.b)
  return _s;
}
inline const std::string& tagged_blob_message::_internal_b() const {
  return b_.Get();
}
inline void tagged_blob_message::_internal_set_b(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  b_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* tagged_blob_message::_internal_mutable_b() {
  _has_bits_[0] |= 0x00000002u;
  return b_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* tagged_blob_message::release_b() {
  // @@protoc_insertion_point(field_release:tagged_blob_message.b)
  if (!_internal_has_b()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = b_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (b_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void tagged_blob_message::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  b_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), b,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (b_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    b_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tagged_blob_message.b)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto
